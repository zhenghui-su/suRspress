[{"id":0,"title":"","content":"工程化#","routePath":"/guide/engineering/","lang":"","toc":[{"text":"工程化","id":"工程化","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"Vite 系列前言","content":"#\n\nWebpack：老牌构建工具，生态丰富\n\nVite：解决了 Webpack 的一些问题，降低心智负担\n\n由 Vue 团队推出，但它也支持构建 React、Angular、Svelte 项目\n\n分如下一些模块：\n\n * 什么是构建工具\n * Webpack 的一个缺点在哪\n * ES Module 的规范\n * Vite 是什么\n * Vite 的基本安装和使用\n * Vite 的编译结果\n * Vite 的编译结果的分析\n * Vite 的配置文件\n * Vite 中如何处理CSS、静态资源\n * Vite 的插件以及常用插件的使用\n * Vite 和 TypeScript 的结合\n * Vite 构建 React 项目、Svelte 项目、Vue3 项目\n * Vite 的构建原理","routePath":"/guide/engineering/vite/1-Vite系列前言","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"Vite 中处理 CSS","content":"#\n\n\nVite 中处理原生 CSS#\n\nVite 天生就支持对 CSS 文件的直接处理\n\n\n\n上面的处理分几步：\n\n * Vite 在读取到 main.js 中，发现引用了 index.css\n * 直接使用 fs 模块去读取index.css中的文件内容\n * 然后创建一个 style 标签，将 index.css 中的内容 copy 到 style 标签中\n * 将 style 标签插入到 index.html的 head 中\n * 将该 CSS 文件中的内容直接替换为 js 脚本(方便热更新和 CSS 模块化)\n\n我们可以看一下是不是被替换了，随便写一点 index.css 的内容\n\n\n\n然后运行查看是这样的：\n\n\n\n它在替换 JS 的时候，会设置 Content-Type 为 js，让浏览器以 js 的方式来解析该 CSS 后缀的文件\n\n\n\n这就是 Vite 中如何处理原生 CSS\n\n\nVite 处理 CSS 模块化#\n\n我们首先构建一个场景：\n\n * 一个组件最外层的元素类名一般取名：wrapper\n * 一个组件最底层的元素类名一般取名：footer\n\n你取了 footer 这个名字，但别人并不知道，它也取名了 footer\n这个类名，那不是会冲突吗？同样的样式类名就会覆盖之前的，这就是协同开发的时候很容易出现的问题\n\n为了解决这类的问题，就诞生了 CSS Module\n\n我们只需在 css 文件名加上 module 后缀，变成如index.module.css就代表 CSS Module，这时候就会将类名后面加上哈希值以防止重复\n\n我们来一个例子，建两个 css 和两个 js 文件，如下，另一个名字换一下就好\n\n\n\n\n\n然后查看，就会发现两个不会覆盖，查看控制台会发现加上了哈希值：\n\n\n\n * 在我们将文件名改为module.css（module 是一种约定，表示需要开启 CSS 模块化），Vite 认为你开启了 CSS Module\n * Vite 会将你的所有类名进行一定规则的替换（将 footer 替换为 _footer_5nipi_1）\n * 同时创建一个映射对象 { footer: \"_footer_5nipi_1\" }\n * 将替换过后的内容塞进 style 标签里然后放入到 head 标签中\n * 将 index1.module.css 内容进行全部替换为 JS\n * 将创建的映射对象在脚本中进行默认导出\n\n这就是 Vite 中如何处理 CSS Module\n\n\nVite 中处理 CSS 预处理器#\n\n由于 Vite 的目标仅为现代浏览器，因此建议使用原生 CSS 变量和实现 CSSWG 草案的 PostCSS 插件（例如\npostcss-nesting）来编写简单的、符合未来标准的 CSS。\n\n话虽如此，但 Vite 也同时提供了对 .scss, .sass, .less, .styl 和 .stylus 文件的内置支持。没有必要为它们安装特定的\nVite 插件，但必须安装相应的预处理器依赖：\n\n\n\n预处理就是支持一些原生 CSS 不支持的东西，比如循环，变量等等\n\n在你安装后就可以使用了\n\n\nVite 处理 PostCSS 后处理器#\n\n如果项目包含有效的 PostCSS 配置 (任何受 postcss-load-config 支持的格式，例如\npostcss.config.js)，它将会自动应用于所有已导入的 CSS\n\nPostCSS 是一个后处理器，可以添加各个插件，比如为了兼容性就可以安装autoprefixer 插件，然后在postcss.config.js中添加\n\n\n\n这下它就会自动添加兼容各个浏览器的前缀如 --webkit\n\n详细在后面章节会介绍","routePath":"/guide/engineering/vite/10-Vite中处理CSS","lang":"","toc":[{"text":"Vite 中处理原生 CSS","id":"vite-中处理原生-css","depth":2,"charIndex":3},{"text":"Vite 处理 CSS 模块化","id":"vite-处理-css-模块化","depth":2,"charIndex":403},{"text":"Vite 中处理 CSS 预处理器","id":"vite-中处理-css-预处理器","depth":2,"charIndex":1064},{"text":"Vite 处理 PostCSS 后处理器","id":"vite-处理-postcss-后处理器","depth":2,"charIndex":1336}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"Vite 配置文件中 CSS 配置流程","content":"#\n\n在 vite.config.js 中我们通过 css 属性去控制整个 Vite 对于 CSS 的处理行为\n\n\nModules 配置篇#\n\n在 css 属性中，我们可以通过 modules 属性来控制 css 的模块化相关\n\n整个 vite.config.js文件如下：\n\n\n\n这里面有几个常用属性：\n\n * localsConvention：控制css模块化的类名格式显示，有如下值\n   \n   * camelCase：驼峰命名法，如 footerContent\n   * dashes：短横线，如 footer-content\n   * camelCaseOnly：只显示驼峰，不是驼峰的不显示\n   * dashesOnly：只显示短横线，不是短横线的不显示\n\n * scopeBehavior：配置当前的模块化是 模块化local 还是全局化 global\n   \n   * local：有哈希值就代表开启了模块化，保证样式不会被覆盖\n   * global：这个代表就是关闭模块化，没有哈希值了，和原生 css 一样\n\n * generateScopedName：对生成的类名进行自定义\n   \n   * 比如值为：\"[name]__[local]___[hash:base64:5]\"，其中，name 表示当前文件名，local\n     表示类名，这样类名就会变为我们定义的如index-module__header__3qxGt\n   * 这个也可以配置成函数，但很少用函数，了解一下即可\n   \n   \n\n * hashPrefix：生成 hash 会根据你的类名 + 文件名 + 等等\n   去进行生成，如果你想生成的hash更加独特可以通过配置hashPrefix，这个字符串最终会参与到 hash 的生成\n\n> hash：只要你的字符串有一个字不一样，生成hash就会不一样，但如果字符串完全一样hash就会一样\n\n * globalModulePaths：配置你不想参与到css模块化的路径数组\n\n\npreprocessorOptions 配置篇#\n\n假设我们没有使用 Vite等构建工具，我们又想去编译 less 文件的话，就需要下载 less，它会带上lessc 这个编译器，我们需要使用 lessc\nindex.less来编译 less 文件\n\n而在我们使用lessc 这个命令的时候，可以传很多相关的参数如--math\"always\"用来处理计算的如margin 100px /\n2，如果你不加括号包裹它，它是不会处理的。\n\n而在 css 属性中，我们可以通过 preprocessorOptions 属性来控制预处理器的一些全局参数\n\n整个vite.config.js文件内容如下，这里只举例了几个，具体需要参考预处理器文档中的 options选项\n\n\n\n这里有几个常用的属性\n\n * math：就是我们上面的开启数学计算\n * globalVars：定义全局变量，可以做一些全局都需用到的东西，比如颜色\n * devSourceMap：开启sourceMap的配置\n\n> sourceMap：代表文件的索引，假设我们的代码被压缩或被编译过了，这个时候如果程序出错，它产生的错误位置信息是编译或压缩的文件中，而不是我们开发时候的位\n> 置，如果有 sourceMap，它就会有一个索引文件map能够指向我们开发时候所在的位置\n\n\nPostCSS#\n\nVite 天生对 PostCSS 有非常良好的支持\n\nPostCSS 保证 CSS\n在执行之后时万无一失的，比如为了浏览器的兼容性，PostCSS在使用插件后会给属性添加保证上如--webkit来保证浏览器能够执行，它其实和 babel\n很类似，babel 也会将一些ES6以后的代码转为更低版本的代码\n\n所以PostCSS 就是解决如下的一些问题，不止下面这些\n\n * 对未来 CSS 属性的一些使用降级问题\n * 前缀补全，比如--webkit\n\nPostCSS 工作流程：\n\n我们写的CSS --> PostCSS --> 对语法进行编译(如函数、变量)Less Sass 也能做 --> 对未来的高级CSS 语法进行降级 -->\n前缀补全 --> 浏览器客户端\n\n就像 babel 的工作流程：\n\n我们写的JS --> babel --> 将ts语法转为js语法 --> 做语法降级 --> 浏览器客户端去运行\n\n\n简单使用 PostCSS#\n\n我们来一个简单的例子来尝试一下，新建一个目录，初始化packge，安装依赖\n\n\n\n新建 index.css\n\n\n\n然后现在终端运行如下命令，代表用 postcss 将 index.css 转换为 result.css\n\n\n\n我们会发现 result 和原来的一样，为什么呢？\n\n因为我们没有加任何的插件，PostCSS 本身是不具备任何功能的，它根据插件来运行的，就像净水系统需要有各个插槽来过滤自来水\n\n我们来书写配置文件postcss.config.js\n\n\n\n当然这个插件也需要安装：\n\n\n\n然后我们再运行一下：\n\n\n\n然后我们会发现它帮我们多加了一行代码，这就是基本的使用\n\n\n\n为什么 PostCSS 叫后处理器呢？在它开始的时候，它试图取代 Less、Sass，利用插件的方法来留住相关的人员\n\n但后面发现Less、Sass不断更新，他们的插件也需要更新，工作量较大，得不偿失，于是他们基本停止维护插件，让使用者自己弄将编译后的结果给PostCSS即可\n\nPostCSS还是会做前缀补全等工作，但前面如Less等编译不再维护，于是业内就有说法说PostCSS是后处理器，当然PostCSS也可以做Less、Sass等\n工作，但这个插件维护成本高，于是现在交由社区了\n\n\nPostCSS 配置篇#\n\n我们可以在 css 属性中的 postcss 属性来配置 PostCSS\n\n比如我们配置上节课说的 postcss-preset-env\n\n\n\n我们写一个新语法，不认识也没事，主要看作用：\n\n\n\n然后运行，会发现 PostCSS 的插件 postcssPresetEnv 给我们降级了\n\n\n\n再比如写一个别的：\n\n\n\n查看运行，发现 postcssPresetEnv 给我们前缀补全了\n\n\n\n更多的配置参考 PostCSS 官网即可，如果你不想将这个配置在 Vite\n的配置文件中，也可以新建postcss.config.js文件，将配置写在里面，Vite 也可以自动识别并且加载。当然 Vite配置文件里面不能有\npostcss 这个属性哈。","routePath":"/guide/engineering/vite/11-Vite配置文件中CSS配置流程","lang":"","toc":[{"text":"Modules 配置篇","id":"modules-配置篇","depth":2,"charIndex":57},{"text":"preprocessorOptions 配置篇","id":"preprocessoroptions-配置篇","depth":2,"charIndex":865},{"text":"PostCSS","id":"postcss","depth":2,"charIndex":1435},{"text":"简单使用 PostCSS","id":"简单使用-postcss","depth":3,"charIndex":1857},{"text":"PostCSS 配置篇","id":"postcss-配置篇","depth":2,"charIndex":2413}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"为什么要用 path 处理服务端路径","content":"#\n\n这节把之前小节的一点说一下，就是为什么我们需要使用path处理服务端的路径\n\n举个例子，我们的插件就是在服务端运行，这其中一定会涉及到读文件，但如果我们写的是相对路径，会发生什么呢？如下：\n\n\n\n如果我们是在这个js代码的目录下运行，是不会出错。但如果我们换一个目录，比如换一个目录，然后运行这个js代码，就会发现报错了\n\n\n\n因为你所在的目录没有这个东西，所以就会报错\n\nnode 端去读取文件或者操作文件的时候，如果发现你用的是相对路径，则会使用process.cwd()来进行相应的拼接\n\n> process.cwd()：获取当前的node执行目录\n\n但我们希望它读取的时候基于 main.js 去进行一个绝对路径的拼接生成，所以我们需要处理它\n\n由于我们在服务端，它是commonjs 规范，会注入一个变量__dirname，它代表当前文件所在的目录，那我们用它拼接吧\n\n\n\n运行，发现没问题了，但为什么我们要用path呢？其实主要是兼容，因为如果是Windows下，会发现不是正斜杠，而是反斜杠了，如下，只差\\\n\n\n\n所以为了统一，使用path，path本质就是一个字符串处理模块，它有很多的路径字符串处理方法\n\n\n\n这样每个操作系统都可以读取到了\n\n那为什么每个地方都会有一个变量__dirname呢？\n\n其实涉及到Common JS 规范的原理，它其实是将东西都放到一个立即执行函数中，这样就实现作用域隔绝，实现模块化，我们可以尝试一下\n\n\n\n运行会发现打印出东西，我们往下翻翻就会找到几个字符串：\n\n\n\n是不是很熟悉，4 其实代表的就是 __dirname\n\nCommon JS 规范将东西包在立即执行函数中，它传了五个参数\n\n\n\n这下就知道为什么会有这个了，了解一下即可","routePath":"/guide/engineering/vite/12-为什么要用path处理服务端路径","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"Vite 加载静态资源","content":"#\n\n什么是静态资源？\n\n图片，视频资源，一般除了动态API，大部分资源都视作静态资源\n\n动态 API 指我们向服务器发请求然后返回资源，这个就不是静态资源\n\nVite 对静态资源基本上是开箱即用的，我们说几个常用的加载\n\n\n加载图片#\n\n先准备一个图片，随便一个png，然后我们尝试一下\n\n\n\n运行，就会发现可以加载了，效果就不演示了，很简单\n\n\n加载 json 文件#\n\n创建一个index.json文件\n\n\n\n然后我们尝试读取使用：\n\n\n\n运行，会打印一个对象，这就很方便，因为有部分构件工具，json文件的导入会作为一个JSON字符串形式存在，我们还需要解析\n\n接下来我们假设这个json文件里面有100个字段，但我们只想取出两个，怎么做呢？\n\n我们可以通过如下的形式来：\n\n\n\n> 这个导入形式叫做 tree shaking 摇树优化，打包工具会自动帮你移除没有用到的变量或者方法，以此提高性能\n\n\n别名 resolve.alias 配置#\n\n我们在开发中引入静态资源，基本通过相对路径，但如果我们项目较大，嵌套的较多，出现如下情况，会觉得很长而且很麻烦\n\n\n\n我们可以通过配置vite.config.js中的别名来做：\n\n\n\n这样我们遇到上面的情况就可以这样引入了，也可以正常加载\n\n\n\n别名的原理就是读取到这个将它进行替换了\n\n\nresolve.alias 原理#\n\n我们回到之前的vite-dev-server，之前写简易开发服务器的时候的目录，还有映像吗，改一下index.js，精简一下：\n\n\n\n然后我们创建一个vite.config.js文件，这个不是vite配置哈，这个只是我们要演示如何实现别名原理的文件：\n\n\n\n然后我们需要获取这个文件，因为不用返回给客户端，我们这里约定名字叫vite.config.js，就像Vite为什么要配置文件叫这个一样\n\n\n\n我们会发现已经获取到了，我们新创建一个src目录，新建一个test.js文件\n\n\n\n然后在main.js中引入一下\n\n\n\n现在我们需要在读取 js 文件中进行 alias 的替换，引入就不写了\n\n\n\n新建一个文件aliasResolver.js用来处理替换这个替换\n\n\n\n当然你如果是Windows，这里就会报错无法引入，因为path路径分隔是这样的\\\\，Vite 会做更多的兼容处理，这里只是知道一下 alias 原理是什么即可\n\n\n加载 SVG 资源#\n\nSVG：可伸缩矢量图形\n\n优点：不会失真，且尺寸小\n\n缺点：没法很好的去表示层次丰富的图片信息\n\n我们一般使用 SVG 去做图标，先来尝试一下怎么使用\n\n先准备一个svg，如果没有可以使用create-vite创建项目，里面一般会有svg图片\n\n新建一个文件，随便取名：\n\n\n\n这是第一种方式加载，但这种方式很麻烦，比如我需要鼠标悬浮在上面，变化某个东西，就难以扩展\n\n接下来是第二种方式，我们在加载静态资源的时候是可以加一个参数的，默认是加上了url参数\n\n\n\n我们接下来换一个参数raw，这个是读取整个文件内容，获取内容字符串\n\n\n\n这样也能加载出svg，如果我们要改它，比如鼠标触摸上面变个色也很方便：\n\n\n\n这样就可以了，当然要记住改svg颜色用的是fill属性，而不是background-color或者color\n\n\nVite 在生产环境对静态资源的处理#\n\n当我们将工程进行打包以后，打包后的静态资源会有个哈希后缀，为什么要有hash？\n\n浏览器有一个缓存机制，静态资源名字只要不改变，那么它就会直接用缓存以此提高速度，比如在我们刷新页面的时候，就会重新请求对不对？它会看请求的名字是不是一样，如果一\n样就读取缓存，不一样就重新请求，当然更加深入缓存的知识，在别的章节会细讲，这里了解一下即可。\n\n所以为了尽量避免名字一致，在打包的时候会采用hash算法，将一串字符串经过运算得到一个新的乱码字符串，只要你文件不变，hash就不会变，如果文件内容变化一点点，\nhash也会变化。\n\n利用好哈希算法，可以更好的控制浏览器的缓存机制\n\nVite 在打包的时候是通过 rollup 来打包的，以此利用丰富生态\n\n我们在vite.config.js中也可以通过 build 属性配置打包相关的：\n\n\n\n这里解释就不多介绍了，注释都有，自己试试就明白了","routePath":"/guide/engineering/vite/13-Vite加载静态资源","lang":"","toc":[{"text":"加载图片","id":"加载图片","depth":2,"charIndex":112},{"text":"加载 json 文件","id":"加载-json-文件","depth":2,"charIndex":174},{"text":"别名 resolve.alias 配置","id":"别名-resolvealias-配置","depth":2,"charIndex":404},{"text":"resolve.alias 原理","id":"resolvealias-原理","depth":2,"charIndex":571},{"text":"加载 SVG 资源","id":"加载-svg-资源","depth":2,"charIndex":1008},{"text":"Vite 在生产环境对静态资源的处理","id":"vite-在生产环境对静态资源的处理","depth":2,"charIndex":1385}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"Vite 插件之 vite-aliases 插件","content":"#\n\nVite 会在不同的生命周期中去调用不同的插件以达到不同的目的\n\n> 生命周期：Vite 从开始执行到执行结束，中间这个过程就是生命周期\n\nwebpack 中有一个输出 HTML 文件的插件 清除输出目录：clean-webpack-plugin\n\nVite 其实和 webpack 的非常类似\n\n\n基本使用 vite-aliases#\n\n我们从一个简单的插件 vite-aliases 学起\n\nvite-aliases 可以帮助我们生成别名：它会检测你的当前目录下包括 src 在内的所有文件夹，并帮助我们去生成别名\n\n先安装它，如果 node 版本不对可以使用 nvm 切换\n\n\n\n然后在vite.config.js中使用 plugins 来配置插件：\n\n\n\n这个插件生成的别名是如何的呢？比如下面这样，**代表你的工程路径\n\n\n\n它还有很多配置，可以参考官方 Github，这里举一个即可\n\n\n\n这样配置，你的别名就是以 & 开头的，如下：\n\n\n\n\n手写 vite-aliases 插件#\n\n整个插件就是在 Vite 的生命周期的不同阶段去做不同的事情，我们利用官方提供的钩子来做事情\n\n比如说 Vue 和 React 官方就会提供一些生命周期函数如 created\n\n我们去手写 vite-aliases 其实就是在 vite 执行配置文件之前将配置文件改了\n\n从官网文档地址：Vite 独有钩子，我们可以使用 config来做这个事情\n\n我们新建一个文件夹plugins，新建文件ViteAliases.js\n\nVite 的插件必须返回给 Vite 一个配置对象，而我们看大部分插件导出的都是一个函数，然后我们去调用这个函数来使用\n\n> 用函数的形式，可以拥有更多的自定义配置，如果导出一个对象也可以，但多元化就没了\n\n\n\n然后我们看config\n\n\n\n我们先返一个空对象，然后我们用一下插件，看看打印出的参数是什么\n\n\n\n我们发现打印实在 Vite 执行之前调用的，这没问题\n\n\n\n这里还需要强调，通过vite.config.js返回出去的配置对象以及我们在插件的config生命周期中返回的对象都不是最终的一个配置对象\n\nVite 会把这几个配置对象进行一个 merge 合并，类似...合并\n\n现在我们来写插件，这里我们要返回一个 resolve 出去, 将 src 目录下的所有文件夹进行别名控制\n\n第一步我们先读目录\n\n\n\n运行，会发现把我们目录打印都读取了，但有个不必要的文件test.js，我们需要去掉\n\n\n\n我们来编写一个函数getTotalSrcDir用来处理\n\n\n\n我们先调用打印一下，发现每个文件的 Stat 打印出来了\n\n\n\n然后我们调用 Stat 上有一个方法isDirectory可以识别是否是目录\n\n\n\n打印看看，发现不是目录的 test.js就变为 false 了，这样我们就可以识别了\n\n\n\n\n\n然后我们看看结果：\n\n\n\n运行，结果如下，这样我们就成功获取了目录，第一步读目录完成\n\n\n\n第二步，我们要生成 resolve 这个配置对象，继续改进getTotalSrcDir\n\n\n\n然后调用获取它，打印看看：\n\n\n\n发现打印出来的毫无问题，对应成功\n\n\n\n最后我们只需要在返回的配置对象中挂上去就成功啦\n\n\n\ntest.js使用别名引入一下\n\n\n\n我们先什么插件都不用，启动之后会发现报错：\n\n\n\n然后我们启用我们的写的插件，会发现成功运行了，并且成功引入，在页面上显示了\n\n\n\n接下来我们弄一个上面的自定义配置，就是自定义别名符号，这里就是利用函数传参来做\n\n下面是ViteAliases.js完整代码，其实就是把keyName传给getTotalSrcDir了\n\n\n\n然后我们在配置中调用时候传别名配置：\n\n\n\n当然test.js也要改一下\n\n\n\n照样可以运行，这就是自定义配置的实现，完整目录如下，后续插件基本都在这做：\n\n","routePath":"/guide/engineering/vite/14-Vite插件之vite-aliases","lang":"","toc":[{"text":"基本使用 vite-aliases","id":"基本使用-vite-aliases","depth":2,"charIndex":152},{"text":"手写 vite-aliases 插件","id":"手写-vite-aliases-插件","depth":2,"charIndex":430}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"Vite 插件之 vite-plugin-html","content":"111","routePath":"/guide/engineering/vite/15-Vite插件之vite-plugin-html","lang":"","toc":[{"text":"基本使用","id":"基本使用","depth":2,"charIndex":-1},{"text":"手写 vite-plugin-html 插件","id":"手写-vite-plugin-html-插件","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"Vite 插件之 vite-plugin-mock","content":"#\n\n该插件是用来做 mock 数据的，即模拟数据\n\n我们在开发的时候一般是前后端一块并行开发，但后端没写完之前的时候我们是没有接口数据，没有接口文档\n\n为了做一些测试，比如用户列表，我们需要 mock 一些数据\n\n * 简单方式：直接写死一些数据用来调试\n   \n   * 缺点：无法做大量数据测试、没法获取一些标准数据、无法感知 http 请求异常\n\n * mockjs：模拟海量数据，vite-plugin-mock 的依赖项就是 mockjs\n\n\n基本使用#\n\n我们先安装依赖：\n\n\n\n然后在vite.config.js中去配置插件\n\n\n\n我们需要在根目录下新建一个mock文件夹，它会自动读取下面的index.js\n\n> 如果你想自定义文件夹，也可以用 mockPath 属性来设置，参考Github 文档\n\n\n\n然后我们去main.js写一个请求\n\n\n\n启动，打开浏览器查看网络，发现成功：\n\n\n\n我们查看返回，发现返回的是空数组，和我们所写的返回一致，成功\n\n\n\n那我们改一下返回，再查看一下\n\n\n\n运行查看，发现完全对上了\n\n\n\n那我们现在和之前的简单方式好像没区别，也是写死的，这时候就需要用到我们刚刚安装的 mockjs 了\n\n\n\n其中各个模拟的配置可以查看文档：数据示例文档\n\n我们查看数据，发现基本没问题，除了英文名那有个 bug\n\n\n\n我们去掉中文名字，只生成英文就没啥问题的：\n\n\n\n然后我们把生成的 userList 放入到下面的配置：\n\n\n\n运行，发现没啥问题了，这样就可以模拟大量数据了\n\n\n\n不过注意，mockJS 已经很久没有维护了，这个一般就是用来模拟一下数据\n\n\n手写 vite-plugin-mock 插件#\n\n新建VitePluginMock.js文件，用来写插件\n\n该插件做的事情就是拦截 http 请求，将请求发到我们本地的开发服务器\n\n当我们使用 fetch 或 axios 去请求的时候，一般有个地址，比如 axios 有个 baseUrl 用来写地址，而当我们没写它时，Vite 可以接管\n\n当打给本地的开发服务器的时候， viteServer 服务器接管\n\n这里我们学习一个新的钩子：configureServer，它用来处理用户请求：\n\n\n\n运行，会发现报了一个错：\n\n\n\n这是因为res.end会自动设置请求头，它是异步的，所以走完后放到异步队列，然后就直接到next，之后才设置请求头，自然就会报错了，修改一下\n\n> 这里可以结合事件循环来想想\n\n\n\n发现运行成功，并且拦截了：\n\n\n\n查看响应结果，没错，是我们设置的 hello world\n\n\n\n那接下来我们是不是返回我们用 mockjs 写的数据列表就可以了，这里就需要读文件了，这里因为约定 mock 文件放 mock 文件夹下，所以就不用 path\n拼了\n\n\n\n这样我们通过 mockStat 就找到index.js了，如下：\n\n\n\n然后我们读取这个文件，当然这里一般只有一个，所以我们可以直接读：\n\n\n\n报 import 的错误，把index.js里面的 import 导入换成 Commonjs 即可\n\n\n\n打印出了这个，我们会发现都读取到了：\n\n\n\n那我们匹配一下，然后返回对应数据即可，下面是完整代码，这里如果想要整洁还可以把代码提成一个函数：\n\n\n\n这样我们运行，再打开，发现成功，并且返回了我们生成的数据\n\n\n\n查看一下服务器终端：\n\n\n\n\n\n至此，这个插件我们就学习了，同时又学习了一个新的钩子configureServer\n\n所有插件代码，都在我的 Github 仓库：vite-plugin-mock","routePath":"/guide/engineering/vite/16-Vite插件之vite-plugin-mock","lang":"","toc":[{"text":"基本使用","id":"基本使用","depth":2,"charIndex":227},{"text":"手写 vite-plugin-mock 插件","id":"手写-vite-plugin-mock-插件","depth":2,"charIndex":702}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"Vite调用插件原理以及查缺补漏","content":"#\n\n我们在之前的插件学习中已经学习了 Vite 提供的几个独有钩子了，分别是：\n\n * config\n\n * configureServer\n\n * transformIndexHtml\n\n如果有点忘记，可以点击上面，进入官方网址看看，或者回之前章节看看\n\n\n三个独有新钩子#\n\n我们除了学习了上面的三个，再简单讲一下别的\n\n\nconfigResovled#\n\n官方文档：configResovled\n\nconfigResovled：在解析 Vite 配置后调用。使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用。\n\n\n\n打印出来会发现有很多，因为我们有一个默认的defineConfig，查看插件会发现有很多内置的插件：\n\n\n\n\nconfigurePreviewServer#\n\n官方文档：configurePreviewServer\n\nconfigurePreviewServer 与 configureServer 相同，但用于预览服务器。\n\n这个钩子也是在其他中间件安装前被调用。如果你想要在其他中间件 之后 安装一个插件，你可以从 configurePreviewServer\n返回一个函数，它将会在内部中间件被安装之后再调用：\n\n\n\n\nhandleHotUpdate#\n\n官方文档：handleHotUpdate\n\n这个就是用来自定义你的热更新行为用来覆盖官方的热更新，这块就不细讲了，后续有机会讲\n\n\n通用钩子#\n\n上述的几个钩子是 Vite 独有的，接下来的通用钩子在 rollup 也会调用\n\n官方文档地址：通用钩子\n\n\noptions#\n\n在服务器启动时被调用，我们现在打印的话会发现什么都没有，因为我们没有弄和 rollup 相关的配置\n\n\n\n打印如下\n\n\n\n我们加一点 rollup 相关的配置\n\n\n\n再次运行，就有值了：\n\n\n\n\nbuildStart#\n\n和 options 类似，我们打印一下试试：\n\n\n\n结果如下：\n\n\n\n更多的就不介绍了，可以自行参考官方文档\n\n\n社区生态插件#\n\n我们可以参考社区生态插件列表：awesome-vite#plugins\n\n基本上大部分的需求要求都会在社区插件中有实现，根据介绍选择即可\n\n\n调用插件原理#\n\n本质上就是读取文件，通过生命周期钩子来调用，如下：\n\n","routePath":"/guide/engineering/vite/17-Vite调用插件原理以及查缺补漏","lang":"","toc":[{"text":"三个独有新钩子","id":"三个独有新钩子","depth":2,"charIndex":130},{"text":"configResovled","id":"configresovled","depth":3,"charIndex":164},{"text":"configurePreviewServer","id":"configurepreviewserver","depth":3,"charIndex":338},{"text":"handleHotUpdate","id":"handlehotupdate","depth":3,"charIndex":546},{"text":"通用钩子","id":"通用钩子","depth":2,"charIndex":630},{"text":"options","id":"options","depth":3,"charIndex":692},{"text":"buildStart","id":"buildstart","depth":3,"charIndex":800},{"text":"社区生态插件","id":"社区生态插件","depth":2,"charIndex":870},{"text":"调用插件原理","id":"调用插件原理","depth":2,"charIndex":950}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"Vite 与 Ts 的结合","content":"#\n\nTypeScript 是 Javascript 的一个超集，它能够进行类型标注，检查代码的隐形问题，同时可以进行语法智能提示 (类似之前的 JSDoc )\n\n\n两者比较#\n\n我们来个小例子，先用 JSDoc 来做\n\n\n\n在我们标注了JSDoc 之后，我们打params.的时候就会有提示，如下：\n\n\n\n接下来我们用 Ts 来做一下：\n\n\n\n在我们输入的时候也会有语法提示，两者都差不多\n\n\n\nts 的好处是他把类型标注提取出来，我们可以单独创建一个类型标注文件，同时易于扩展，JSDoc 毕竟是在注释中不容易扩展\n\n\n使用 Ts#\n\nVite 其实天生支持 TypeScript，参考：TypeScript\n\n我们可以直接使用.ts文件，但注意的是 Vite 仅执行.ts文件的转译，并不执行 任何类型检查。并假定类型检查已经被你的 IDE 或构建过程处理了。\n\n> 就是它能用 TS 文件，但 ts 的类型报错等等它不会检测，这和其他静态分析检查，例如 ESLint一样\n\n我们先来看 Ts 的一个好处，不允许不同类型赋值\n\n\n\n如下会直接提示你，这就是它的一大好处，保证最终返回的一定是字符串\n\n\n\n如果我们换成 Js，就不会爆红，如果处理很多你可能还找不到问题在哪\n\nTs 的类型标注，让我们拥有强类型锁定\n\nTs 还有类型推导，比如上面的str，我们不标注 string类型也可以，因为我们给他赋值了一个 string，鼠标悬浮在上面会发现给我们自动推导了类型：\n\n\n\n当然上面的代码，在浏览器还是可以执行的，没有任何输出报错，毕竟 Javascript 允许这么做\n\n有些人不愿意看到爆红，将爆红配置给关了，那这样用 Ts 的意义就没了，我们就需要约束别人\n\n\n类型报错约束#\n\n那我们如何让 Ts 的错误直接输出到控制台呢？需要安装一个插件vite-plugin-checker\n\n它在官方也有说到，如下\n\n\n\n这是他们官方的示例图，这意味着我们必须解决类型报错才行\n\n\n\n官方文档地址：vite-plugin-checker\n\n先按照依赖：\n\n\n\n然后在配置中使用\n\n\n\n运行的时候可能有报错：\n\n\n\n因为这个插件依赖 TypeScript，所以我们需要安装TypeScript：npm i typescript -D\n\n然后再运行还会有个报错，说少了tsconfig.json文件，这个其实是ts的配置文件，我们可以自己新建\n\n> 或者全局安装ts：npm insatll typescript -g，用tsc --init来创建\n\n\n\n这时候我们在运行，就会发现浏览器直接弹出报错了：\n\n\n\n这是开发环境，我们打包一下看看呢？运行如下，当然package需要配置scripts哦\n\n\n\n打包过程中，就会给我们提示错误了：\n\n\n\n但这还是打包成功了，我们可以配置一下如果有错误，编译等等都不能进行，就不会生成目录了\n\n参考官方：\n\n\n\n我们配置一下packcge的脚本，让前面的必须走通才能做后面的 build 打包工作\n\n\n\n然后我们再运行，就会发现提示错误并且不会打包成功：\n\n\n\n\n一些报错#\n\n我们在使用import.meta的时候会报错，提示这个是在高级语法中才能使用，因为 TypeScript\n默认用的时候ES的低版本，我们需要改一下tsconfig.json的配置\n\n\n\n但当我们用import.meta.env，有些时候我们自己定义了.env文件，当我们用的时候没有语法提示，这时候就需要配置一下\n\n在 src 目录下创建一个 vite-env.d.ts 文件，接着按下面这样增加 ImportMetaEnv 的定义：\n\n\n\n这样我们在用import.meta.env.VITE_APP_TITLE就会有语法提示了\n\n\n\n这里不多解释这里的含义，因为需要讲到 ts 的东西，只需///其实就类似import就可以了","routePath":"/guide/engineering/vite/18-Vite与Ts的结合","lang":"","toc":[{"text":"两者比较","id":"两者比较","depth":2,"charIndex":82},{"text":"使用 Ts","id":"使用-ts","depth":2,"charIndex":261},{"text":"类型报错约束","id":"类型报错约束","depth":2,"charIndex":738},{"text":"一些报错","id":"一些报错","depth":2,"charIndex":1304}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"Vite 性能优化概述","content":"#\n\n我们平时说的性能优化是在说什么呢？包括几个方面：\n\n * 开发时候的构建速度优化：npm run dev 敲下的一瞬间到呈现结果要占用多少时长\n   \n   * webpack 在这方面很多：cache-loader cache loader 结果(如果两次构建源代码没有产生变化，则直接使用缓存 不调用\n     loader)，thread-loader，开启多线程去构建...\n   * vite 是按需加载，所以我们不需要太关心这方面\n\n * 页面性能指标：和我们写代码有关\n   \n   * 首屏渲染时长：fcp(first content paint) (也有叫页面中第一个元素的渲染时长)\n     \n     * 懒加载：需要我们写代码实现\n     * http 优化：强缓存和协商缓存\n       * 强缓存：服务端给响应头追加一些字段(expires 代表截止失效时间)，客户端会记住这些字段，在 expires\n         没有到达之前，无论怎么刷新页面，浏览器都不会重新请求而是从缓存中里取\n       * 协商缓存：是否使用缓存要和后端商量，当服务端给我们打上协商缓存的标记以后，客户端在下次刷新页面需要重新请求资源时会发送一个协商请求给服务端，服\n         务端如果需要说需要变化，则会响应具体的内容，如果没有变化则会响应 304 状态码\n   \n   * 页面中最大元素的一个时长：lcp(largest content paint)\n   \n   * ......\n\n * js 逻辑：\n   \n   * 我们要注意副作用的清除，在应用中组件是会频繁的挂载和卸载，比如我们在某一个组件中有计时器，如果我们在卸载的时候不清除这个计时器，下次再次挂载的时候计时\n     器等于有两个线程了\n   \n   * 我们在写法上的注意事项：requestAnimationFrame、requestIdleCallback一些新的 API\n     \n     * 浏览器的帧率：16.6 ms 去更新一次（执行 js 逻辑以及 重排重绘...），假设我的 js 执行逻辑超过\n       16.6ms，就会阻塞导致卡顿掉帧，可以通过 api 将 js 放入每 16.6 ms 剩余的时间中执行，就不会卡顿了\n   \n   * 防抖、节流，或者用 lodash 工具库，比如一个数组有很多数组，不要用原生的 forEach，用 lodash 的，这个工具库有很多算法可以提高性能\n   \n   * 对作用域的控制\n     \n     * \n   \n   * ...\n\n * css\n   \n   * 关注继承属性：能继承就不要重复写\n   * 尽量避免太过于深的 css 嵌套\n\n * 构建优化：构建工具如 vite(rollup) webpack\n   \n   * 优化体积：压缩、treeshaking、图片资源压缩\n   * cdn 加载、分包 ······\n\n * ······","routePath":"/guide/engineering/vite/19-Vite性能优化概述","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"什么是构建工具","content":"#\n\n> 浏览器只认识 HTML、CSS、JS\n\n大型项目一般具备哪些功能\n\n * TypeScript：如果遇到 ts 文件我们需要使用 tsc 将 Typescript 代码转换为 js 代码\n * React/Vue：安装 react-compiler / vue-compiler，将我们写的 jsx 文件或者 vue 文件转换为 render 函数\n * Sass/Less/PostCSS/Style-Component：我们又需要安装 less-loader，sass-loader等一系列编译工具\n * 语法降级：安装 babel 将es的新语法转换为旧版浏览器可以使用的语法\n * 体积优化：安装 uglifyjs 将我们代码进行压缩变成体积更小性能更高的文件\n * ......\n\n在我们稍微改一些东西，就需要安装、编译等等，非常麻烦，比如：\n\n将 App.tsx --> tsc --> App.jsx --> React-Compiler --> js 文件\n\n所以我们希望有一个工具可以把这些集成到一起，让我们只关心我们写的代码，代码一变化，工具就自动帮我们将这些 tsc、react-compiler 等都走一遍\n\n这个工具就叫 构建工具\n\n\n构建工具承担的任务#\n\n一个构建工具承担了如下的任务：\n\n * 模块化开发支持：支持直接从 node_modules 里引入代码，多种模块化支持（如 common js）\n * 处理代码兼容性：比如 babel 语法降级，这个不是构建工具做的，构建工具是将这些语法对应的处理工具集成进来自动化处理\n * 提高项目性能：压缩文件、代码分割\n * 优化开发体验：\n   * 构建工具会自动监听文件变化，当文件变化以后自动调用对应的集成工具进行重新打包，然后在浏览器重新运行（这个过程也叫热更新）\n   * 开发服务器：跨域的问题，用 react-cli 或 vue-cli，本质是代理到服务器，服务器往服务器发请求是没有跨域的\n\n构建工具让我们无需关心代码的如何编译运行，我们只需关心它的配置文件就可以完成集成，即使不给配置文件也会有默认的帮忙处理\n\n构建工具还具有热更新，结合起来之后，我们只需关心如何去写开发的代码即可了。\n\n现在主流的构建工具有：Webpack、Vite、ESbuild、Rollup、Grunt、Gulp、Parcel 等","routePath":"/guide/engineering/vite/2-什么是构建工具","lang":"","toc":[{"text":"构建工具承担的任务","id":"构建工具承担的任务","depth":2,"charIndex":535}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"性能优化之分包策略","content":"#\n\n我们来一个简单的示例，我们在之前ts的基础上安装一个lodash\n\n\n\n然后导入使用：\n\n\n\n会发现报了如下的错\n\n\n\n这里我们需要去tsconfig.json加一个配置\n\n\n\n我们在引入forEach的时候发现没有智能提示，其实是因为没有下载类型依赖：\n\n\n\n\n\n这样就有提示了，我们写一个非常简单的东西：\n\n\n\n然后我们调整一下vite.config.js让他不压缩，以便于查看：\n\n\n\n然后我们直接打包：\n\n\n\n我们发现这上面，一大行的代码，而我们的代码只有这几行，只用了一个lodash库就多出这么多代码\n\n\n\n浏览器有自己的一个缓存策略：静态资源只要名字没有变化，那么它就不会重新去拿\n\n但我们的文件有一个hash，只要文件有变化，hash就会不一样\n\n而我们的业务代码经常变化，但lodash却不会变化，因为我们下载了就是固定了\n\n那每次业务代码一变就会导致文件名字变化，文件名不一样就要重新请求，lodash也会重新请求，但lodash是没必要进行重新请求的因为它没变，所以就需要用到分包了\n\n分包就是把一些不会常规更新的文件，进行单独打包处理\n\n\n进行分包#\n\n我们进入vite.config.js来配置，我们进入manualChunks，先打印一下\n\n\n\n然后打包，打印如下：\n\n\n\n我们是不是找到了 lodash，那我们配置一下\n\n\n\n配置中可能有报红提示配置，到tsconfig.json配置一下即可：\n\n\n\n然后我们再运行一下打包，这次我们会发现生成了三个文件\n\n\n\n我们去index看看，发现之前的几千行直接暴跌到几十了\n\n\n\n我们在原来的基础上就改一点字符串\n\n\n\n然后再打包，会发现只有index文件名变了，而新生成的 vendor没有变化：\n\n\n\n这个配置在 rollup 配置中也有写：output.manualChunks，如下\n\n\n\n当然上面的还有一种写法，就是自己指定库，但一旦库一多就不好指定了，所以函数形式方便\n\n\n\n\n多页面应用#\n\n假设你有下面的项目文件结构：\n\n\n\n在开发过程中，简单地导航或链接到 /nested/ - 将会按预期工作，与正常的静态文件服务器表现一致。\n\n在构建过程中，你只需指定多个 .html 文件作为入口点即可：\n\n\n\n在之前的时候，如果我们一个html的js文件引入了lodash，另一个html的js也引入了lodash，如果没有做分包的话，生成的两个js文件都会有lodas\nh的几千行代码\n\n但现在vite主动优化了，即使你没有做分包，它也只生成在一个js文件中的几千行，然后另一个js文件引入它即可，当然为了节省这个，我们还需要和上面一样做分包的策略\n。","routePath":"/guide/engineering/vite/20-性能优化之分包策略","lang":"","toc":[{"text":"进行分包","id":"进行分包","depth":2,"charIndex":484},{"text":"多页面应用","id":"多页面应用","depth":2,"charIndex":834}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"性能优化之 gzip 压缩","content":"#\n\n有时候我们的文件资源实在太大了比如有个 2000kb，那么 http 传输就会慢\n\n我们的方法是将所有的静态文件进行压缩，以达到减少体积的目的\n\n服务端 -> 压缩文件，客户端收到压缩包 -> 解压缩\n\n过大的时候，一般就会有提示你 chunk 大于 500kb 等等，让你使用几种策略：\n\n> chunk 就是块，块最终会映射成 js 文件，但 chunk 不是 js 文件\n\n * 使用动态导入\n * 使用分包策略\n\n我们还有一种操作，使用 gzip 压缩\n\n我们安装一个插件vite-plugin-compression，Github 地址：vite-plugin-compression\n\n\n\nvite.config.js 中的配置插件\n\n\n\n然后我们再打包一次，会发现生成一个 gz 文件\n\n\n\n然后就是后端或者运维的事情，在客户端请求index.html和相关 js 的时候，让他们用我们的 gz 就可以了\n\n服务端读取 gzip 文件（gz 后缀），设置一个响应头 content-encoding为 gzip（代表告诉浏览器该文件使用 gzip 压缩过的）\n\n浏览器收到响应结果，发现响应头里有 gzip 对应字段，就解压它得到原来的 js 文件，然后执行\n\n浏览器是需要承担一定的解压时间，如果体积不是很大的话不要用 gzip 压缩","routePath":"/guide/engineering/vite/21-性能优化之gzip压缩","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"性能优化之动态导入","content":"#\n\n还记得webpack和vite在构建的区别么？Vite是按需加载，而我们的动态导入和它异曲同工\n\n动态导入是ES6的一个新特性，我们一般会在路由里面会用到动态导入\n\n> 路由：根据不同的地址 展现不同的组件\n\n比如React，这里是没有动态导入的情况\n\n\n\n只要我们一写了import，整个组件就会被读取加载了，不管你用没用，如果这个组件很大，那不是就会浪费了吗？\n\n所以我们需要换成动态导入：\n\n\n\n这样在我们没有进入对应地址的时候，我们是不会加载组件的，就会提高速度了\n\n其中import函数类似如下：\n\n\n\n这个就是动态导入的类似，内部实现一个异步加载\n\n通过动态导入，也可以实现性能的提升","routePath":"/guide/engineering/vite/22-性能优化之动态导入","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"性能优化之CDN加速","content":"#\n\nCDN：content delivery network 内容分发网络\n\n我们举个例子，我们所有依赖以及文件在我们进行打包后会放到服务器上\n\n然后我们服务器在深圳，而你在纽约，然后访问网站，就会发现有点卡\n\n而CDN就是将我们的第三方模块全部写成CDN的形式，然后保证我们自己代码的一个小体积（体积小服务器和客户端的传输压力就没那么大）\n\ncdn ---> 内容分发 dns\n\n其实就是一个网址：比如下面这个\n\nhttps://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js\n\n你要加载lodash，然后你在纽约，它就会根据你的位置去找更近的网络分发给你\n\n由于你的第三方模块是cdn加载的，所以你自身代码的体积就小了，所以你访问速度就快了\n\n\n使用 CDN#\n\n之前我们打包的时候，做了分包，但lodash依旧是一个文件，如果放到服务器，加载依旧需要不小时间，这时候我们使用cdn来试试\n\n我们使用一个插件：vite-plugin-cdn-import，先安装：\n\n\n\n然后我们在 vite.config.js 中使用它：\n\n\n\n然后我们打包看一下，这是之前的：\n\n\n\n这是之后的：\n\n\n\n这个插件还有预设的几个常用的npm包，也就是说我们可以不用写cdn地址了，比如react相关\n\n\n\n预设的 npm 包如下：\n\nreact、react-dom、react-router-dom、antd、vue、vue2、vue-router、vue-router@3、moment、da\nyjs、axios、lodash","routePath":"/guide/engineering/vite/23-性能优化之CDN加速","lang":"","toc":[{"text":"使用 CDN","id":"使用-cdn","depth":2,"charIndex":351}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"Vite 相较于 Webpack 的优势","content":"#\n\n官方文档：为什么选 Vite\n\n起因：当项目越大，构建工具 (Webpack) 所需处理的 js 代码就越多，这和 Webpack 的工作流程有关\n\n结果：构建工具需要很长时间才能启动开发服务器\n\n> Webpack 还不能改，如果改了，整个就变化了，生态等等也要改变\n\nWebpack 支持多种模块化，比如下面的例子\n\n\n\nWebpack 允许我们这么写，它的转换结果大致如下：\n\n\n\n> 通过 AST 抽象语法树来转换\n\n由于支持多种模块化，它一开始就需要统一模块化代码，这意味着它需要将所有的依赖都读一遍\n\n为了兼容性，因为还有 node 端，所以 Webpack 性能较差。\n\nVite 基于 ES Module，Vite 关注浏览器端的开发体验，且在启动方面有些不同，它的性能很快，这就是相较于 Webpack 的优势之一。","routePath":"/guide/engineering/vite/3-Vite相较于Webpack的优势","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"Vite 脚手架和 Vite 的区别","content":"#\n\nVite 官网搭建 Vite 项目文档：搭建第一个 Vite 项目\n\n这里我们用 yarn create vite 举例，步骤如下：\n\n * 全局安装一个东西：create-vite ( vite 的脚手架 )\n\n * 直接运行这个 create-vite 中某个目录下的一个执行配置，该目录取决于我们选择的模板\n\n> 这里可能有个误区：认为 yarn create 构建项目也是 Vite 做的事情，这是错误的\n\ncreate-vite 和 vite 的关系是 create-vite 内置了 vite\n\n就像是使用 create-react-app 内置了 webpack\n\n我们先学习 Vite，而不是 Vite脚手架 create-vite\n\n> 脚手架就是搭建一套预设项目，这是什么意思呢？\n> \n> 比如我们自己搭建一个项目，需要下载vite、react、sass等等，还需要建目录等\n> \n> 而脚手架帮我们都干了，它下载了基本的库，同时给你搭好了目录，这就是预设","routePath":"/guide/engineering/vite/4-Vite脚手架和Vite的区别","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"Vite 启动项目初体验","content":"#\n\nVite 是开箱即用的( out of box)：你不需要做任何额外的配置就可以使用 Vite 来帮你处理构建工作\n\n在默认情况下，我们的 ES Module 去导入资源的时候，要么是绝对路径，要么是相对路径\n\n那我们下载一个包放在 node_modules，浏览器为什么在我们导入非绝对路径和非相对路径的时候不默认帮我们搜寻 node_modules 呢？\n\n因为依赖树，比如我们导入 lodash，这个库中又 import 了别的库，这个别的库又 import\n了别的，一层一层的嵌套，那网络请求是不是要请求一大堆，就会及其消耗性能\n\n这时候就需要我们的 Vite 出场了。\n\n\n简单示例#\n\n初始化package.json\n\n\n\n随便安装一个库，比如 loadsh\n\n\n\n创建一个counter.js\n\n\n\n再创建一个main.js\n\n\n\n创建一个 html，默认就好，导入 main.js\n\n\n\n这时候我们运行会报错说找不到 lodash，所以我们下载 vite\n\n\n\n然后在 package.json 的 script 中添加\n\n\n\n我们在终端运行：npm run dev，然后打开就发现没错了","routePath":"/guide/engineering/vite/5-Vite启动项目初体验","lang":"","toc":[{"text":"简单示例","id":"简单示例","depth":2,"charIndex":294}],"domain":"","frontmatter":{},"version":""},{"id":20,"title":"Vite 的依赖预构建","content":"#\n\n比如下面的代码\n\n\n\nVite 会自动帮我们补全路径，类似下面\n\n\n\n> 找寻依赖的过程是自当前目录依次向上查找的过程，直到搜寻到根目录或者搜寻到对应依赖上为止\n\n生产和开发\n\n * 开发中每次依赖预构建所重新构建的相对路径都是正确的\n * 生产中 Vite 会交给 Rollup 去完成生产环境的打包，让兼容性更好\n\n而我们导入库的时候会出现一个问题，有些库它不是 ES Module 的导出，它是 common js 规范的导出，为了解决这个问题，Vite 使用了 依赖预构建\n解决它\n\n\n依赖预构建#\n\n依赖预构建的步骤如下：\n\n * 首先 Vite 会找到对应的依赖，然后调用 esbuild（对 js 语法进行处理的一个库）将其他规范的代码转换为 esmodule 规范\n * 然后将它放入到当前目录的 node_modules/.vite/deps 中\n * 将各个模块进行统一集成，变成一个文件\n\n它解决了 3 个问题：\n\n * 不同的第三方库会有不同的导出格式，Vite 将它都转为 esmodule\n * 对路径的处理下可以直接使用 .vite/deps，方便路径重写\n * 解决网络多包传输的性能问题（嵌套 import 问题，也是浏览器不支持 node_modules 的原因）\n\n\n配置初识#\n\n创建一个文件 vite.config.js，这就是 Vite 的配置文件类似 webpack.config.js\n\n\n\n这里知道一下就行，后续会详细解读","routePath":"/guide/engineering/vite/6-Vite的依赖预构建","lang":"","toc":[{"text":"依赖预构建","id":"依赖预构建","depth":2,"charIndex":249},{"text":"配置初识","id":"配置初识","depth":2,"charIndex":555}],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"Vite 配置文件处理细节","content":"#\n\n\nVite 配置文件的语法提示#\n\n如果使用 WebStorm，他集成的语法提示比较全\n\n但如果我们使用 vscode，我们就需要进行处理\n\n * 第一种方法：使用 defineConfig 工具函数来获取提示\n\n\n\n它其实就是有个类型约束(ts)了，所以编辑器就会识别然后给你提示了\n\n * 第二种方法：使用 jsdoc 来实现智能提示\n\n\n\n\nVite 关于环境的处理#\n\n过去我们使用 webpack 的时候，我们就会区分配置文件的一个环境\n\n * webpack.dev.config\n\n * webpack.prod.config\n\n * webpack.base.config\n\n而在Vite中，如果配置文件需要基于（dev/serve 或 build）命令或者不同的 模式 来决定选项，亦或者是一个 SSR\n构建（isSsrBuild）、一个正在预览的构建产物（isPreview），则可以选择导出这样一个函数：\n\n\n\n我们可以新建几个如vite.dev.config.js、vite.prod.config.js\n\n然后在配置引入，这里可以用策略模式来做，然后我将不必要的去掉\n\n","routePath":"/guide/engineering/vite/7-Vite配置文件处理细节","lang":"","toc":[{"text":"Vite 配置文件的语法提示","id":"vite-配置文件的语法提示","depth":2,"charIndex":3},{"text":"Vite 关于环境的处理","id":"vite-关于环境的处理","depth":2,"charIndex":176}],"domain":"","frontmatter":{},"version":""},{"id":22,"title":"Vite 环境变量处理","content":"#\n\n\n为何需要环境变量#\n\n环境变量：会根据当前的代码环境产生值的变化的变量就叫做环境变量\n\n代码环境：开发环境，测试环境，预发布环境，灰度环境，生产环境\n\n举个例子，如果用过百度地图SDK或者小程序的SDK，里面有一个\nAPP_KEY，它在不同的环境中，值是不一样的，在我们请求第三方SDK接口的时候就会带上它，这样他就会根据你的环境来返回不同的值\n\n比如开发环境需要110，测试环境需要111，生产环境需要112，那每次请求都要写，都要带上，就觉得很烦\n\n再举个现实例子，在和后端对接的时候，开发环境和生产环境的API一般都是不一样的，如下：\n\n * 开发和测试：http://test.api/\n * 生产：https://api/\n\n这时候我们总不能在每次生产前去改url等等，这不是很麻烦吗？如果有一次忘记修改了，那用户访问的不就是开发和测试的数据了？\n\n所以这时候我们就需要环境变量了\n\n\n如何处理#\n\n我们创建三个文件.env、.env.development、.env.production\n\n\n\n\n\n\n\n在 Vite 中的环境变量处理，Vite 中内置了 dotenv\n\nVite 使用 dotenv 这个第三方库，它会在你执行如npm run dev的时候自动读取.env文件，并解析这个文件中的对应环境变量，将其注入到\nprocess 对象上(process具体可看 node 章节)\n\n> 小知识：为什么 vite.config.js 可以书写成ES Module的形式，这是因为 Vite\n> 它在读取这个文件的时候率先使用node去解析文件语法，如果遇到ES Module就会将其转为 Common JS 规范\n\n我们就可以使用 process.env来获取各个值了，但注意 Vite 考虑到和其他配置的一些冲突问题， 默认是不加载 .env 文件将其值注入到\nprocess 对象上\n\n涉及到 vite.config.js 中的一些配置：\n\n * root：项目根目录（index.html 文件所在的位置）\n * envDir：用来配置当前环境变量的文件地址\n\nVite 给我们提供了一个函数，我们可以调用 loadEnv 来手动确认 env 文件\n\n\n\n * process.cwd 方法：返回当前 node 进程工作的目录，详情见 node 章节\n\n * mode：根据你的运行命令决定值，比如运行npm run dev，Vite会在后面补上mode，就变成运行npm run dev --mode\n   development，这时候mode 的值就是 development，我们也可以手动改变mode，自己取名，比如npm run dev --mode\n   dev，这时候mode 的值就是dev\n\n当我们调用 loadEnv 的时候，会做如下的事情：\n\n * 直接找到 .env 文件，并解析其中的环境变量放入到对象中\n * 会将传递进来的 mode 这个变量与 env\n   拼接：.env.[mode]，然后根据我们提供的目录去取对应的配置文件并进行解析，然后放入到对象中，这个放入是在之前的基础上添加的\n\n我们运行，打印如下，.env 公有的值有，开发环境的值也有\n\n\n\n\n客户端获取#\n\n上面我们获取到了 env 的环境变量，可他是在服务端获取的，如果是客户端，我们如何获取呢？\n\nVite 会将对应的环境变量注入到 import.meta.env 中，我们打印一下\n\n\n\n会发现并没有我们在 env 中定义的环境变量\n\n这是因为 Vite 做了一个校验拦截，为了防止我们将隐私性的变量直接送到其中\n\n如果你的变量不是以VITE开头的，它就不会帮你将环境变量注入到客户端中\n\n我们改一下env\n\n\n\n然后运行，查看就会发现已经有了\n\n\n\n如果我们不想要以 VITE 开头的配置，我们可以使用 envPrefix 配置\n\n\n\n然后把env 改一下\n\n\n\n我们运行一下看一下有没有变成 TEST_AAA，成功\n\n\n\n所以我们在请求的时候就可以根据环境变量来弄了","routePath":"/guide/engineering/vite/8-Vite环境变量处理","lang":"","toc":[{"text":"为何需要环境变量","id":"为何需要环境变量","depth":2,"charIndex":3},{"text":"如何处理","id":"如何处理","depth":2,"charIndex":401},{"text":"客户端获取","id":"客户端获取","depth":2,"charIndex":1363}],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"Vite开发服务器原理","content":"Vite dev server","routePath":"/guide/engineering/vite/9-Vite开发服务器原理","lang":"","toc":[{"text":"实现开发服务器","id":"实现开发服务器","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"","content":"学习结构#\n\n","routePath":"/guide/","lang":"","toc":[{"text":"学习结构","id":"学习结构","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"","content":"文档声明#\n\n\n经典真题#\n\n * 什么是？是否需要在 HTML5 中使用？\n * 什么是严格模式与混杂模式？\n * 列举几条怪异模式中的怪癖行为？\n\n\n文档声明概念#\n\nHTML 文档通常以文档声明开始，该声明的作用是帮助浏览器确定其尝试解析和显示的 HTML 文档类型。\n\n\n\n文档声明必须是 HTML 文档的第一行、且顶格显示，对大小写不敏感。因为任何放在 DOCTYPE 前面的东西，比如批注或 XML 声明，会令 IE9\n或更早期的浏览器触发怪异模式(后面的渲染模式会介绍)\n\n文档声明并非一个 HTML 标签。它是一条\"信息\"，告知浏览器期望的文档类型。\n\n那么说到文档类型，我们首先有必要先了解一下 HTML 的发展历史。如下图所示:\n\n版本          年份\nHTML        1991\nHTML+       1993\nHTML 2.0    1995\nHTML 3.2    1996\nHTML 4.01   1999\nXHTML 1.0   2000\nHTML 5      2014\n\n> 其中还有很多，就不细分了\n\n可以看到，HTML 版本从最开始诞生到最新的 HTML5，中间经历了很多版本。 那不同的版本有啥区别么?当然有区别，比如一个最显著的区别就是支持的 HTML\n元素不同。例如下面的举例，还有很多区别\n\n标签       HTML 5   HTML 4   XHTML\na        Yes      Yes      Yes\napplet   No       Yes      No\naside    Yes      No       No\naudio    Yes      No       No\narea     Yes      Yes      No\n\n> 更多可以参考：https://www.w3school.com.cn/tags/html_ref_dtd.asp\n\n所以，你现在就知道为什么要书写文档声明了。原因是不同版本所支持的 HTML 元素类型是不同的，我需要告诉浏览器以哪一种文档类型方式来解析当前的这个 HTML\n文件。\n\n那么，最新的 HTML5 的文档类型倒是很简单，前面我们已经看到了\n\n\n\n那么稍微老一点的版本，例如 HTML4 或者 XHTML 的文档类型声明长啥样呢？\n\n这里我们看两个\n\nHTML 4.01 Strict\n\n该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素(比如 font)。不允许框架集（Framesets）。\n\n\n\nHTML 4.01 Transitional\n\n该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素(比如 font)。不允许框架集（Framesets）。\n\n\n\n> 更多参考：https://www.w3school.com.cn/tags/tag_doctype.asp\n\n首先，给我们的第一直观感受， 就是声明写得很长。\n\n那么为什么会这么长呢?\n\n原因很简单，HTML5 不需要引入DTD文件，而其他类型的文档声明是需要引入DTD的。\n\n很好，一个新的名词出现了，DTD.\n\n在早期的 HTML 版本，例如 HTML 4.01 中， 声明之所以要引用DTD，是因为 HTML 4.01\n基于SGML。而DTD规定的是标记语言的规则，这样浏览器才能正确地呈现内容。\n\n但是最新的 HTML 5 不基于 SGML,所以不需要引用 DTD。\n\n到这里估计有的小伙伴要懵圈了，怎么又冒出来一个SGML ? ?\n\n是的，你没有看错，我们有: SGML、HTML、XML、XHTML、HTML5\n\n从这五者的名字中，我们都可以看到\"ML\"这两个字母，所以我们先从ML说起。\n\n\"ML\"即\"Markup language(置标语言)\"。\n\n根据维基百科对其的解释，\"Markup\nlanguage\"是用标准的标记来解释纯文本文档的内容，从而提供关于文档结构或文档该如何渲染的信息。置标语言的发展可以用下面来表示:\n\n\n\nGML 是第一代置标语言，使文档能明确将标示和内容分开，所有文件使用同样的标示方法。\n\nSGML 在 GML 的基础上进行整理，形成了一套非常严谨的文件描述方法。它的组成包括语法定义，DTD,文件实例三部分。SGML 因太严谨规范达 500\n多页，故而不易学、不易用、难以实现，所以在它的基础上又发展出了其他的更易用的置标语言。\n\nHTML 抛弃了 SGML 复杂庞大的缺点，继承了 SGML 的很多优点。HTML 最大的特点是简单性和跨平台性。它只使用了 SGML 中很少的一部分标记，例如\nHTML 4.0 中只定义了 70 余种标记。为了便于在计算机上实现，HTML 规定的标记是固定的，即 HTML 语法是不可扩展的。\n\n随着 Web 应用的不断发展，HTML 的局限性也越来越明显地显现了出来，如 HTML 无法描述数据、可读性差、搜索时间长等。人们又把目光转向\nSGML，再次改造 SGML 使之适应现在的网络需求。1998 年 2 月 10 日，W3C(World Wide Web\nConsortium，万维网联盟)公布 XML 1.0 标准，XML 诞生了。很长一段时间，XML 都作为网络传输的标准数据格式。\n\nXHTML 的出现是因为当时的 HTML\n语法要求比较松散，这样对网页编写者来说，比较方便，但对于机器来说，语言的语法越松散，处理起来就越困难，对于传统的计算机来说，还有能力兼容松散语法，但对于许多其他\n设备，比如手机，难度就比较大。因此产生了由 DTD 定义规则，语法要求更加严格的 XHTML。\n\n> DTD 教程可以参考：https://www.w3school.com.cn/dtd/index.asp\n\n最终，HTML5 是 HTML 的第五个修订版，该版本不在基于 SGML 了，所以也就不用再引入 DTD 声明了。\n\nHTML5 的出现，其主要的目标是将互联网语义化，以便更好地被人类和机器阅读，并同时提供更好地支持各种媒体的嵌入。\n\n现在国内通常所说的 H5 开发，实际上是 HTML5 与 CSS3 及 ES6 的一个组合，大概可以用以下公式说明: HTML5 ≈ HTML5 + CSS3\n+ ES6\n\n\n渲染模式#\n\n明白了文档类型声明的作用之后，接下来我们还需要看一个东西，那就是渲染模式。\n\n浏览器渲染模式分为 3 种：\n\n * 怪癖模式（混杂模式）[Quirks mode]\n * 严格模式（标准模式）[Standars mode]\n * 几乎标准模式 [Almost standars mode]\n\n之所以出现不同的渲染模式，是由于历史原因造成的。\n\n当年 Netscape4 (网景公司早期的浏览器)和 IE4 (微软公司早期的浏览器)实现 CSS 机制时，没有遵循 W3C 提出的标准。Netscape4\n提供了糟糕的支持，而 1E4 虽然接近标准，但依旧未能完全正确的支持标准。\n\n所以，在 W3C 标准推出以前，浏览器在对页面的渲染上没有统一规范，产生了差异(Quirks mode 或者称为 Compatibility Mode)\n\n为了保障自己的网站在各个浏览器上显示正确，网页开发者们不得不依据各个浏览器自身的规范来使用 CSS，因此大部分网站的 CSS 实现并不符合 W3C 规范的标准。\n\nW3C 标准推出后，浏览器渲染页面有了统一的标准(Strict mode 也有叫做 Standars\nmode)浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致\n页面显示异常。\n\n为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法(如:微软的 IE) 。这样浏览器渲染上就产生了 Quircks mode 和\nStandars mode, 两种渲染方法共存在一个浏览器上。混杂模式服务于旧式规则，而严格模式服务于标准规则。\n\n> 对于 HTML 文档来说，浏览器使用文档开头的 DOCTYPE 来决定用怪异模式处理或标准模式处理。如果文档中没有 DOCTYPE\n> 将触发文档的怪异模式。怪异模式最明显的影响是会触发怪异盒模型。\n> \n> 在 DOCTYPE 声明中，没有使用 DTD 声明或者使用 HTML4 以下的 DTD 声明时，基本所有的浏览器都是使用 Quirks mode\n> 呈现，其他的则使用 Standars mode 解析。\n\n严格模式和怪异模式的部分渲染区别#\n\n 1. 盒模型的高宽包含内边距 padding 和 边框 border\n\n在 W3C 标准中，如果设置一个元素的宽度和高度， 指的是元素内容的宽度和高度，而在 IE5.5 及以下的浏览器及其他版本的怪异模式下，IE\n的宽度和高度还包含了 padding 和 border\n\n 2. 可以设置行内元素的高宽\n\n在严格模式下，给 span 等行内元素设置 width 和 height 都不会生效，而在怪异模式下，则会生效。\n\n 3. 可设置百分比的高度\n\n在严格模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。\n\n 4. 用margin:0 auto设置水平居中在 IE 下会失效\n\n使用margin:0 auto在严格模式下可以使元素水平居中，但在怪异模式下却会失效，怪异模式下的解决办法，用 text-align 属性:\nbody{text-align:center};#content{text-aligin:left}\n\n 5. 怪异模式下设置图片的 padding 会失效\n 6. 怪异模式下 Table 中的字体属性不能继承上层的设置\n 7. 怪异模式下white-space:pre会失效\n\n> 更多参考\n> MDN：https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standard\n> s_Mode\n> \n> MDN 还给出了不同模式下在不同浏览器的渲染区别(英文)：https://hsivonen.fi/doctype/\n\n\n真题解答#\n\n * 什么是？是否需要在 HTML5 中使用？\n\n> 它是 HTML 的文档声明，通过它告诉浏览器，使用哪一个 HTML 版本标准解析文档。\n> \n> 在浏览器发展的历史中，HTML\n> 出现过很多个版本，不同版本在元素、属性等书写格式上略有差异，如果不预先告诉浏览器，浏览器就不知道我们的文档标准是什么，在这种情况下，大部分浏览器将开启最大兼\n> 容模式来解析网页，我们称之为怪异模式。这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的 bug,所以文档声明是必须的。\n> \n> 而文档声明有多种书写格式，对应不同的 HTML 版本，这种书写是告诉浏览器，整个文档使用 HTML5 的标准进行解析。\n\n * 什么是严格模式与混杂模式？\n\n> 严格模式:又称标准模式，是指浏览器按照 W3C 标准解析代码。\n> \n> 混杂模式:又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。\n> \n> 如何区分:浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。\n> \n>  1. 如果文档包含严格的 DOCTYPE,那么它一般以严格模式呈现。(严格 DTD——严格模式)\n> \n>  2. 包含过渡 DTD 和 URI 的 DOCTYPE，也以严格模式呈现，但有过渡 DTD 而没有 URI\n>     (统一资源标识符，就是声明最后的地址)会导致页面以混杂模式呈现。(有 URI 的过渡 DTD——严格模式；没有 URI 的过渡 DTD——混杂模式)\n> \n>  3. DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。 (DTD 不存在或者格式不正确——混杂模式)\n> \n>  4. HTML5 没有 DTD,因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。( HTML5\n>     没有严格和混杂之分)\n> \n> 意义：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，\n> 每个浏览器都有自己的解析模式。\n\n * 列举几条怪异模式中的怪癖行为？\n\n>  1. 宽高的算法与 W3C 盒模型不同\n>  2. 在表格中的字体样式不会继承\n>  3. 怪异模式下可以设置行内元素宽高\n>  4. 怪异模式下 white-space:pre 会失效","routePath":"/guide/interview/html/1-文档声明","lang":"","toc":[{"text":"文档声明","id":"文档声明","depth":2,"charIndex":-1},{"text":"经典真题","id":"经典真题","depth":3,"charIndex":7},{"text":"文档声明概念","id":"文档声明概念","depth":3,"charIndex":76},{"text":"渲染模式","id":"渲染模式","depth":3,"charIndex":2624},{"text":"严格模式和怪异模式的部分渲染区别","id":"严格模式和怪异模式的部分渲染区别","depth":4,"charIndex":3569},{"text":"真题解答","id":"真题解答","depth":3,"charIndex":4282}],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"","content":"语义化#\n\n\n经典真题#\n\n * 说说对HTML 语义化的理解\n\n\n什么是语义元素？#\n\n语义是指对一个词或者句子含义的正确解释。很多HTML标签也具有语义的意义，也就是说元素本身传达了关于标签所包含内容类型的一些信息。例如，当浏览器解析到\n\n\n\n\n标签时，它将该标签解释为包含这一块内容的最重要的标题。h1标签的语义就是用它来标识特定网页或部分最重要的标题。\n\n\n为什么要语义化？#\n\n * 代码结构：使页面没有css的情况下，也能够呈现出很好的内容结构\n * 有利于SEO：爬虫依赖标签来确定关键字的权重，因此可以和搜索引擎建立良好的沟通，帮助爬虫抓取更多的有效信息\n * 提升用户体验：例如title、alt可以用于解释名称或者解释图片信息，以及label标签的灵活运用。\n * 便于团队开发和维护：语义化使得代码更具有可读性，让其他开发人员更加理解你的htm/结构，减少差异化\n * 方便其他设备解析：如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染网页。\n\n\nHTML5 常用的语义元素#\n\nHTML5提供了新的语义元素来定义网页的不同部分，它们被称为“切片元素\"，如图所示:\n\n\n\n * header：用于定义页面的头部区域，通常包括网站logo、主导航、全站链接以及搜索框。\n * nav：定义页面的导航链接部分区域。\n * main：定义文档的主要内容，该内容在文档中应当是独一无二的\n * article：定义页面独立的内容，它可以有自己的header、footer、sections等，专注于单个主题的博客文章，报纸文章或网页文章。\n * section：表示文档中的一个区域（或节），比如，内容中的一个专题组\n * aside：表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的部分 且可以被单独的拆分出来而不会影响整体。通常表现为侧边栏或嵌入内容。\n * footer：定义最近一个章节内容或者根节点元素的页脚。-个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。\n\n> 有很多100多个html语义元素可以选择，更多参考：https://developer.mozilla.org/en-US/docs/Web/HTML/El\n> ement\n\n\n无障碍网页#\n\nW3C在1997年发起了一项WAI (Web Acessibility\nInitiative)的计划，该计划的目标是提升网站的易用性(acssibiliy)，而其中有一个很重要的指标，那就是能够被残障人士使用的网站才能称得上一个易用\n的(易访问的)网站。\n\nHTML5在无障碍方面进行了加强，加入了无障碍属性。\n\n所谓HTML5无障碍属性，主要针对的是视觉缺陷，失聪，行动不便的残疾人以及假装残疾的测试人员。尤其像盲人，眼睛看不到，其浏览网页则需要借助辅助设备，如屏幕阅读器\n，屏幕阅读机可以大声朗读或者输出盲文。\n\n而HTML5无障碍属性就是可以让屏幕阅读器准确识别网页中的内容，变化，状态的技术规范，可以让盲人这类用户也能无障碍阅读!\n\n> 关于更多说明，参考MDN：https://developer.mozilla.org/zh-CN/docs/Web/Accessibility\n\n常见的无障碍属性\n\nWAI-ARIA是W3C编写的规范，定义了一组可用于其他元素的HTML 特性，用手提供额外的语义化以及改善缺乏的可访问性。以下是规范中三个主要的特性:\n\n * 角色：这定义了元素是干什么的。许多「标志性的角色」，其实重复了HTML5的结构元素的语义价值。例如 role= \"navigation\"\n   (nav)或者role=\"complementary\" (aside)。\n * 属性：我们能通过定义一些属性给元素，让他们具备更多的语义。例如: aria-required=\"true\"\n   意味着元素在表单上是必填的。然而aril-labelledby=\n   \"label\"允许在元素上设置一个ID，用于labelledby引用作为屏幕阅读器指定的label内容，多个也可以。\n * 状态：用于表达元素当前的条件的特殊属性，例如aria\n   disabled=\"true\",屏幕阅读器就会这个表单禁止输入。状态和属性的差异之处就是:属性在应用的生命周期中不会改变，而状态可以，通常我们用编程的方法\n   改变它，例如Javascript\n\n关于WAI-ARIA属性重要的一点是它不会对Web页面有任何影响，除了让更多的信息从浏览器暴露给acessibilitAPIs (无障碍API),\n这也是屏幕阅读器这一类软件的信息源。WAI-ARIA不会影响网页的结构，以及DOM等等，尽管这些属性可用于作为CSS选择器。\n\n> 更多参阅：[https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility/WAI-ARIA_ba\n> sics]*https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility/WAI-ARIA_ba\n> sics\n\n\n真题解答#\n\n * 说说对html语义化的理解\n\n语义化的目的主要有以下几点：\n\n 1. 去掉或者丢失样式的时候能够让页面呈现出清晰的结构\n\n 2. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息:爬虫依赖于标签来确定上下和各个关键字的权重\n\n 3. 方便其他设备解析(如屏幕阅读器、盲人阅读器、移动设备)以意义的方式来渲染网页\n\n 4. 便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。HTML5 中新增加的很多标签，例如:\n    article、 nav, header 和footer等，就是基于语义化设计原则","routePath":"/guide/interview/html/2-语义化","lang":"","toc":[{"text":"语义化","id":"语义化","depth":2,"charIndex":-1},{"text":"经典真题","id":"经典真题","depth":3,"charIndex":6},{"text":"什么是语义元素？","id":"什么是语义元素","depth":3,"charIndex":33},{"text":"为什么要语义化？","id":"为什么要语义化","depth":3,"charIndex":182},{"text":"HTML5 常用的语义元素","id":"html5-常用的语义元素","depth":3,"charIndex":439},{"text":"无障碍网页","id":"无障碍网页","depth":3,"charIndex":952},{"text":"真题解答","id":"真题解答","depth":3,"charIndex":2151}],"domain":"","frontmatter":{},"version":""},{"id":27,"title":"","content":"W3C#\n\n\n经典真题#\n\n对于 WEB 标准以及 W3C 的理解与认识问题\n\n\n什么是 W3C#\n\n * W3C 指万维网联盟(World Wide Web Consortium)\n * W3C 创建于 1994 年 10 月\n * W3C 由 Tim Berners-Lee 创建\n * W3C 是一个会员组织\n * W3C 的工作是对 web 进行标准化\n * W3C 创建并维护 WWW 标准\n * W3C 标准被称为 W3C 推荐( W3C 规范)\n\n\nW3C 是如何创建的？#\n\n万维网(World Wide Web)是作为欧洲核子研究组织的一个项目发展起来的，在那里Tim Berners-Lee开发出万维网的雏形。Tim\nBerners-Lee是万维网的发明人，目前是万维网联盟的主任。\n\nW3C在1994年被创建，其创立目的是为了完成麻省理工学院(MIT) 与欧洲粒子物理研究所(CERN)\n之间的协同工作，并得到了美国国防部高级研究计划局(DARPA) 和欧洲委员会(European Commission)的支持。\n\n\n标准化 Web#\n\nW3C致力于实现所有的用户都能够对Web加以利用(不论其文化教育背景、能力、财力以及其身体残疾)。\n\nW3C同时与其他标准化组织协同工作，比如Internet工程工作小组(Internet Engineering Task Force)、 无线应用协议(WAP)\n以及Unicode联盟(Unicode Consortium)。\n\nW3C由美国麻省理工学院计算机科学和人工智能实验室(MIT CSAIL),总部位于法国的欧洲信息数学研究联盟 (ERCIM)和日本的庆应大学(Keio\nUniversity)联合运作，并且在世界范围内拥有分支办事处。\n\n\nW3C 成员#\n\n正因为Web是如此的重要(不论在其影响范围还是在投资方面)，以至于不应由任何一家单独的组织来对它的未来进行控制，因此W3C扮演着一个会员组织的角色\n\n一些知名的会员包括:\n\n * IBM\n * Microsoft\n * America Online\n * Apple\n * Adobe\n * Macromedia\n * Sun Microsystems\n\nW3C的会员包括了:软件开发商、内容提供商、企业用户、通信公司、研究机构、研究实验室、标准化团体以及政府\n\n\nW3C 规范的批准步骤#\n\n在W3C发布某个新标准的过程中，规范是通过下面的严格程序由一个简单的理念逐步确立为推荐标准的：\n\n * W3C 收到一份提交\n * 由 W3C 发布一份记录\n * 由 W3C 创建一个工作组\n * 由 W3C 发布一份工作草案\n * 由 W3C 发布一份候选的推荐\n * 由 W3C 发布一份被提议的推荐\n * 由 W3C 发布推荐\n\n> 具体步骤参阅：https://www.runoob.com/w3c/w3c-process.html\n\n\n真题解答#\n\n对于 WEB 标准以及 W3C 的理解与认识问题\n\n答：\n\n任何东西都需要一个标准， 有了标准才能够更好的进行交流和推广。不同的标准，得出的便是不同的结果。因此，制定什么样的标准，如何确立标准，至关重要。\n\n正因为有了网页的标准，才能降低开发难度及开发成本，减少各种BUG、安全问题，提高网站易用性。\n\n就好比HTML在W3C组织推出标准之前，不同的浏览器厂商有一套自己的标准，这对于开发人员来讲是痛苦 的，所以才会遗留下浏览器的标准模式和怪异模式这个历史问题。\n\nW3C就是一个推出标准的组织，被称之为万维网联盟，W3C最重要的工作是发展Web规范。","routePath":"/guide/interview/html/3-W3C","lang":"","toc":[{"text":"W3C","id":"w3c","depth":2,"charIndex":-1},{"text":"经典真题","id":"经典真题","depth":3,"charIndex":6},{"text":"什么是 W3C","id":"什么是-w3c","depth":3,"charIndex":40},{"text":"W3C 是如何创建的？","id":"w3c-是如何创建的","depth":3,"charIndex":231},{"text":"标准化 Web","id":"标准化-web","depth":3,"charIndex":470},{"text":"W3C 成员","id":"w3c-成员","depth":3,"charIndex":757},{"text":"W3C 规范的批准步骤","id":"w3c-规范的批准步骤","depth":3,"charIndex":999},{"text":"真题解答","id":"真题解答","depth":3,"charIndex":1236}],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"","content":"SEO#\n\n\n经典真题#\n\n请描述下 SEO 中的 TDK？\n\n\n什么是 SEO#\n\nSEO 由英文 Search Engine Optimization 缩写而来，中文意译为 搜索引擎优化 。\n\n其实叫做针对搜索引擎优化更容易理解。它是指从自然搜索结果获得网站流量的技术和过程，是在了解搜索引擎自然排名机制的基础上，对网站进行内部及外部的调整优化，改进网站\n在搜索引擎中的关键词自然排名，获得更多流量，从而达成网站销售及品牌建设的目标。\n\n\n如何进行 SEO 优化工作？#\n\n有的同学第一反应:给钱。\n\n虽然，国内的百度搜索引擎，确实存在给钱就把你排在前面的情况，但是在不给钱的情况下，我们也能够通过一些优化手段来提升页面的权重，从而使我们的页面获取更多流量。\n\n下面就介绍一些常见的SEO优化手段。\n\n整个SEO工作大致可以分为内部优化和外部优化。\n\n内部优化#\n\n1-合理的 title、description、keywords#\n\n这个就是上面题中出现的 TDK，其实就是这3个单词的缩写。\n\n * title：浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到，搜索引擎在抓取网页时，最先读取的就是网页标题，所以 title\n   是否正确设置极其重要。title 一般不超过80个字符，而且词语间要用英文 \"-\" 隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。\n * description：也就是网页的内容摘要，这是对于一个网页的简要内容概况。description 一般不超过150个字符，描述内容和页面内容相关。\n * keywords：主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此 keywords\n   的每个词都要能在内容中找到相应匹配，才有利于排名。keywords 一般不超过3个，每个关键词不宜过长，而且词语间要用英文 \",\"\n   隔开，尽量将重要的关键字靠前放。\n\n2-语义化的 HTML 代码，符合 W3C 规范#\n\n语义化代码能够让搜索引擎容易理解网页，即使脱去了CSS这层外衣，整个网页的结构也是清清楚楚的，无论是搜索引擎还是阅读者，都能够很容易的分辨网页的结构。\n\n关于语义化的具体内容，可以参阅《语义化》章节。\n\n3-非装饰性图片必须加 alt#\n\nimg标签的alt属性指定了替代文本，用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容。\n\n例如：\n\nalt 的作用：\n\n * 增强内容相关性：它是可以利用汉字介绍文章内容的，对于一些特定的企业产品，由于视觉的体验，它往往是少文字的。\n * 提高关键词密度：在操作企业站的时候，我们经常遇到是站点首屏一个大的橫幅banner，几乎占用了首页的大部分页面，为了有效的提高首页核心关键词密度，我们只能\n   利用一切办法增添关键词，比如:在图片的 alt 标签中添加。\n\n4-对于不显示的对象谨慎使用 display: none#\n\n对于不想显示的文字内容，应当设置 z-index 或设置到浏览器显示器之外。因为搜索引擎会过滤掉 display: none 其中的内容。\n\n5-重要内容 HTML 代码放在最前#\n\n搜索引擎抓取HTML顺序是从上到下，所以我们尽量将重要的内容放在前面，保证重要内容一定会被抓取。\n\n6-少用 iframe#\n\n少用或者尽量不用 iframe，因为搜索引擎不会抓取 iframe 中的内容\n\n> 还有很多很多，诸如SSR渲染等\n\n外部优化#\n\n外部优化主要是指放友情链接和外链。好的友情链接可以快速的提高网站的权重，高质量的外链，会给你的网站提高源源不断的权重提升。另外，就是要向各大搜索引擎登陆入口提交\n尚未收录站点。\n\n\n真题解答#\n\n请描述下 SEO 中的 TDK\n\n答：参考上面，可以简短一点。","routePath":"/guide/interview/html/4-SEO","lang":"","toc":[{"text":"SEO","id":"seo","depth":2,"charIndex":-1},{"text":"经典真题","id":"经典真题","depth":3,"charIndex":6},{"text":"什么是 SEO","id":"什么是-seo","depth":3,"charIndex":32},{"text":"如何进行 SEO 优化工作？","id":"如何进行-seo-优化工作","depth":3,"charIndex":221},{"text":"内部优化","id":"内部优化","depth":4,"charIndex":377},{"text":"外部优化","id":"外部优化","depth":4,"charIndex":1453},{"text":"真题解答","id":"真题解答","depth":3,"charIndex":1551}],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"","content":"iframe 示例","routePath":"/guide/interview/html/5-iframe","lang":"","toc":[{"text":"iframe","id":"iframe","depth":2,"charIndex":-1},{"text":"经典真题","id":"经典真题","depth":3,"charIndex":-1},{"text":"iframe 介绍","id":"iframe-介绍","depth":3,"charIndex":-1},{"text":"真题解答","id":"真题解答","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"","content":"微格式#","routePath":"/guide/interview/html/6-微格式","lang":"","toc":[{"text":"微格式","id":"微格式","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"","content":"替换元素#","routePath":"/guide/interview/html/7-替换元素","lang":"","toc":[{"text":"替换元素","id":"替换元素","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":32,"title":"","content":"页面可见性#","routePath":"/guide/interview/html/8-页面可见性","lang":"","toc":[{"text":"页面可见性","id":"页面可见性","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":33,"title":"","content":"html 章节总结#","routePath":"/guide/interview/html/","lang":"","toc":[{"text":"html 章节总结","id":"html-章节总结","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":34,"title":"","content":"各章总结#","routePath":"/guide/interview/","lang":"","toc":[{"text":"各章总结","id":"各章总结","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":35,"title":"","content":"JS 高级#","routePath":"/guide/js/","lang":"","toc":[{"text":"JS 高级","id":"js-高级","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":36,"title":"","content":"OSI七层参考模型 & TCP/IP 四层/五层模型图#\n\n\n\n\n物理层#\n\n物理层是直接和物理介质打交道的。\n\n物理层的设备网卡，网线，集线器，中继器，调制解调器\n\n物理层信道：\n\n * 有线信道\n   * 明线：即高空架设暴露在外的线路\n   * 对称电缆：由多对双绞线组成的线缆\n   * 同轴电缆：由中心导体、绝缘层、外层导体、外皮组成(应用极为广泛)\n   * 光纤：由玻璃或塑料制成的纤维，利用光在纤维中以全反射原理传输\n * 无限信道：\n   * 无线电波：如WiFi\n\n在这一层通过(电，光，无线电波)，会获取他们对应的传送信号，电压，转换成010101010101但是数据还未组织，它们的单位为bit，所以在这一层主要就是传输比\n特流\n\n本层重点：比特流\n\n\n数据链路层#\n\n将比特流传入，建立逻辑连接、进行硬件地址寻址、差错校验等功能。( 由底层网络定义协议)\n\n将比特组合成字节进而组合成数据帧，用MAC地址访问介质，错误发现但不能纠正\n\nMAC地址:每个网卡的唯一标识\n\n> 有了Mac地址之后就可以知道谁是接收者，谁是发送者，并且知道了数据的内容 并且进行了分组。\n> 那么他如何进行传播数据，他是进行广播的方式进行传输,在局域网内所有的计 算机都能收到消息\n\n在Windows下可以通过在终端输入ipconfig/all来查看物理地址即MAC地址\n\n在Mac下可以通过ifconfig/all来查看物理地址\n\n有了数据帧就可以通过交换机来进行交互\n\n本层重点：数据帧\n\n\n网络层#\n\n网络层是最复杂的一层，在这一层就定义了我们的IP，20.xxx.xx.xxx\n\n该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出\n路由等控制，将信息从一个网络设备传送到另一个网络设备\n\n1.寻址:对网络层而言使用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信(类似于数据链路层的MAC地址)\n\n2.路由:在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备\n\n这一层的经常被叫数据包\n\n\n传输层#\n\n传输层主要就是定义我们的端口号，以及控流，和校验。\n\n并且拥有两个熟知的协议TCP UDP\n\n * TCP是面向连接的协议并且TCP是可靠的 因为TCP会进行三次握手四次挥手所以是可靠的，但是这样会降低速度\n\n * UDP具有较好的实时性效率比TCP高 UDP是没有三次握手四次挥手的，故此不稳定，但是速度快常用于直播\n\n这一层经常被叫数据段\n\n\n会话层#\n\n会话层，是在发送方和接收方之间进行通信时创建、维持、之后终止或断开连接的地方，与电话通话有点相似\n\n会话层定义了一种机制，允许发送方和接收方启动或停止请求会话，以及当双方发生拥塞时仍然能保持对话\n\n会话层包含了一种称为检查点(Checkpoint) 的机制来维持可靠\n会话。检查点定义了一个最接近成功通信的点，并且定义了当发生内容丢失或损坏时需要回滚以便恢复丢失或损坏数据的点，即断点下载的原理\n\n这一层经常被叫报文\n\n\n表示层#\n\n表示层主要做了几件重要的事情安全，压缩，也是程序在网络中的一个翻译官\n\n1.安全在你的数据发送之前进行加密，在接受者的表示层进行解密\n\n2.表示层还会对图片文件等格式进行解码和编码例如JPEG、ASCII图片是人类能读懂的计算机需要转换成计算机能读懂的编码。\n\n这一层经常被叫报文\n\n\n应用层#\n\n应用层就是我们使用最多的一层\n\n例如：\n\n * ajax调用接口发送http请求\n\n * 域名系统DNS\n\n * 邮件协议SMTP\n\n * webSocket长连接\n\n * SSH协议\n\n这一层经常被叫报文","routePath":"/guide/network/1-OSI七层模型","lang":"","toc":[{"text":"OSI七层参考模型 & TCP/IP 四层/五层模型图","id":"osi七层参考模型--tcpip-四层五层模型图","depth":2,"charIndex":-1},{"text":"物理层","id":"物理层","depth":3,"charIndex":32},{"text":"数据链路层","id":"数据链路层","depth":3,"charIndex":338},{"text":"网络层","id":"网络层","depth":3,"charIndex":649},{"text":"传输层","id":"传输层","depth":3,"charIndex":954},{"text":"会话层","id":"会话层","depth":3,"charIndex":1134},{"text":"表示层","id":"表示层","depth":3,"charIndex":1351},{"text":"应用层","id":"应用层","depth":3,"charIndex":1500}],"domain":"","frontmatter":{},"version":""},{"id":37,"title":"","content":"TCP三次握手#\n\n先认识名词\n\n * seq（sequence number）序列号随机生成的\n * ack（acknowledgement number）确认号ack= seq+ 1\n * ACK（acknowledgement）确定序列号有效\n * SYN（synchronous）发起新连接\n * FIN（FINSH）完成\n\n一张流程图解决\n\n\n\n我们可以通过Wireshark工具来查看，免费开源\n\n在我们发送http请求之前，有三个TCP连接即三次握手\n\n * 第一步客户端生成Seq为0发送\n * 第二步服务端让Seq+1验证，验证通过，打上ACK=1\n * 第三步客户端让Seq = 客户端Seq + 1\n\n\n\n\nTCP四次挥手#\n\n超时等待状态（TIME_WAIT）：如果最后一个过程ACK标记在某个情况下丢失，但那这样服务端就永远不会断开了，就不稳定了，所以为了弥补缺失，执行了超时等待状态\n，如果丢失，服务器会重新发送断开连接的请求，ACK会重新发送，保证TCP链接可靠\n\n\n\n我们依旧可以通过工具来查看四次挥手\n\n * 第一步客户端生成Seq=673\n * 第二步服务端让Seq+1验证，通过，打上标记ACk=674\n\n> 此时进入WAIT_2阶段，如果还有别的任务会在这个阶段进行处理，完成后才进行第三次挥手\n\n * 第三步服务端发送FIN请求，验证ACK是否正确（通过客户端Seq+1），服务端还会生成一个它对应的Seq\n * 第四步客户端有一个ACK标记，通过服务端的Seq+1验证，它自身的Seq通过客户端自身Seq+1实现，最后CLOSE结束\n\n","routePath":"/guide/network/2-TCP三次握手和四次挥手","lang":"","toc":[{"text":"TCP三次握手","id":"tcp三次握手","depth":2,"charIndex":-1},{"text":"TCP四次挥手","id":"tcp四次挥手","depth":2,"charIndex":314}],"domain":"","frontmatter":{},"version":""},{"id":38,"title":"","content":"过程#\n\nURL的组成不多解释，可自己查询\n\n在我们有了IP后，因为IP又长又难记，所以就产生了域名，但访问域名，网络是如何找到对应的服务器呢？就是通过DNS查询\n\nDNS是把IP和域名进行了一个映射，通过域名找到对应的IP，再拿到正确的资源\n\n\nDNS查询顺序#\n\n如下，若其中一步成功则直接跳到建立链接部分：\n\n * 浏览器自身DNS\n * 操作系统DNS\n * 本地hosts文件\n * 向域名服务器发送请求\n\n\n域名解析#\n\n * 请求发起后，游览器首先会解析这个域名，首先它会查看本地硬盘的hosts文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用hosts文件里面的i\n   p地址\n * 如果在本地的hosts文件没有能够找到对应的ip地址，浏览器会发出一个DNS请求到本地DNS(域名分布系统)服务器。本地DNS服务器一般都是你的网络接入服\n   务器商提供，比如中国电信，中国移动。\n * 查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式\n   进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询\n * 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程\n\n\noptions请求：#\n\n两种情况会发出options请求\n\n * 发送跨域请求的时候\n * 自定义请求头的时候\n\n\n强缓存#\n\n\n\n\n协商缓存#\n\n","routePath":"/guide/network/3-浏览器输入URL后发生了什么","lang":"","toc":[{"text":"过程","id":"过程","depth":2,"charIndex":-1},{"text":"**DNS**查询顺序","id":"dns查询顺序","depth":3,"charIndex":-1},{"text":"域名解析","id":"域名解析","depth":3,"charIndex":209},{"text":"options请求：","id":"options请求","depth":3,"charIndex":606},{"text":"强缓存","id":"强缓存","depth":3,"charIndex":665},{"text":"协商缓存","id":"协商缓存","depth":3,"charIndex":674}],"domain":"","frontmatter":{},"version":""},{"id":39,"title":"","content":"CDN#\n\nContent Delivery Network 内容分发网络\n\nCDN是用来优化网络资源请求的时间的\n\n\n网站上线#\n\n网站上线必须有一台服务器，这个服务器上面存放前端资源，然后搞一个域名，通过DNS将域名解析我们服务器的IP（127.xx.xx.xx）\n\n找服务器如下\n\n就近的服务器是可以缓存数据的，如果源服务器出现什么状况，可以保证数据不会崩掉，做异地灾备等措施\n\n\n\n\nCDN：工作过程#\n\n浏览器在输入url后，第一回合需要进行DNS解析，如果配置了CDN，DNS会将最终的域名解析权交给CNAME（别名指向）指向的CDN专用DNS服务器\n\n\n\n\nCDN：负载均衡#\n\n在CDN中，负载均衡又分为服务器负载均衡和服务器整体负载均衡(也有的称为服务器全局负载均衡)。\n\n服务器负载均衡是指能够在性能不同的服务器之间进行任务分配，既能保证性能差的服务器不成为系统的瓶颈，又能保证性能高的服务器的资源得到充分利用。而服务器整体负载均衡\n允许Web网络托管商、门户站点和企业根据地理位置分配内容和服务。\n\n通过使用多站点内容和服务来提高容错性和可用性，防止因本地网或区域网络中断、断电或自然灾害而导致的故障。在CDN的方案中服务器整体负载均衡将发挥重要作用，其性能高\n低将直接影响整个CDN的性能。\n\n","routePath":"/guide/network/4-CDN内容分发","lang":"","toc":[{"text":"CDN","id":"cdn","depth":2,"charIndex":-1},{"text":"网站上线","id":"网站上线","depth":3,"charIndex":59},{"text":"CDN：工作过程","id":"cdn工作过程","depth":3,"charIndex":195},{"text":"CDN：负载均衡","id":"cdn负载均衡","depth":3,"charIndex":285}],"domain":"","frontmatter":{},"version":""},{"id":40,"title":"","content":"同源策略及跨域问题#\n\n同源策略是一套浏览器安全机制，当一个源的文档和脚本，与另一个源的资源进行通信时，同源策略就会对这个通信做出不同程度的限制。\n\n简单来说，同源策略对 同源资源 放行，对 异源资源 限制\n\n> 请求的时候拥有相同的协议，域名端口，只要有一个不同就属于跨域\n\n因此限制造成的开发问题，称之为跨域（异源）问题\n\n同源和异源#\n\n\n\n例如:\n\nhttps://study.duyiedu.com/api/movie的源为https://study.duyiedu.com\n\nhttp://localhost:7001/index.html的源为http://localhost:7001\n\n两个URL地址的源完全相同，则称之为同源，否则称之为异源（跨域）\n\n\n\n跨域出现的场景#\n\n跨域可能出现在三种场景：\n\n * 网络通信\n   \n   a元素的跳转；加载css、js、图片等；AJAX等等\n\n * JS API\n   \n   window.open、window.parent、iframe.contentWindow等等\n\n * 存储\n   \n   WebStorage、IndexedDB等等\n\n对于不同的跨域场景，以及每个场景中不同的跨域方式，同源策略都有不同的限制。\n\n本文重点讨论网络通信中AJAX的跨域问题\n\n网络中的跨域#\n\n当浏览器运行页面后，会发出很多的网络请求，例如CSS、JS、图片、AJAX等等\n\n请求页面的源称之为页面源，在该页面中发出的请求称之为目标源。\n\n当页面源和目标源一致时，则为同源请求，否则为异源请求（跨域请求）\n\n\n\n浏览器如何限制异源请求？#\n\n浏览器出于多方面的考量，制定了非常繁杂的规则来限制各种跨域请求，但总体的原则非常简单：\n\n * 对标签发出的跨域请求轻微限制\n * 对AJAX发出的跨域请求严厉限制\n\n\n\n\n解决方案#\n\n第一个方案：jsonp#\n\n原理：通过script标签的src不受同源策略的限制，可以跨域请求数据\n\n缺点：只能发送get请求，不安全和不易维护，容易被非法站点恶意调用\n\n> 恶意攻击者可能利用callback=恶意函数的方式实现XSS攻击\n\n后端返回的是一个函数，但这个函数是在前端定义的，它会把值注入到这个函数的参数里面\n\n实现jsonp\n\n前端代码，放在HTML的script标签里,通过live server启动\n\n\n\n后端代码，用Node实现\n\n首先需要安装依赖\n\n\n\n代码,因为jsonp只能发送get请求，所以后端定义的时候也要定义为get请求\n\n\n\n第二个方案：前端代理#\n\n纯前端解决\n\n前端代码，用fetch发送请求\n\n\n\n后端代码，改动一点，这时直接请求/api/json会有跨域的\n\n\n\n此时如何解决跨域呢？我们需要借助构建工具完成\n\n安装vite（webpack等其他工具差不多）\n\n\n\n新建vite.config.ts文件\n\n\n\n然后我们需要启动一个vite服务，在package.json配置\n\n\n\n前端就不用live server启动了，用npm run dev启动，且请求的url改动一下\n\n\n\n此时跨域就解决了，因为vite会拦截服务，然后代理转发到3000端口\n\n> 服务端对服务端是没有跨域限制的，所以可以这样解决\n\n注意：此方法只对开发环境有效，上线还需要Nginx改动配置\n\n第三个方案：后端设置请求头#\n\n前端还是之前的，用live server启动\n\n后端代码，设置请求头\n\n\n\n第四个方案：Nginx代理#\n\n安装Nginx#\n\n第一种方式\n\n可以百度官网，点击对应版本，建议安装主线版本\n\n安装完成后，解压打开文件夹，双击nginx.exe文件启动\n\n配置文件在conf文件夹下的nginx.conf，改动即可\n\n第二种方式\n\n可以通过Microsoft Store商店，搜索wsl，找一个对应版本（我的为20.04.6），下载一个Ubuntu\n\n它其实就是一个linux的内核\n\n打开Ubuntu，输入apt-get install nginx下载\n\n打开我的电脑，下面有一个Linux，点击\n\n\n\n打开会发现我们刚刚安装的乌班图就在这，打开，nginx默认安装在etc下面\n\n找到nginx文件夹，进入sites-available目录，有一个default，打开更改\n\n更改Nginx配置#\n\n首先找到主机ip，在乌班图输入cat /etc/resolv.conf找到nameserver\n\n因为我们代理的时候不能用localhost，所以需要找到自己主机的ip\n\n打开配置后，我们只需在下面配置一个代理即可\n\n\n\n写完以后我们在乌班图启动nginx服务，输入nginx\n\n访问80端口，进入nginx，此时如果我们在浏览器控制台请求的话就没有跨域了\n\n","routePath":"/guide/network/5-跨域+四种解决方案","lang":"","toc":[{"text":"同源策略及跨域问题","id":"同源策略及跨域问题","depth":3,"charIndex":-1},{"text":"同源和异源","id":"同源和异源","depth":4,"charIndex":163},{"text":"跨域出现的场景","id":"跨域出现的场景","depth":4,"charIndex":337},{"text":"网络中的跨域","id":"网络中的跨域","depth":4,"charIndex":569},{"text":"浏览器如何限制异源请求？","id":"浏览器如何限制异源请求","depth":4,"charIndex":687},{"text":"解决方案","id":"解决方案","depth":3,"charIndex":789},{"text":"第一个方案：jsonp","id":"第一个方案jsonp","depth":4,"charIndex":796},{"text":"第二个方案：前端代理","id":"第二个方案前端代理","depth":4,"charIndex":1079},{"text":"第三个方案：后端设置请求头","id":"第三个方案后端设置请求头","depth":4,"charIndex":1406},{"text":"第四个方案：Nginx代理","id":"第四个方案nginx代理","depth":4,"charIndex":1460}],"domain":"","frontmatter":{},"version":""},{"id":41,"title":"","content":"计算机网络#\n\n在本章你将学习到计算机的基础模型，CDN 和跨域解决方案","routePath":"/guide/network/","lang":"","toc":[{"text":"计算机网络","id":"计算机网络","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":42,"title":"","content":"1-梦开始的地方#\n\n\n概述#\n\n 1. nodejs 并不是JavaScript应用，也不是编程语言，因为编程语言使用的JavaScript,Nodejs 是\n    JavaScript的运行时环境。\n\n\n\n 2. Nodejs 是构建在 V8 引擎之上的，V8 引擎是由 C/C++编写的，因此我们的 JavaSCript 代码需要由 C/C++转化后再执行。\n 3. NodeJs 使用异步 I/O 和事件驱动的设计理念，可以高效地处理大量并发请求，提供了非阻塞式 I/O\n    接口和事件循环机制，使得开发人员可以编写高性能、可扩展的应用程序,异步 I/O 最终都是由libuv 事件循环库去实现的。\n 4. NodeJs 使用 npm 作为包管理工具类似于 python 的 pip，或者是 java 的 Maven，目前 npm 拥有上百万个模块。\n    www.npmjs.com/\n 5. nodejs 适合干一些 IO 密集型应用，不适合 CPU 密集型应用，nodejsIO 依靠 libuv 有很强的处理能力，而 CPU 因为\n    nodejs 单线程原因，容易造成 CPU 占用率高，如果非要做 CPU 密集型应用，可以使用 C++插件编写 或者 nodejs\n    提供的cluster。(CPU 密集型指的是图像的处理 或者音频处理需要大量数据结构 + 算法)\n\n\nNodejs 大致架构图#\n\n\n\n\nNodejs 应用场景#\n\n以下展示并不是所有东西都是 nodejs 编写而是运行环境可以配合 nodejs 或者依靠 nodejs 运行。\n\n前端#\n\n * Vue\n * Angular\n * React\n * nuxtjs\n * nextjs\n\n后端#\n\n * serverLess\n\n * web 应用：epxress、Nestjs、koa (编写后端)\n\n * RPC 服务：gRPC(跨语言通信)\n\n * 爬虫：Puppeteer(自动化 UI 测试)、cheerio\n\n * BFF 层、网关层\n\n * 及时性应用 socket.io\n\n桌面端#\n\n * electron\n\n * tauri\n\n * NWjs\n\n移动端#\n\n * weex\n\n * ionic\n\n * hybrid\n\n * React Native\n\n基建端#\n\n * webpack、vite、rollup、gulp\n\n * less、scss、postCss\n\n * babel、swc\n\n * inquire、command 、shelljs\n\n嵌入式#\n\n * Ruff js\n\n单元测试#\n\n * jest、vitest、e2e\n\nCICD#\n\n * Jenkins、docker、Husky、miniprogram-ci\n\n反向代理#\n\n * http-proxy、Any-proxy\n\n\n安装 Nodejs#\n\n进入官网https://www.nodejs.com.cn/\n\n可以点击下载其他版本，Windows 可以下载.msi文件，安装非常简单，且会自动帮你自动配置环境变量，建议直接一直 next 下去安装即可\n\n如何检查是否安装成功呢？在 Windows 打开 cmd，输入以下三个，会输出版本号\n\n","routePath":"/guide/node/1-梦开始的地方","lang":"","toc":[{"text":"1-梦开始的地方","id":"1-梦开始的地方","depth":2,"charIndex":-1},{"text":"概述","id":"概述","depth":3,"charIndex":11},{"text":"Nodejs 大致架构图","id":"nodejs-大致架构图","depth":3,"charIndex":602},{"text":"Nodejs 应用场景","id":"nodejs-应用场景","depth":3,"charIndex":620},{"text":"安装 Nodejs","id":"安装-nodejs","depth":3,"charIndex":1211}],"domain":"","frontmatter":{},"version":""},{"id":43,"title":"","content":"10-CSR SSR SEO#\n\n\n概述#\n\n在上一章的时候我们说过在 node 环境中无法操作 DOM 和 BOM，但是如果非要操作 DOM 和 BOM 也是可以的我们需要使用第三方库帮助我们jsdom\n\n\n\njsdom 是一个模拟浏览器环境的库，可以在 Node.js 中使用 DOM API\n\n简单案例#\n\n\n\n运行完该脚本会在执行目录下生成 html 文件，里面内容都是渲染好的\n\n\n\n\nCSR SSR#\n\n我们上面的操作属于SSR (Server-Side Rendering)服务端渲染请求数据和拼装都在服务端完成\n\n而我们的Vue，React等框架(这里不谈 nuxtjs,nextjs)，是在客户端完成渲染拼接的属于CSR(Client-Side\nRendering)客户端渲染\n\nCSR 和 SSR 区别\n\n 1. 页面加载方式：\n    * CSR：在 CSR 中，服务器返回一个初始的 HTML 页面，然后浏览器下载并执行 JavaScript 文件，JavaScript\n      负责动态生成并更新页面内容。这意味着初始页面加载时，内容较少，页面结构和样式可能存在一定的延迟。\n    * SSR：在 SSR 中，服务器在返回给浏览器之前，会预先在服务器端生成完整的 HTML 页面，包含了初始的页面内容。浏览器接收到的是已经渲染好的\n      HTML 页面，因此初始加载的速度较快。\n 2. 内容生成和渲染：\n    * CSR：在 CSR 中，页面的内容生成和渲染是由客户端的 JavaScript 脚本负责的。当数据变化时，JavaScript 会重新生成并更新\n      DOM，从而实现内容的动态变化。这种方式使得前端开发更加灵活，可以创建复杂的交互和动画效果。\n    * SSR：在 SSR 中，服务器在渲染页面时会执行应用程序的代码，并生成最终的 HTML\n      页面。这意味着页面的初始内容是由服务器生成的，对于一些静态或少变的内容，可以提供更好的首次加载性能。\n 3. 用户交互和体验：\n    * CSR：在 CSR 中，一旦初始页面加载完成，后续的用户交互通常是通过 AJAX 或 WebSocket 与服务器进行数据交互，然后通过\n      JavaScript 更新页面内容。这种方式可以提供更快的页面切换和响应速度，但对于搜索引擎爬虫和\n      SEO（搜索引擎优化）来说，可能需要一些额外的处理。\n    * SSR：在 SSR\n      中，由于页面的初始内容是由服务器生成的，因此用户交互可以直接在服务器上执行，然后服务器返回更新后的页面。这样可以提供更好的首次加载性能和对搜索引擎友\n      好的内容。\n\n\nSEO#\n\nSEO （Search Engine Optimization）搜索引擎优化\n\nCSR 应用对 SEO 并不是很友好\n\n> 因为在首次加载的时候获取 HTML 信息较少 搜索引擎爬虫可能无法获取完整的页面内容\n\n如下的一个网页源代码 网址：https://iviewui.com/view-ui-plus/guide/introduce\n\n\n\n而 SSR 就不一样了 由于 SSR 在服务器端预先生成完整的 HTML\n页面，搜索引擎爬虫可以直接获取到完整的页面内容。这有助于搜索引擎正确理解和评估页面的内容\n\n下面是掘金，通过nuxt.js服务端渲染 网址：https://juejin.cn/\n\n\n\n说了这么多，哪些网站适合做 CSR，哪些适合做 SSR\n\nCSR 应用：ToB 型，例如后台管理系统、大屏可视化，都可以采用 CSR 渲染，不需要很高的 SEO 支持\n\nSSR 应用：内容密集型应用 ToC 型，例如 新闻网站、博客网站、电子商务、门户网站，需要 SEO 支持","routePath":"/guide/node/10-CSR  SSR  SEO","lang":"","toc":[{"text":"10-CSR SSR SEO","id":"10-csr-ssr-seo","depth":2,"charIndex":-1},{"text":"概述","id":"概述","depth":3,"charIndex":17},{"text":"简单案例","id":"简单案例","depth":4,"charIndex":149},{"text":"CSR SSR","id":"csr-ssr","depth":3,"charIndex":197},{"text":"SEO","id":"seo","depth":3,"charIndex":1148}],"domain":"","frontmatter":{},"version":""},{"id":44,"title":"","content":"11-Path Windows & posix#\n\n> path 模块在不同的操作系统是有差异的(windows | posix)\n\nwindows大家肯定熟悉，posix可能大家没听说过\n\nposix（Portable Operating System Interface of UNIX）\n\nposix表示可移植操作系统接口，也就是定义了一套标准\n\n遵守这套标准的操作系统有(unix、linux、macOs、windows wsl)\n\n为什么要定义这套标准？比如在 Linux 系统启动一个进程需要调用fork函数，在 Windows 启动一个进程需要调用creatprocess函数\n\n这样就有问题，比如我在 Linux 写好了代码，需要移植到 Windows 发现函数不统一，posix标准的出现就是为了解决这个问题\n\nWindows 并没有完全遵循 POSIX 标准，Windows 在设计上采用了不同于 POSIX 的路径表示方法\n\n> 在 Windows 系统中，路径使用反斜杠（\\）作为路径分隔符。这与 POSIX 系统使用的正斜杠（/）是不同的。这是 Windows\n> 系统的历史原因所致，早期的 Windows 操作系统采用了不同的设计选择。\n\n\nWindows posix 差异#\n\npath.basename() 方法返回的是给定路径中的最后一部分\n\n在 posix 处理 Windows 路径，会发现结果返回的并不对，应该返回 myfile.html\n\n\n\n如果要在posix系统处理 Windows 的路径，需要调用对应操作系统的方法，应该修改为\n\n\n\n这样就能返回 myfile.html\n\n\npath.dirname#\n\n这个 API 和basename正好互补\n\n\n\ndirname API 返回 /aaaa/bbbb/cccc 除了最后一个路径的前面路径。\n\nbasename API 返回 最后一个路径 index.html\n\n\npath.extname#\n\n这个 API 用来返回扩展名，例如/bbb/ccc/file.txt 返回就是.txt\n\n\n\n> 如果有多个 . 返回最后一个，如果没有扩展名，返回空\n\n\npath.join#\n\n这个 API 主要是用来拼接路径的\n\n\n\n> 可以支持 .. ./ ../操作符\n\n\n\n\npath.resolve#\n\n用于将相对路径解析并且返回绝对路径\n\n如果传入了多个绝对路径 它将返回最右边的绝对路径\n\n\n\n传入绝对路径 + 相对路径\n\n\n\n如果只传入相对路径\n\n\n\n\npath.parse 和 path.format#\n\npath.format 和 path.parse 正好互补\n\nparse用于解析文件路径\n\n它接受一个路径字符串作为输入，并返回一个包含路径各个组成部分的对象\n\n\n\n * root：路径的根目录，即 /\n * dir：文件所在的目录，即 /home/user/documents\n * base：文件名，即 file.txt\n * ext：文件扩展名，即 .txt\n * name：文件名去除扩展名，即 file\n\nformat 正好相反，把对象转回字符串\n\n\n\n\npath.sep#\n\n根据操作系统返回的值是不一样的\n\nWindows 返回是\\ posix 返回的是/\n\n","routePath":"/guide/node/11-Path Windows和posix","lang":"","toc":[{"text":"11-Path Windows & posix","id":"11-path-windows--posix","depth":2,"charIndex":-1},{"text":"Windows posix 差异","id":"windows-posix-差异","depth":3,"charIndex":535},{"text":"path.dirname","id":"pathdirname","depth":3,"charIndex":713},{"text":"path.extname","id":"pathextname","depth":3,"charIndex":835},{"text":"path.join","id":"pathjoin","depth":3,"charIndex":928},{"text":"path.resolve","id":"pathresolve","depth":3,"charIndex":985},{"text":"path.parse 和 path.format","id":"pathparse-和-pathformat","depth":3,"charIndex":1078},{"text":"path.sep","id":"pathsep","depth":3,"charIndex":1338}],"domain":"","frontmatter":{},"version":""},{"id":45,"title":"","content":"12-OS#\n\nNodejs os 模块可以跟操作系统进行交互\n\n\n\n\n常用的 API#\n\n序号   API             作用\n1    os.type()       它在 Linux 上返回 'Linux'，在 macOS 上返回 'Darwin'，在 Windows 上返回\n                     'Windows_NT'\n2    os.platform()   返回标识为其编译 Node.js 二进制文件的操作系统平台的字符串。 该值在编译时设置。 可能的值为\n                     'aix'、'darwin'、'freebsd'、'linux'、'openbsd'、'sunos'、以及\n                     'win32'等\n3    os.release()    返回操作系统的版本例如10.xxxx代表 win10\n4    os.homedir()    返回用户目录 例如c:\\user\\su，底层原理就是 windows 下的echo %USERPROFILE%\n                     ，posix 系统下的$HOME\n5    os.arch()       返回 cpu 的架构 可能的值为\n                     'arm'、'arm64'、'ia32'、'mips'、'mipsel'、'ppc'、'ppc64'、's390'、's\n                     390x'、以及 'x64'\n6    os.version()    返回版本，如Windows 10 Pro\n\n> windows 在 cmd 下输入echo %USERPROFILE%就会输出用户的目录\n\n\n获取 CPU 的线程以及详细信息#\n\n\n\n输出如下的信息\n\n\n\n * model: 表示 CPU 的型号信息，其中 \"Intel(R) Core(TM) i7 CPU 860 @ 2.80GHz\" 是一种具体的型号描述\n * speed: 表示 CPU 的时钟速度，以 MHz 或 GHz 为单位。在这种情况下，速度为 2926 MHz 或 2.926 GHz\n * times: 是一个包含 CPU 使用时间的对象，其中包含以下属性：\n   * user: 表示 CPU 被用户程序使用的时间（以毫秒为单位）\n   * nice: 表示 CPU 被优先级较低的用户程序使用的时间（以毫秒为单位）\n   * sys: 表示 CPU 被系统内核使用的时间（以毫秒为单位）\n   * idle: 表示 CPU 处于空闲状态的时间（以毫秒为单位）\n   * irq: 表示 CPU 被硬件中断处理程序使用的时间（以毫秒为单位）\n\n例如我的电脑是六核十二线程就会获取到 12 个线程\n\n\n\n\n获取网络信息#\n\n\n\n\n\n * address: 表示本地回环接口的 IP 地址，这里是 '127.0.0.1'\n * netmask: 表示本地回环接口的子网掩码，这里是 '255.0.0.0'\n * family: 表示地址族（address family），这里是 'IPv4'，表示 IPv4 地址\n * mac: 表示本地回环接口的 MAC 地址，这里是 '00:00:00:00:00:00'。请注意，本地回环接口通常不涉及硬件，因此 MAC\n   地址通常为全零\n * internal: 表示本地回环接口是否是内部接口，这里是 true，表示它是一个内部接口\n * cidr: 表示本地回环接口的 CIDR 表示法，即网络地址和子网掩码的组合，这里是 '127.0.0.1/8'，表示整个 127.0.0.0 网络\n\n\n案例#\n\n知道这些信息有什么用？\n\n非常经典的例子 webpack vite 大家应该都用过 他们有一个配置项可以打开浏览器 open:true 我们来简单复刻一下\n\n","routePath":"/guide/node/12-OS","lang":"","toc":[{"text":"12-OS","id":"12-os","depth":2,"charIndex":-1},{"text":"常用的 API","id":"常用的-api","depth":3,"charIndex":35},{"text":"获取 CPU 的线程以及详细信息","id":"获取-cpu-的线程以及详细信息","depth":3,"charIndex":768},{"text":"获取网络信息","id":"获取网络信息","depth":3,"charIndex":1210},{"text":"案例","id":"案例","depth":3,"charIndex":1578}],"domain":"","frontmatter":{},"version":""},{"id":46,"title":"","content":"13-process 进程#\n\nprocess 是 Nodejs 操作当前进程和控制当前进程的 API，并且是挂载到 globalThis 下面的全局 API\n\n\nAPI 介绍#\n\nprocess.arch#\n\nprocess.arch返回操作系统 CPU 架构 跟我们之前讲的os.arch 一样\n\n值：'arm'、'arm64'、'ia32'、'mips'、'mipsel'、'ppc'、'ppc64'、's390'、's390x'、以及 'x64'\n\nprocess.argv#\n\nprocess.argv获取执行进程后面的参数，返回是一个数组\n\n后面我们讲到命令行交互工具的时候会很有用，各种 cli 脚手架也是使用这种方式接受配置参数例如webpack\n\n\n\nprocess.cwd()#\n\nprocess.cwd()返回当前的工作目录\n\n> ESM 模式下，__dirname无法使用，这个是代替__dirname使用的\n\n例如在 F:\\project\\node> 执行的脚本就返回这个目录\n\n\n\nprocess.memoryUsage#\n\nprocess.memoryUsage用于获取当前进程的内存使用情况\n\n该方法返回一个对象，其中包含了各种内存使用指标，如 rss（Resident Set\nSize，常驻集大小）、heapTotal（堆区总大小）、heapUsed（已用堆大小）和 external（外部内存使用量）等\n\n\n\nprocess.exit()#\n\n调用 process.exit() 将强制进程退出，即使仍有未完全完成的异步操作挂起\n\n下面例子 5 不会被打印出来 因为在 2 秒钟的时候就被退出了\n\n\n\n它还可以监听对应的方法\n\n\n\nprocess.kill#\n\nprocess.kill与exit类似，kill用来杀死一个进程，接受一个参数进程 id 可以通过process.pid获取\n\n\n\nprocess.env#\n\nprocess.env用于读取操作系统所有的环境变量，也可以修改和查询环境变量\n\n> 注意：修改并不会真正影响操作系统的变量，而是只在当前线程生效，线程结束便释放\n\n\n\n\n环境变量场景#\n\n区分开发环境 和 生产环境\n\n\n\ncross-env能跨平台设置和使用环境变量，不论是在 Windows 系统还是 POSIX 系统。同时，它提供了一个设置环境变量的脚本，使得您可以在脚本中以\nunix 方式设置环境变量，然后在 Windows 上也能兼容运行\n\n如下，在 package 中设置cross-env NODE_ENV=dev\n\n\n\ncross-env原理:\n\n * 如果是 windows，就调用 SET 设置环境变量\n * 如果是 posix，就调用 export 设置环境变量\n\n","routePath":"/guide/node/13-process进程","lang":"","toc":[{"text":"13-process 进程","id":"13-process-进程","depth":2,"charIndex":-1},{"text":"API 介绍","id":"api-介绍","depth":3,"charIndex":81},{"text":"process.arch","id":"processarch","depth":4,"charIndex":90},{"text":"process.argv","id":"processargv","depth":4,"charIndex":228},{"text":"process.cwd()","id":"processcwd","depth":4,"charIndex":334},{"text":"process.memoryUsage","id":"processmemoryusage","depth":4,"charIndex":454},{"text":"process.exit()","id":"processexit","depth":4,"charIndex":623},{"text":"process.kill","id":"processkill","depth":4,"charIndex":734},{"text":"process.env","id":"processenv","depth":4,"charIndex":815},{"text":"环境变量场景","id":"环境变量场景","depth":3,"charIndex":915}],"domain":"","frontmatter":{},"version":""},{"id":47,"title":"","content":"14-child_process 子进程 核心 API#\n\n子进程是 Nodejs 核心 API，如果你会 shell 命令，他会有非常大的帮助，或者你喜欢编写前端工程化工具之类的，他也有很大的用处，以及处理 CPU\n密集型应用。\n\n\n创建子进程#\n\nNodejs 创建子进程共有7个API Sync 同步 API 不加是异步 API\n\n 1. exec 执行命令(异步执行)\n 2. execSync 执行命令(同步执行)\n 3. execFile 执行可执行文件(异步执行)\n 4. execFileSync 执行可执行文件(同步执行)\n 5. spawn 执行命令(异步执行)\n 6. spawnSync 执行命令(同步执行)\n 7. fork 创建 node 子进程\n\n\nAPI 示例#\n\nexec 方法#\n\nexec适合执行较小的 shell 命令，有字节上限：200kb\n\n\n\nexec获取 nodejs 版本号\n\n\n\noptions配置项\n\n 1. cwd 子进程的当前工作目录。\n 2. env 环境变量键值对。\n 3. encoding 默认为 'utf8'。\n 4. shell 用于执行命令的 shell。 在 UNIX 上默认为 '/bin/bash'，在 Windows 上默认为\n    process.env.ComSpec。 详见 Shell Requirements 与 Default Windows Shell。\n 5. timeout 默认为 0。\n 6. maxBuffer stdout 或 stderr 允许的最大字节数。 默认为 200*1024。 如果超过限制，则子进程会被终止。 查看警告：\n    maxBuffer and Unicode。\n 7. killSignal | 默认为 'SIGTERM'。\n 8. uid 设置该进程的用户标识。（详见 setuid(2)）\n 9. gid 设置该进程的组标识。（详见 setgid(2)）\n\nexecSync 方法#\n\n获取 node 版本号 如果要执行单次shell命令，execSync方便一些，options同上\n\n\n\n打开谷歌浏览器 使用 exec 可以打开一些软件例如 wx 谷歌 qq 音乐等 以下会打开百度并且进入无痕模式\n\n\n\nexecFile 方法#\n\nexecFile适合执行可执行文件，例如执行一个 node 脚本，或者 shell 文件\n\nwindows 可以编写 cmd 脚本，posix 可以编写 bash 脚本\n\n> 简单示例\n\n新建文件bat.cmd写入以下代码。\n\n创建一个文件夹 mkdir，进入目录，写入一个文件 test.js，最后执行。\n\n\n\n使用execFile执行这个\n\n\n\n\n\nspawn 方法(异步用的多)#\n\nspawn用于执行一些实时获取的信息，因为 spawn 返回的是流边执行边返回\n\nexec是返回一个完整的 buffer，buffer 的大小是200k，如果超出会报错，而spawn是无上限的。\n\n\n\n\n\n> exec -> execFile -> spawn\n> \n> exec 是底层通过 execFile 实现，execFile 底层通过 spawn 实现\n\nfork#\n\n场景适合大量的计算，或者容易阻塞主进程操作的一些代码，就适合开发 fork\n\n新建index.js文件，写入以下\n\n\n\n新建test.js文件，写入以下\n\n\n\n> send 发送信息 ，message 接收消息，可以相互发送接收。\n\nfork 底层使用的是 IPC 通道进行通讯的，IPC 基于 libuv 实现\n\n根据不同操作系统调用不同的 API\n\n","routePath":"/guide/node/14-child_process 子进程 核心API","lang":"","toc":[{"text":"14-child_process 子进程 核心 API","id":"14-child_process-子进程-核心-api","depth":2,"charIndex":-1},{"text":"创建子进程","id":"创建子进程","depth":3,"charIndex":117},{"text":"API 示例","id":"api-示例","depth":3,"charIndex":339},{"text":"exec 方法","id":"exec-方法","depth":4,"charIndex":348},{"text":"execSync 方法","id":"execsync-方法","depth":4,"charIndex":848},{"text":"execFile 方法","id":"execfile-方法","depth":4,"charIndex":974},{"text":"spawn 方法(异步用的多)","id":"spawn-方法异步用的多","depth":4,"charIndex":1165},{"text":"fork","id":"fork","depth":4,"charIndex":1366}],"domain":"","frontmatter":{},"version":""},{"id":48,"title":"","content":"15-FFmpeg#\n\nFFmpeg\n是一个开源的跨平台多媒体处理工具，可以用于处理音频、视频和多媒体流。它提供了一组强大的命令行工具和库，可以进行视频转码、视频剪辑、音频提取、音视频合并、流媒体传\n输等操作。\n\n\nFFmpeg 的主要功能和特性：#\n\n 1. 格式转换：FFmpeg 可以将一个媒体文件从一种格式转换为另一种格式，支持几乎所有常见的音频和视频格式，包括\n    MP4、AVI、MKV、MOV、FLV、MP3、AAC 等。\n 2. 视频处理：FFmpeg\n    可以进行视频编码、解码、裁剪、旋转、缩放、调整帧率、添加水印等操作。你可以使用它来调整视频的分辨率、剪辑和拼接视频片段，以及对视频进行各种效果处理。\n 3. 音频处理：FFmpeg\n    可以进行音频编码、解码、剪辑、混音、音量调节等操作。你可以用它来提取音频轨道、剪辑和拼接音频片段，以及对音频进行降噪、均衡器等处理。\n 4. 流媒体传输：FFmpeg 支持将音视频流实时传输到网络上，可以用于实时流媒体服务、直播和视频会议等应用场景。\n 5. 视频处理效率高：FFmpeg 是一个高效的工具，针对处理大型视频文件和高分辨率视频进行了优化，可以在保持良好质量的同时提供较快的处理速度。\n 6. 跨平台支持：FFmpeg 可以在多个操作系统上运行，包括 Windows、MacOS、Linux 等，同时支持多种硬件加速技术，如 NVIDIA\n    CUDA 和 Intel Quick Sync Video。\n\n\n安装 FFmpeg#\n\n官方网址，选择对应的操作系统下载即可，Windows 点击第一个，找到release builds下载 zip 包\n\n\n\n下载完成配置一下环境变量就 ok 了，输入 ffmpeg -version 不报错即可\n\n\n\n\n子进程配合 ffmpeg#\n\n常用的五个功能如下，更多的可以查看官网\n\n转换格式#\n\n简单的 demo 视频转 gif ，-i 表示输入的意思\n\n\n\n\n\n视频裁剪 + 控制大小**#\n\n-ss起始时间 -to结束事件\n\n> ss 写在 -i 的前面可能会导致精度问题，因为视频还没解析就跳转到了相关位置，但是解析速度快\n\n> ss 写在 -i 后面精度没问题，但是解析速度会变慢\n\n\n\n如下，该视频只有十秒被我们截取出来了\n\n1\n\n提取视频的音频#\n\n\n\n如下，音频已经被我们提取出来了\n\n\n\n添加水印#\n\n-vf 就是video filter\n\ndrawtext添加文字、fontsize大小、xy垂直水平方向、fontcolor颜色、text水印文案\n\n> 以上内容全部小写\n\n\n\n可以发现水印已经添加上了\n\n\n\n去掉水印#\n\nw h宽高，xy 垂直水平坐标，delogo使用的过滤参数删除水印\n\n宽高就是通过上面的水印大小，我们上面大小为 30，有两个字符，所以 w 为 60，h 即 30，x 和 y 与上面一致\n\n\n\n可以发现水印已经去除了\n\n","routePath":"/guide/node/15-FFmpeg","lang":"","toc":[{"text":"15-FFmpeg","id":"15-ffmpeg","depth":2,"charIndex":-1},{"text":"FFmpeg 的主要功能和特性：","id":"ffmpeg-的主要功能和特性","depth":3,"charIndex":107},{"text":"安装 FFmpeg","id":"安装-ffmpeg","depth":3,"charIndex":649},{"text":"子进程配合 ffmpeg","id":"子进程配合-ffmpeg","depth":3,"charIndex":770},{"text":"**转换格式**","id":"转换格式","depth":4,"charIndex":-1},{"text":"视频裁剪 + 控制大小**","id":"视频裁剪--控制大小","depth":4,"charIndex":847},{"text":"**提取视频的音频**","id":"提取视频的音频","depth":4,"charIndex":-1},{"text":"**添加水印**","id":"添加水印","depth":4,"charIndex":-1},{"text":"**去掉水印**","id":"去掉水印","depth":4,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":49,"title":"","content":"16-events 事件触发器#\n\n\nEventEmitter#\n\nNode.js 核心 API 都是采用异步事件驱动架构\n\n简单来说就是通过有效的方法来监听事件状态的变化，并在变化的时候做出相应的动作。\n\n\n\n举个例子，你去一家餐厅吃饭，这个餐厅就是一个调度中心，然后你去点饭，可以理解注册了一个事件emit,然后我们等候服务员的喊号，喊到我们的时候就去取餐，这就是监听\n了这个事件on\n\n\n事件模型#\n\nNodejs 事件模型采用了，发布订阅设计模式\n\n\n\n当一个发布者有新消息时，就将这个消息发布到调度中心。调度中心就会将这个消息通知给所有订阅者。这就实现了发布者和订阅者之间的解耦，发布者和订阅者不再直接依赖于彼此\n，他们可以独立地扩展自己\n\n\n代码案例#\n\n新建一个文件，输入如下代码，\n\n\n\n监听消息数量默认是 10 个，下面的代码超出了 10 个但只会输出 10 个\n\n\n\n如何解除限制？调用 setMaxListeners 传入数量\n\n\n\n只想监听一次，使用once监听，即使emit派发多次也只触发一次\n\n\n\n如何取消侦听？使用off\n\n\n\n\n使用地方#\n\n**process**的底层用到了events的模块\n\n\n\n打开 nodejs 源码，搜索 setupProcessObject 这个函数\n\n\n\n 1. 它首先引入event模块\n 2. 获取process的原型对象\n 3. 将evnet的原型对象设置给了process的原型对象并且重新绑定上下文\n 4. 将process挂载到globalThis，所以我们可以全局访问这个 API\n\n> 我们给fn的原型上添加了一个属性test，我们如何读到原型上的属性呢？如下\n> \n> 通过Object.getPrototypeOf()方法就可以访问，上面的源码就用到了\n\n\n\n> 我们如何把b原型上的属性嫁接到a原型呢？通过Object.setPrototypeOf()方法\n\n","routePath":"/guide/node/16-events 事件触发器","lang":"","toc":[{"text":"16-events 事件触发器","id":"16-events-事件触发器","depth":2,"charIndex":-1},{"text":"EventEmitter","id":"eventemitter","depth":3,"charIndex":18},{"text":"事件模型","id":"事件模型","depth":3,"charIndex":196},{"text":"代码案例","id":"代码案例","depth":3,"charIndex":326},{"text":"使用地方","id":"使用地方","depth":3,"charIndex":480}],"domain":"","frontmatter":{},"version":""},{"id":50,"title":"","content":"17-util#\n\nutil 是 Node.js 内部提供的很多实用或工具类型的 API，用来方便我们快速开发，下面介绍一些常用的 API\n\n\nutil.promisify#\n\nNode.js 大部分的 API 都是遵循回调函数的模式去编写的\n\n参考上面的第 14 章子进程其中的exec，如下，查看 node 版本\n\n\n\n这就是常规的写法\n\n我们使用util.promisify，可以将回调函数改为 Promise 风格，Promisfiy 接收original(一个函数体)，如下\n\n\n\npromisify 如何实现#\n\n * 第一步：promisify 是返回一个新的函数，因此如下\n\n\n\n * 第二步：promiseify 接收一个函数，并且需要在返回的函数中接收真正的参数，然后返回一个 Promise，如下\n\n\n\n * 调用真正的函数，将参数透传给original，如果失败就 reject，成功就返回 resolve，有多个的话返回一个对象\n\n\n\n这样我们可以大致实现该工具\n\n注意：该实现是拿不到 values 的 key 的，因为 Node.js 内部没有开放kCustomPromisifyArgsSymbol这个 Symbol\n给我们\n\n因此输出的结果是{ '0': 'v18.16.0\\n', '1': '' }\n\n而正常的结果应该是{ stdout: 'v18.16.0\\n', stderr: '' }\n\n\nutil.callbackify#\n\n这个和上面的 API 正好相反，是将 Promise 类型的 API 变为回调函数\n\n如下使用\n\n\n\n剖析 callbackify#\n\n如下，考虑到多个参数情况，回调函数肯定是在最后一个，通过 pop 方法将其取出\n\n\n\n\nutil.format#\n\n函数如下\n\n\n\n其中第一个 format 参数，语法和 C 语言基本一致，如下\n\n * %s:(String)将用于转换除 BigInt、Object 和 -0 之外的所有值\n\n> BigInt 值将用 n 表示，没有用户定义的 toString 函数的对象使用具有选项 { depth: 0, colors: false,\n> compact: 3 } 的 util.inspect() 进行检查。\n\n * %d:(Numer)将用于转换除 BigInt 和 Symbol 之外的所有值\n\n * %i:(parseInt(value, 10))用于除 BigInt 和 Symbol 之外的所有值\n\n * %f:(parseFloat(value))用于除 Symbol 之外的所有值\n\n * %j:(JSON) 如果参数包含循环引用，则替换为字符串 '[Circular]'\n\n * %o:(Object)具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于具有选项 { showHidden: true,\n   showProxy: true } 的 util.inspect()。 这将显示完整的对象，包括不可枚举的属性和代理\n\n * %O: (Object). 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于没有选项的 util.inspect()。\n   这将显示完整的对象，但不包括不可枚举的属性和代理\n\n * %c: (CSS). 此说明符被忽略，将跳过任何传入的 CSS\n\n * %%: 单个百分号 ('%')。 这不消费参数\n\n下面是例子，格式化一个字符串\n\n\n\n结果如下：\n\n\n\n如果不传入格式化的参数，就会按照空格分开\n\n\n\n结果如下：\n\n","routePath":"/guide/node/17-util","lang":"","toc":[{"text":"17-util","id":"17-util","depth":2,"charIndex":-1},{"text":"util.promisify","id":"utilpromisify","depth":3,"charIndex":71},{"text":"promisify 如何实现","id":"promisify-如何实现","depth":4,"charIndex":245},{"text":"util.callbackify","id":"utilcallbackify","depth":3,"charIndex":617},{"text":"剖析 callbackify","id":"剖析-callbackify","depth":4,"charIndex":687},{"text":"util.format","id":"utilformat","depth":3,"charIndex":748}],"domain":"","frontmatter":{},"version":""},{"id":51,"title":"","content":"18-pngquant#\n\n\n什么是 pngquant?#\n\npngquant 是一个用于压缩 PNG 图像文件的工具。它可以显著减小 PNG 文件的大小，同时保持图像质量和透明度。\n\n通过减小文件大小，可以提高网页加载速度，并节省存储空间。pngquant 提供命令行接口和库，可轻松集成到各种应用程序和脚本中。\n\n前往 pngquant 官网下载\n\n> 下载完配置一下环境变量，终端输入pngquant --version输出版本号即成功\n\n\n原理是什么#\n\npngquant 使用修改过的 Median Cut 量化算法以及其他技术来实现压缩 PNG 图像的目的。它的工作原理如下：\n\n 1. 首先，pngquant 构建一个直方图，用于统计图像中的颜色分布情况。\n 2. 接下来，它选择盒子来代表一组颜色。与传统的 Median Cut 算法不同，pngquant 选择的盒子是为了最小化盒子中颜色与中位数的差异。\n 3. pngquant 使用感知模型给予图像中噪声较大的区域较少的权重，以建立更准确的直方图。\n 4. 为了进一步改善颜色，pngquant 使用类似梯度下降的过程对直方图进行调整。它多次重复 Median Cut 算法，并在较少出现的颜色上增加权重。\n 5. 最后，为了生成最佳的调色板，pngquant 使用 Voronoi 迭代（K-means）对颜色进行校正，以确保局部最优。\n 6. 在重新映射颜色时，pngquant 只在多个相邻像素量化为相同颜色且不是边缘的区域应用误差扩散。这样可以避免在视觉质量较高且不需要抖动的区域添加噪声。\n\n通过这些步骤，pngquant 能够在保持图像质量的同时，将 PNG 图像的文件大小减小到最低限度。\n\n\nMedian Cut 量化算法#\n\n假设我们有一张 8x8 像素的彩色图像，每个像素由红色、绿色和蓝色通道组成，每个通道的值范围是 0 到 255。\n\n 1. 初始化：我们将图像中的每个像素视为一个颜色点，并将它们放入一个初始的颜色桶。\n\n 2. 选择划分桶：在初始的颜色桶中选择一个具有最大范围的颜色通道，假设我们选择红色通道。\n\n 3. 划分颜色：对于选定的红色通道，将颜色桶中的颜色按照红色通道的值进行排序，并找到中间位置的颜色值作为划分点。假设划分点的红色值为 120。\n    \n    划分前的颜色桶：\n    \n    * 颜色 1: (100, 50, 200)\n    * 颜色 2: (150, 30, 100)\n    * 颜色 3: (80, 120, 50)\n    * 颜色 4: (200, 180, 160)\n    \n    划分后的颜色桶：\n    \n    * 子桶 1:\n      \n      * 颜色 1: (100, 50, 200)\n      * 颜色 3: (80, 120, 50)\n    \n    * 子桶 2:\n      \n      * 颜色 2: (150, 30, 100)\n      * 颜色 4: (200, 180, 160)\n\n 4. 重复划分：我们继续选择颜色范围最大的通道，假设我们选择子桶 1 中的绿色通道。\n    \n    划分前的颜色桶（子桶 1）：\n    \n    * 颜色 1: (100, 50, 200)\n    * 颜色 3: (80, 120, 50)\n    \n    划分后的颜色桶（子桶 1）：\n    \n    * 子桶 1.1:\n      * 颜色 3: (80, 120, 50)\n    * 子桶 1.2:\n      * 颜色 1: (100, 50, 200)\n    \n    子桶 2 中只有两个颜色，不需要再进行划分。\n\n 5. 颜色映射：将原始图像中的每个像素颜色映射到最接近的颜色桶中的颜色。\n    \n    假设原始图像中的一个像素为 (110, 70, 180)，我们将它映射到颜色 1: (100, 50, 200)\n    \n    大概的公式为 sqrt((110-100)^2 + (70-50)^2 + (180-200)^2) ≈ 31.62\n    \n    通过 Median Cut 算法，我们将原始图像中的颜色数目从 64 个（8x8 像素）减少到 4 个颜色桶，从而实现了图像的量化\n\n\nNodejs 中调用 pngquant#\n\n同样可以使用exec命令来调用，73kb 的图片压缩完之后为 22kb\n\n\n\n--quality参数表示图片质量，值范围 0-100，值越大，图片体积越大，但图片质量越好\n\n\n\n * --speed=1：最慢的速度，产生最高质量的输出图像\n\n * --speed=10：最快的速度，但可能导致输出图像质量降低\n   \n   > 取值范围 1-10，值越小越慢，但质量高，值越大越快，但质量一般\n\n","routePath":"/guide/node/18-pngquant","lang":"","toc":[{"text":"18-pngquant","id":"18-pngquant","depth":2,"charIndex":-1},{"text":"什么是 pngquant?","id":"什么是-pngquant","depth":3,"charIndex":14},{"text":"原理是什么","id":"原理是什么","depth":3,"charIndex":223},{"text":"Median Cut 量化算法","id":"median-cut-量化算法","depth":3,"charIndex":739},{"text":"Nodejs 中调用 pngquant","id":"nodejs-中调用-pngquant","depth":3,"charIndex":1815}],"domain":"","frontmatter":{},"version":""},{"id":52,"title":"","content":"19-fs 上#\n\n\n概述#\n\n在 Node.js 中，fs 模块是文件系统模块（File System module）的缩写，它提供了与文件系统进行交互的各种功能。通过 fs\n模块，你可以执行诸如读取文件、写入文件、更改文件权限、创建目录等操作，fs模块是Node.js 核心API之一。\n\n\nfs 多种策略#\n\n如下代码\n\n\n\n 1. fs 支持同步和异步两种模式 ，增加了Sync fs 就会采用同步的方式运行代码，会阻塞下面的代码，不加 Sync 就是异步的模式不会阻塞。\n\n 2. fs 新增了 promise 版本，只需要在引入包后面增加/promises 即可，fs 便可支持 promise 回调。\n\n 3. fs 返回的是一个 buffer 二进制数据 每两个十六进制数字表示一个字节\n\nbuffer 如下:\n\n\n\n\n常用 API 介绍#\n\n读取文件 readFile#\n\n第一个参数 读取的路径， 第二个参数是个配置项\n\n配置项第一个是 encoding，支持各种编码 utf-8 之类的\n\n配置项第二个是 flag，它的配置就很多了，如下\n\n * 'a': 打开文件进行追加。 如果文件不存在，则创建该文件。\n\n * 'ax': 类似于 'a' 但如果路径存在则失败。\n\n * 'a+': 打开文件进行读取和追加。 如果文件不存在，则创建该文件。\n\n * 'ax+': 类似于 'a+' 但如果路径存在则失败。\n\n * 'as': 以同步模式打开文件进行追加。 如果文件不存在，则创建该文件。\n\n * 'as+': 以同步模式打开文件进行读取和追加。 如果文件不存在，则创建该文件。\n\n * 'r': 打开文件进行读取。 如果文件不存在，则会发生异常。\n\n * 'r+': 打开文件进行读写。 如果文件不存在，则会发生异常。\n\n * 'rs+': 以同步模式打开文件进行读写。 指示操作系统绕过本地文件系统缓存。\n   \n   这主要用于在 NFS 挂载上打开文件，因为它允许跳过可能过时的本地缓存。 它对 I/O 性能有非常实际的影响，因此除非需要，否则不建议使用此标志。\n   \n   这不会将 fs.open() 或 fsPromises.open() 变成同步阻塞调用。 如果需要同步操作，应该使用类似 fs.openSync()\n   的东西。\n\n * 'w': 打开文件进行写入。 创建（如果它不存在）或截断（如果它存在）该文件。\n\n * 'wx': 类似于 'w' 但如果路径存在则失败。\n\n * 'w+': 打开文件进行读写。 创建（如果它不存在）或截断（如果它存在）该文件。\n\n * 'wx+': 类似于 'w+' 但如果路径存在则失败。\n\n示例代码：\n\n\n\n使用可读流读取#\n\n使用场景:适合读取大文件\n\n\n\n创建文件夹#\n\n如果开启 recursive 可以递归创建多个文件夹\n\n\n\n删除文件夹#\n\n如果开启 recursive 递归删除全部文件夹\n\n\n\n重命名文件#\n\n第一个参数原始名称 第二个参数新的名称\n\n\n\n监听文件的变化#\n\n返回监听的事件如change,和监听的内容filename\n\n\n\n\n源码解析#\n\ngithub 源码地址\n\n目录：src/unix/fs.c\n\nfs 的源码是通过 C++ 层的 FSReqCallback 这个类 对libuv 的uv_fs_t 的一个封装，其实也就是将我们 fs 的参数透传给\nlibuv 层\n\n\n\nmkdir 举例\n\n\n\n\n注意事项#\n\n\n\n为什么先走 setImmediate 呢，而不是 fs 呢?\n\nNode.js 读取文件的时候是使用 libuv 进行调度的，而 setImmediate 是由 V8 进行调度的\n\n文件读取完成后 libuv 才会将 fs 的结果 推入 V8 的队列","routePath":"/guide/node/19-fs(上)","lang":"","toc":[{"text":"19-fs 上","id":"19-fs-上","depth":2,"charIndex":-1},{"text":"概述","id":"概述","depth":3,"charIndex":10},{"text":"fs 多种策略","id":"fs-多种策略","depth":3,"charIndex":147},{"text":"常用 API 介绍","id":"常用-api-介绍","depth":3,"charIndex":367},{"text":"读取文件 `readFile`","id":"读取文件-readfile","depth":4,"charIndex":-1},{"text":"使用可读流读取","id":"使用可读流读取","depth":4,"charIndex":1149},{"text":"创建文件夹","id":"创建文件夹","depth":4,"charIndex":1175},{"text":"删除文件夹","id":"删除文件夹","depth":4,"charIndex":1213},{"text":"重命名文件","id":"重命名文件","depth":4,"charIndex":1249},{"text":"监听文件的变化","id":"监听文件的变化","depth":4,"charIndex":1280},{"text":"源码解析","id":"源码解析","depth":3,"charIndex":1324},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":1462}],"domain":"","frontmatter":{},"version":""},{"id":53,"title":"","content":"2-npm 和 package.json#\n\n\nnpm#\n\nnpm（全称 Node Package Manager）是 Node.js\n的包管理工具，它是一个基于命令行的工具，用于帮助开发者在自己的项目中安装、升级、移除和管理依赖项。\n\n> 官网地址\n\n * 类似于 PHP 的工具：Composer。它是 PHP 的包管理器，可以用于下载、安装和管理 PHP 的依赖项，类似于 npm。\n * 类似于 Java 的工具：Maven。它是 Java 的构建工具和项目管理工具，可以自动化构建、测试和部署 Java 应用程序，类似于 npm 和\n   webpack 的功能。\n * 类似于 Python 的工具：pip。它是 Python 的包管理器，可以用于安装和管理 Python 的依赖项，类似于 npm。\n * 类似于 Rust 的工具：Cargo。它是 Rust 的包管理器和构建工具，可以用于下载、编译和管理 Rust 的依赖项，类似于 npm 和 Maven\n   的功能。\n\n\nnpm 命令#\n\n 1.  npm init：初始化一个新的 npm 项目，创建 package.json 文件。\n\n 2.  npm install：安装一个包或一组包，并且会在当前目录存放一个 node_modules。\n     \n     > npm install 安装模块的时候一般是扁平化安装的，但是有时候出现嵌套的情况是因为版本不同\n     > \n     > A 依赖 C 1.0 B 依赖 C 1.0 D 依赖 C 2.0,\n     > \n     > 此时 C 1.0 就会被放到 A B 的 node_moduels, C 2.0 会被放入 D 模块下面的 node_moduels\n\n 3.  npm install ：安装指定的包。\n     \n     > 简写 npm i，通过在包后@版本号来安装指定版本\n\n 4.  npm install --save：安装指定的包，并将其添加到 package.json 文件中的依赖列表中。(如Vue，是生产环境所需要的依赖)\n\n 5.  npm install --save-dev：安装指定的包，并将其添加到 package.json\n     文件中的开发依赖列表中。(如webpack，是开发环境所需要的依赖)\n\n 6.  npm install -g ：全局安装指定的包。\n\n 7.  npm update ：更新指定的包。\n\n 8.  npm uninstall ：卸载指定的包。\n\n 9.  npm run ：执行 package.json 文件中定义的脚本命令。\n\n 10. npm search ：搜索 npm 库中包含指定关键字的包。\n\n 11. npm info ：查看指定包的详细信息。\n\n 12. npm list：列出当前项目中安装的所有包。\n\n 13. npm outdated：列出当前项目中需要更新的包。\n\n 14. npm audit：检查当前项目中的依赖项是否存在安全漏洞。\n\n 15. npm publish：发布自己开发的包到 npm 库中。\n\n 16. npm login：登录到 npm 账户。\n\n 17. npm logout：注销当前 npm 账户。\n\n 18. npm link: 将本地模块链接到全局的 node_modules 目录下\n\n 19. **npm config list **用于列出所有的 npm 配置信息。执行该命令可以查看当前系统和用户级别的所有 npm\n     配置信息，以及当前项目的配置信息（如果在项目目录下执行该命令）\n\n 20. npm get registry 用于获取当前 npm 配置中的 registry 配置项的值。registry 配置项用于指定 npm\n     包的下载地址，如果未指定，则默认使用 npm 官方的包注册表地址\n\n 21. **npm set registry npm config set registry **命令，将 registry 配置项的值修改为指定的 地址\n\n\nPackage json#\n\n执行npm init便可以初始化一个package.json文件\n\n 1.  name：项目名称，必须是唯一的字符串，通常采用小写字母和连字符的组合。\n\n 2.  version：项目版本号，通常采用语义化版本号规范。\n     \n     > version 是三段式版本号一般是 1.0.0 大版本号、次版本号 、修订号\n     > \n     >  * 大版本号一般是有重大变化才会升级\n     >  * 次版本号一般是增加功能进行升级\n     >  * 修订号一般是修改 bug 进行升级\n\n 3.  description：项目描述。\n\n 4.  main：项目的主入口文件路径，通常是一个 JavaScript 文件。\n\n 5.  keywords：项目的关键字列表，方便他人搜索和发现该项目。\n\n 6.  author：项目作者的信息，包括姓名、邮箱、网址等。\n\n 7.  license：项目的许可证类型，可以是自定义的许可证类型或者常见的开源许可证（如 MIT、Apache 等）。\n\n 8.  dependencies：项目所依赖的包的列表，这些包会在项目运行时自动安装。\n\n 9.  devDependencies：项目开发过程中所需要的包的列表，这些包不会随项目一起发布，而是只在开发时使用。\n\n 10. peerDependencies：项目的同级依赖，即项目所需要的模块被其他模块所依赖。\n     \n     > 一般是给编写插件的人员使用的，如在devDependencies有一个自己的插件vite-plugin-chen，但它不能凭空运行，需要依赖vit\n     > e环境，这时就需要添加\"vite\":\"^2.0.0\"\n\n 11. scripts：定义了一些脚本命令，比如启动项目、运行测试等。\n\n 12. repository：项目代码仓库的信息，包括类型、网址等。\n\n 13. bugs：项目的 bug 报告地址。\n\n 14. homepage：项目的官方网站地址或者文档地址。","routePath":"/guide/node/2-npm和package.json","lang":"","toc":[{"text":"2-npm 和 package.json","id":"2-npm-和-packagejson","depth":2,"charIndex":-1},{"text":"npm","id":"npm","depth":3,"charIndex":23},{"text":"npm 命令","id":"npm-命令","depth":3,"charIndex":446},{"text":"Package json","id":"package-json","depth":3,"charIndex":1732}],"domain":"","frontmatter":{},"version":""},{"id":54,"title":"","content":"20-fs 下#\n\n\n概述#\n\n在 Node.js 中，fs 模块是文件系统模块（File System module）的缩写，它提供了与文件系统进行交互的各种功能。通过 fs\n模块，你可以执行诸如读取文件、写入文件、更改文件权限、创建目录等操作，Node.js 核心API之一。\n\n\nAPI#\n\n写入内容#\n\n\n\n 1. 第一个参数写入的文件\n\n 2. 第二个参数写入的内容\n\n 3. 第三个是 options 可选项 encoding 编码 mode 权限 flag 如下\n    \n    * 'a': 打开文件进行追加。 如果文件不存在，则创建该文件。\n    \n    * 'ax': 类似于 'a' 但如果路径存在则失败。\n    \n    * 'a+': 打开文件进行读取和追加。 如果文件不存在，则创建该文件。\n    \n    * 'ax+': 类似于 'a+' 但如果路径存在则失败。\n    \n    * 'as': 以同步模式打开文件进行追加。 如果文件不存在，则创建该文件。\n    \n    * 'as+': 以同步模式打开文件进行读取和追加。 如果文件不存在，则创建该文件。\n    \n    * 'r': 打开文件进行读取。 如果文件不存在，则会发生异常。\n    \n    * 'r+': 打开文件进行读写。 如果文件不存在，则会发生异常。\n    \n    * 'rs+': 以同步模式打开文件进行读写。 指示操作系统绕过本地文件系统缓存。\n      \n      > 这主要用于在 NFS 挂载上打开文件，因为它允许跳过可能过时的本地缓存。 它对 I/O\n      > 性能有非常实际的影响，因此除非需要，否则不建议使用此标志。\n      > \n      > 这不会将 fs.open() 或 fsPromises.open() 变成同步阻塞调用。 如果需要同步操作，应该使用类似\n      > \n      > fs.openSync() 的东西。\n    \n    * 'w': 打开文件进行写入。 创建（如果它不存在）或截断（如果它存在）该文件。\n    \n    * 'wx': 类似于 'w' 但如果路径存在则失败。\n    \n    * 'w+': 打开文件进行读写。 创建（如果它不存在）或截断（如果它存在）该文件。\n    \n    * 'wx+': 类似于 'w+' 但如果路径存在则失败。\n\n追加内容#\n\n第一种方式 设置 flag 为 a 可以追加\n\n\n\n查看内容\n\n\n\n第二种方式\n\n\n\n使用appendFileSync也可以追加内容\n\n\n可写流#\n\n\n\n我们可以创建一个可写流 打开一个通道，可以一直写入数据，用于处理大量的数据写入，写入完成之后调用 end 关闭可写流，监听 finish 事件 写入完成\n\n\n硬链接 和 软连接#\n\n\n\n硬链接的作用和用途如下：\n\n 1. 文件共享：硬链接允许多个文件名指向同一个文件，这样可以在不同的位置使用不同的文件名引用相同的内容。这样的共享文件可以节省存储空间，并且在多个位置对文件的\n    修改会反映在所有引用文件上。\n 2. 文件备份：通过创建硬链接，可以在不复制文件的情况下创建文件的备份。如果原始文件发生更改，备份文件也会自动更新。这样可以节省磁盘空间，并确保备份文件与原始\n    文件保持同步。\n 3. 文件重命名：通过创建硬链接，可以为文件创建一个新的文件名，而无需复制或移动文件。这对于需要更改文件名但保持相同内容和属性的场景非常有用。\n\n软链接的一些特点和用途如下：\n\n 1. 软链接可以创建指向文件或目录的引用。这使得你可以在不复制或移动文件的情况下引用它们，并在不同位置使用不同的文件名访问相同的内容。\n 2. 软链接可以用于创建快捷方式或别名，使得你可以通过一个简短或易记的路径来访问复杂或深层次的目录结构。\n 3. 软链接可以用于解决文件或目录的位置变化问题。如果目标文件或目录被移动或重命名，只需更新软链接的目标路径即可，而不需要修改引用该文件或目录的其他代码。","routePath":"/guide/node/20-fs(下)","lang":"","toc":[{"text":"20-fs 下","id":"20-fs-下","depth":2,"charIndex":-1},{"text":"概述","id":"概述","depth":3,"charIndex":10},{"text":"API","id":"api","depth":3,"charIndex":142},{"text":"写入内容","id":"写入内容","depth":4,"charIndex":148},{"text":"追加内容","id":"追加内容","depth":4,"charIndex":1029},{"text":"可写流","id":"可写流","depth":3,"charIndex":1105},{"text":"硬链接 和 软连接","id":"硬链接-和-软连接","depth":3,"charIndex":1192}],"domain":"","frontmatter":{},"version":""},{"id":55,"title":"","content":"21-crypto#\n\ncrypto 模块的目的是为了提供通用的加密和哈希算法。用纯 JavaScript 代码实现这些功能不是不可能，但速度会非常慢。nodejs 用\nC/C++实现这些算法后，通过 crypto 这个模块暴露为 JavaScript 接口，这样用起来方便，运行速度也快。\n\n密码学是计算机科学中的一个重要领域，它涉及到加密、解密、哈希函数和数字签名等技术。Node.js 是一个流行的服务器端 JavaScript\n运行环境，它提供了强大的密码学模块，使开发人员能够轻松地在其应用程序中实现各种密码学功能。本文将介绍密码学的基本概念，并探讨 Node.js 中常用的密码学\nAPI。\n\n\n对称加密#\n\n对称加密是一种简单而快速的加密方式，它使用相同的密钥（称为对称密钥）来进行加密和解密。这意味着发送者和接收者在加密和解密过程中都使用相同的密钥。对称加密算法的加\n密速度很快，适合对大量数据进行加密和解密操作。然而，对称密钥的安全性是一个挑战，因为需要确保发送者和接收者都安全地共享密钥，否则有风险被未授权的人获取密钥并解密\n数据，crypto 使用对称加密如下\n\n\n\n\n非对称加密#\n\n非对称加密使用一对密钥，分别是公钥和私钥。发送者使用接收者的公钥进行加密，而接收者使用自己的私钥进行解密。公钥可以自由分享给任何人，而私钥必须保密。非对称加密算\n法提供了更高的安全性，因为即使公钥泄露，只有持有私钥的接收者才能解密数据。然而，非对称加密算法的加密速度相对较慢，不适合加密大量数据。因此，在实际应用中，通常使\n用非对称加密来交换对称密钥，然后使用对称加密算法来加密实际的数据。\n\n\n\n\n哈希函数#\n\n哈希函数具有以下特点：\n\n 1. 固定长度输出：不论输入数据的大小，哈希函数的输出长度是固定的。例如，常见的哈希函数如 MD5 和 SHA-256 生成的哈希值长度分别为 128 位和\n    256 位。\n 2. 不可逆性：哈希函数是单向的，意味着从哈希值推导出原始输入数据是非常困难的，几乎不可能。即使输入数据发生微小的变化，其哈希值也会完全不同。\n 3. 唯一性：哈希函数应该具有较低的碰撞概率，即不同的输入数据生成相同的哈希值的可能性应该非常小。这有助于确保哈希值能够唯一地标识输入数据。\n\n使用场景:\n\n 1. 我们可以避免密码明文传输 使用 md5 加密或者 sha256\n\n 2. 验证文件完整性，读取文件内容生成 md5 如果前端上传的 md5 和后端的读取文件内部的 md5 匹配说明文件是完整的\n\n","routePath":"/guide/node/21-crypto","lang":"","toc":[{"text":"21-crypto","id":"21-crypto","depth":2,"charIndex":-1},{"text":"对称加密","id":"对称加密","depth":3,"charIndex":303},{"text":"非对称加密","id":"非对称加密","depth":3,"charIndex":495},{"text":"哈希函数","id":"哈希函数","depth":3,"charIndex":703}],"domain":"","frontmatter":{},"version":""},{"id":56,"title":"","content":"22-脚手架#\n\n\n编写自己的脚手架#\n\n什么是脚手架呢？如vue-cli、Create React App、Angular CLI，这一系列帮我们创建模板的工具\n\n编写自己的脚手架是指创建一个定制化的工具，用于快速生成项目的基础结构和代码文件，以及提供一些常用的命令和功能。通过编写自己的脚手架，可以定义项目的目录结构、文件\n模板，管理项目的依赖项，生成代码片段，以及提供命令行接口等功能\n\n * 项目结构：脚手架定义了项目的目录结构，包括源代码、配置文件、静态资源等。\n\n * 文件模板：脚手架提供了一些预定义的文件模板，如 HTML 模板、样式表、配置文件等，以加快开发者创建新文件的速度。\n\n * 命令行接口：脚手架通常提供一个命令行接口，通过输入命令和参数，开发者可以执行各种任务，如创建新项目、生成代码文件、运行测试等。\n\n * 依赖管理：脚手架可以帮助开发者管理项目的依赖项，自动安装和配置所需的库和工具。\n\n * 代码生成：脚手架可以生成常见的代码结构，如组件、模块、路由等，以提高开发效率。\n\n * 配置管理：脚手架可以提供一些默认的配置选项，并允许开发者根据需要进行自定义配置\n\n\n\n\n工具介绍#\n\n我们来学习一下所需要用到的第三方库，通过npm init生成初始的 package，然后npm i下载下面的库\n\n * commander\n\n> Commander 是一个用于构建命令行工具的 npm 库。它提供了一种简单而直观的方式来创建命令行接口，并处理命令行参数和选项。使用\n> Commander，你可以轻松定义命令、子命令、选项和帮助信息。它还可以处理命令行的交互，使用户能够与你的命令行工具进行交互\n\n * inquirer\n\n> Inquirer\n> 是一个强大的命令行交互工具，用于与用户进行交互和收集信息。它提供了各种丰富的交互式提示（如输入框、选择列表、确认框等），可以帮助你构建灵活的命令行界面。通过\n> Inquirer，你可以向用户提出问题，获取用户的输入，并根据用户的回答采取相应的操作。\n\n * ora\n\n> Ora 是一个用于在命令行界面显示加载动画的 npm 库。它可以帮助你在执行耗时的任务时提供一个友好的加载状态提示。Ora\n> 提供了一系列自定义的加载动画，如旋转器、进度条等，你可以根据需要选择合适的加载动画效果，并在任务执行期间显示对应的加载状态。\n\n * download-git-repo\n\n> Download-git-repo 是一个用于下载 Git 仓库的 npm 库。它提供了一个简单的接口，可以方便地从远程 Git\n> 仓库中下载项目代码。你可以指定要下载的仓库和目标目录，并可选择指定分支或标签。Download-git-repo 支持从各种 Git 托管平台（如\n> GitHub、GitLab、Bitbucket 等）下载代码。\n\n\n编写代码#\n\nindex.js#\n\n第一行要写 #!/usr/bin/env node\n\n这是一个 特殊的注释 用于告诉操作系统用 node 解释器去执行这个文件，而不是显式地调用 node 命令\n\n\n\nutils.js#\n\n\n\npackage.json#\n\n加入如下的配置\n\n\n\n配置完成之后 需要执行npm link，用于生成软连接挂载到全局，便可以全局执行 vue-cli 这个命令\n\n\n\n然后执行命令：\n\n\n\n生成如下：","routePath":"/guide/node/22-脚手架","lang":"","toc":[{"text":"22-脚手架","id":"22-脚手架","depth":2,"charIndex":-1},{"text":"编写自己的脚手架","id":"编写自己的脚手架","depth":3,"charIndex":9},{"text":"工具介绍","id":"工具介绍","depth":3,"charIndex":502},{"text":"编写代码","id":"编写代码","depth":3,"charIndex":1208},{"text":"index.js","id":"indexjs","depth":4,"charIndex":1215},{"text":"utils.js","id":"utilsjs","depth":4,"charIndex":1310},{"text":"package.json","id":"packagejson","depth":4,"charIndex":1323}],"domain":"","frontmatter":{},"version":""},{"id":57,"title":"","content":"<%- content %>","routePath":"/guide/node/23-Markdown 转 html","lang":"","toc":[{"text":"23-Markdown 转 html","id":"23-markdown-转-html","depth":2,"charIndex":-1},{"text":"所用库","id":"所用库","depth":3,"charIndex":-1},{"text":"EJS 语法","id":"ejs-语法","depth":3,"charIndex":-1},{"text":"1. 纯脚本语言","id":"1-纯脚本语言","depth":4,"charIndex":-1},{"text":"2. 输出经过 HTML 转义的内容","id":"2-输出经过-html-转义的内容","depth":4,"charIndex":-1},{"text":"3. 输出非转义的内容(原始内容)","id":"3-输出非转义的内容原始内容","depth":4,"charIndex":-1},{"text":"4. 引入其他模版","id":"4-引入其他模版","depth":4,"charIndex":-1},{"text":"5. 条件判断","id":"5-条件判断","depth":4,"charIndex":-1},{"text":"6. 循环","id":"6-循环","depth":4,"charIndex":-1},{"text":"编写","id":"编写","depth":3,"charIndex":-1},{"text":"template.ejs","id":"templateejs","depth":4,"charIndex":-1},{"text":"marked","id":"marked","depth":4,"charIndex":-1},{"text":"browserSync","id":"browsersync","depth":4,"charIndex":-1},{"text":"index.css","id":"indexcss","depth":4,"charIndex":-1},{"text":"完整代码","id":"完整代码","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":58,"title":"","content":"24-zlib#\n\n在 Node.js 中，zlib 模块提供了对数据压缩和解压缩的功能，以便在应用程序中减少数据的传输大小和提高性能。该模块支持多种压缩算法，包括\nDeflate、Gzip 和 Raw Deflate。\n\nzlib 模块的主要作用如下：\n\n 1. 数据压缩：使用 zlib 模块可以将数据以无损压缩算法（如\n    Deflate、Gzip）进行压缩，减少数据的大小。这在网络传输和磁盘存储中特别有用，可以节省带宽和存储空间。\n 2. 数据解压缩：zlib 模块还提供了对压缩数据的解压缩功能，可以还原压缩前的原始数据。\n 3. 流压缩：zlib\n    模块支持使用流（Stream）的方式进行数据的压缩和解压缩。这种方式使得可以对大型文件或网络数据流进行逐步处理，而不需要将整个数据加载到内存中。\n 4. 压缩格式支持：zlib 模块支持多种常见的压缩格式，如 Gzip 和 Deflate。这些格式在各种应用场景中广泛使用，例如 HTTP\n    响应的内容编码、文件压缩和解压缩等。\n\n使用 zlib\n模块进行数据压缩和解压缩可以帮助优化应用程序的性能和资源利用。通过减小数据的大小，可以减少网络传输的时间和带宽消耗，同时减少磁盘上的存储空间。此外，zlib\n模块还提供了丰富的选项和方法，使得开发者可以根据具体需求进行灵活的压缩和解压缩操作。\n\n\n代码案例#\n\n压缩一个 txt 文件gzip 原大小index.txt(439kb) 压缩完index.txt.gz(4b)\n\n\n\n解压 gzip\n\n\n\n无损压缩 deflate 使用 createDeflate 方法\n\n\n\n解压 deflate\n\n\n\n\ngzip 和 deflate 区别#\n\n 1. 压缩算法：Gzip 使用的是 Deflate 压缩算法，该算法结合了 LZ77 算法和哈夫曼编码。LZ77\n    算法用于数据的重复字符串的替换和引用，而哈夫曼编码用于进一步压缩数据。\n 2. 压缩效率：Gzip\n    压缩通常具有更高的压缩率，因为它使用了哈夫曼编码来进一步压缩数据。哈夫曼编码根据字符的出现频率，将较常见的字符用较短的编码表示，从而减小数据的大小。\n 3. 压缩速度：相比于仅使用 Deflate 的方式，Gzip\n    压缩需要更多的计算和处理时间，因为它还要进行哈夫曼编码的步骤。因此，在压缩速度方面，Deflate 可能比 Gzip 更快。\n 4. 应用场景：Gzip 压缩常用于文件压缩、网络传输和 HTTP 响应的内容编码。它广泛应用于 Web\n    服务器和浏览器之间的数据传输，以减小文件大小和提高网络传输效率。\n\n\nhttp 请求压缩#\n\ndeflate 压缩前(8.2kb) -> 压缩后(236b)\n\n\n\ngizp 压缩前(8.2kb) ->压缩后(245b)\n\n","routePath":"/guide/node/24-zlib","lang":"","toc":[{"text":"24-zlib","id":"24-zlib","depth":2,"charIndex":-1},{"text":"代码案例","id":"代码案例","depth":3,"charIndex":587},{"text":"gzip 和 deflate 区别","id":"gzip-和-deflate-区别","depth":3,"charIndex":715},{"text":"http 请求压缩","id":"http-请求压缩","depth":3,"charIndex":1119}],"domain":"","frontmatter":{},"version":""},{"id":59,"title":"","content":"25-http#\n\nhttp 模块是 Node.js 中用于创建和处理 HTTP 服务器和客户端的核心模块。它使得构建基于 HTTP 协议的应用程序变得更加简单和灵活。\n\n 1. 创建 Web 服务器：你可以使用 http 模块创建一个 HTTP 服务器，用于提供 Web\n    应用程序或网站。通过监听特定的端口，服务器可以接收客户端的请求，并生成响应。你可以处理不同的路由、请求方法和参数，实现自定义的业务逻辑。\n 2. 构建 RESTful API：http 模块使得构建 RESTful API 变得简单。你可以使用 HTTP 请求方法（如\n    GET、POST、PUT、DELETE 等）和路径来定义 API 的不同端点。通过解析请求参数、验证身份和权限，以及生成相应的 JSON\n    或其他数据格式，你可以构建强大的 API 服务。\n 3. 代理服务器：http\n    模块还可以用于创建代理服务器，用于转发客户端的请求到其他服务器。代理服务器可以用于负载均衡、缓存、安全过滤或跨域请求等场景。通过在代理服务器上添加逻辑，\n    你可以对请求和响应进行修改、记录或过滤。\n 4. 文件服务器：http 模块可以用于创建一个简单的文件服务器，用于提供静态文件（如\n    HTML、CSS、JavaScript、图像等）。通过读取文件并将其作为响应发送给客户端，你可以轻松地构建一个基本的文件服务器。\n\n\n创建 http 服务器#\n\n\n\n前端中最常用的请求就是 GET 和 POST，那么 nodejs 如何区分这两个请求呢\n\n\n\n一个完整的代码\n\n\n\n\n如何调试#\n\nVSCode 有一个非常方便的插件，如下\n\n\n\n安装完成之后编写简易的代码就可以直接发送请求了，编写具体如下\n\n[POST | GET | PUT] [URL] [http 版本]\n\n[请求头]\n\n[传递的数据]\n\n\n\n在运行 http 后，在 http 文件中右键，然后点击 send request 即可发送\n\n\n\n我们在上面打印的是 a 的值，所以控制台输出了 1\n\n","routePath":"/guide/node/25-http","lang":"","toc":[{"text":"25-http","id":"25-http","depth":2,"charIndex":-1},{"text":"创建 http 服务器","id":"创建-http-服务器","depth":3,"charIndex":614},{"text":"如何调试","id":"如何调试","depth":3,"charIndex":689}],"domain":"","frontmatter":{},"version":""},{"id":60,"title":"","content":"","routePath":"/guide/node/26-反向代理","lang":"","toc":[{"text":"26-反向代理","id":"26-反向代理","depth":2,"charIndex":-1},{"text":"什么是反向代理?","id":"什么是反向代理","depth":3,"charIndex":-1},{"text":"代码实现","id":"代码实现","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":61,"title":"","content":"27-动静分离#\n\n\n什么是动静分离？#\n\n动静分离是一种在Web服务器架构中常用的优化技术，旨在提高网站的性能和可伸缩性。它基于一个简单的原则：将动态生成的内容（如动态网页、API请求）与静态资源（如H\nTML、CSS、JavaScript、图像文件）分开处理和分发。\n\n通过将动态内容和静态资源存储在不同的服务器或服务上，并使用不同的处理机制，可以提高网站的处理效率和响应速度。这种分离的好处包括：\n\n 1. 性能优化：将静态资源与动态内容分离可以提高网站的加载速度。由于静态资源往往是不变的，可以使用缓存机制将其存储在CDN（内容分发网络）或浏览器缓存中，从而\n    减少网络请求和数据传输的开销。\n 2. 负载均衡：通过将动态请求分发到不同的服务器或服务上，可以平衡服务器的负载，提高整个系统的可伸缩性和容错性。\n 3. 安全性：将动态请求与静态资源分开处理可以提高系统的安全性。静态资源通常是公开可访问的，而动态请求可能涉及敏感数据或需要特定的身份验证和授权。通过将静态资\n    源与动态内容分离，可以更好地管理访问控制和安全策略。\n\n实现动静分离的方法\n\n * 使用反向代理服务器（如Nginx、Apache）将静态请求和动态请求转发到不同的后端服务器或服务。\n * 将静态资源部署到CDN上，通过CDN分发静态资源，减轻源服务器的负载。\n * 使用专门的静态文件服务器（如Amazon S3、Google Cloud Storage）存储和提供静态资源，而将动态请求交给应用服务器处理。\n\n\n代码编写#\n\n下面是一个使用Node.js编写的示例代码，演示了如何处理动静分离的请求：\n\n\n\n> 因为每个文件所对应的mime类型都不一样，如果手写的话有很多，不过强大的nodejs社区提供了mime库，可以帮我们通过后缀直接分析出\n> 所对应的mime类型，然后我们通过强缓存让浏览器缓存静态资源\n\n\n常见的mime库#\n\n * 文本文件\n   * text/plain：纯文本文件\n   * text/html：HTML 文件\n   * text/css：CSS 样式表文件\n   * text/javascript：JavaScript 文件\n   * application/json：JSON 数据\n * 图像文件\n   * image/jpeg：JPEG 图像\n   * image/png：PNG 图像\n   * image/gif：GIF 图像\n   * image/svg+xml：SVG 图像\n * 音频文件\n   * audio/mpeg：MPEG 音频\n   * audio/wav：WAV 音频\n   * audio/midi：MIDI 音频\n * 视频文件\n   * video/mp4：MP4 视频\n   * video/mpeg：MPEG 视频\n   * video/quicktime：QuickTime 视频\n * 应用程序文件\n   * application/pdf：PDF 文件\n   * application/zip：ZIP 压缩文件\n   * application/x-www-form-urlencoded：表单提交数据\n   * multipart/form-data：多部分表单数据","routePath":"/guide/node/27-动静分离","lang":"","toc":[{"text":"27-动静分离","id":"27-动静分离","depth":2,"charIndex":-1},{"text":"什么是动静分离？","id":"什么是动静分离","depth":3,"charIndex":10},{"text":"代码编写","id":"代码编写","depth":3,"charIndex":654},{"text":"常见的mime库","id":"常见的mime库","depth":3,"charIndex":807}],"domain":"","frontmatter":{},"version":""},{"id":62,"title":"","content":"28-邮件服务#\n\n\n邮件作用#\n\n邮件服务在我们工作中邮件服务充当着一个重要的角色\n\n * 任务分配与跟踪：邮件服务可以用于分配任务、指派工作和跟踪项目进展。通过邮件，可以发送任务清单、工作说明和进度更新，确保团队成员了解其责任和任务要求，并监控\n   工作的完成情况。\n\n * 错误报告和故障排除：当程序出现错误或异常时，程序员可以通过邮件将错误报告发送给团队成员或相关方。这样可以帮助团队了解问题的性质、复现步骤和相关环境，从而更\n   好地进行故障排除和修复。邮件中可以提供详细的错误消息、堆栈跟踪和其他相关信息，以便其他团队成员能够更好地理解问题并提供解决方案。\n\n * 自动化构建和持续集成：在持续集成和自动化构建过程中，邮件服务可以用于通知团队成员构建状态、单元测试结果和代码覆盖率等信息。如果构建失败或出现警告，系统可以\n   自动发送邮件通知相关人员，以便及时采取相应措施。（企业很常用）\n\n\n代码编写#\n\n需要用到的库\n\n\n\n我们邮件的账号（密码| 授权码）不可能明文写到代码里面一般存放在yaml文件或者环境变量里面\n\n> js-yaml 解析yaml文件，如下\n\n\n\n\n\nnodemailder.createTransport 创建邮件服务这里用qq举例，QQ邮件服务文档\n\n\nPOP3/SMTP 设置方法#\n\n用户名/帐户： 你的QQ邮箱完整的地址\n\n密码： 生成的授权码\n\n电子邮件地址： 你的QQ邮箱的完整邮件地址\n\n接收邮件服务器： pop.qq.com，使用SSL，端口号995\n\n发送邮件服务器： smtp.qq.com，使用SSL，端口号465或587\n\n授权码生成如下，在上面网址的地方\n\n\n\n\n\n授权码管理可以查询授权码登录情况\n\n\n\n测试发送，还是使用之前的插件，编写一个http文件，然后右键发送，发现成功\n\n\n\n","routePath":"/guide/node/28-邮件服务","lang":"","toc":[{"text":"28-邮件服务","id":"28-邮件服务","depth":2,"charIndex":-1},{"text":"邮件作用","id":"邮件作用","depth":3,"charIndex":10},{"text":"代码编写","id":"代码编写","depth":3,"charIndex":405},{"text":"POP3/SMTP 设置方法","id":"pop3smtp-设置方法","depth":3,"charIndex":550}],"domain":"","frontmatter":{},"version":""},{"id":63,"title":"","content":"29-express#\n\n\nexpress介绍#\n\nExpress是一个流行的Node.js\nWeb应用程序框架，用于构建灵活且可扩展的Web应用程序和API。它是基于Node.js的HTTP模块而创建的，简化了处理HTTP请求、响应和中间件的过程。\n\n 1. 简洁而灵活：Express提供了简单而直观的API，使得构建Web应用程序变得简单快捷。它提供了一组灵活的路由和中间件机制，使开发人员可以根据需求定制和\n    组织应用程序的行为。\n 2. 路由和中间件：Express使用路由和中间件来处理HTTP请求和响应。开发人员可以定义路由规则，将特定的URL路径映射到相应的处理函数。同时，中间件允许\n    开发人员在请求到达路由处理函数之前或之后执行逻辑，例如身份验证、日志记录和错误处理。\n 3. 路由模块化：Express支持将路由模块化，使得应用程序可以根据不同的功能或模块进行分组。这样可以提高代码的组织性和可维护性，使得多人协作开发更加便捷。\n 4. 视图引擎支持：Express可以与各种模板引擎集成，例如EJS、Pug（以前称为Jade）、Handlebars等。这使得开发人员可以方便地生成动态的H\n    TML页面，并将数据动态渲染到模板中。\n 5. 中间件生态系统：Express有一个庞大的中间件生态系统，开发人员可以使用各种中间件来扩展和增强应用程序的功能，例如身份验证、会话管理、日志记录、静态文\n    件服务等。\n\n\n编码#\n\n * 启动一个http服务\n\n\n\n * 编写get/post接口\n\n\n\n * 接收前端的参数\n\n\n\n\n模块化#\n\n> 我们正常开发的时候肯定不会把代码写到一个模块里面，Express允许将路由处理程序拆分为多个模块，每个模块负责处理特定的路由。通过将路由处理程序拆分为模块，\n> 可以使代码逻辑更清晰，易于维护和扩展\n\n结构大部分如下\n\n\n\nsrc/user.js\n\n\n\napp.js\n\n\n\n\n中间件#\n\n中间件是一个关键概念。中间件是处理HTTP请求和响应的函数，它位于请求和最终路由处理函数之间，可以对请求和响应进行修改、执行额外的逻辑或者执行其他任务。\n\n中间件函数接收三个参数：req（请求对象）、res（响应对象）和next（下一个中间件函数）。通过调用next()方法，中间件可以将控制权传递给下一个中间件函数\n。如果中间件不调用next()方法，请求将被中止，不会继续传递给下一个中间件或路由处理函数\n\n * 实现一个日志中间件\n\n\n\nlog4js是一个用于Node.js应用程序的流行的日志记录库，它提供了灵活且可配置的日志记录功能。log4js允许你在应用程序中记录不同级别的日志消息，并可以\n将日志消息输出到多个目标，如控制台、文件、数据库等\n\nexpress\\middleware\\logger.js\n\n\n\napp.js\n\n","routePath":"/guide/node/29-express","lang":"","toc":[{"text":"29-express","id":"29-express","depth":2,"charIndex":-1},{"text":"express介绍","id":"express介绍","depth":3,"charIndex":13},{"text":"编码","id":"编码","depth":3,"charIndex":629},{"text":"模块化","id":"模块化","depth":3,"charIndex":685},{"text":"中间件","id":"中间件","depth":3,"charIndex":831}],"domain":"","frontmatter":{},"version":""},{"id":64,"title":"","content":"3-npm install 原理#\n\n\n执行 npm install 的时候发生了什么#\n\n首先安装的依赖都会存放在根目录的node_modules,默认采用扁平化的方式安装，并且排序规则.bin第一个然后@系列，再然后按照首字母排序 abcd等\n\n使用的算法是广度优先遍历，在遍历依赖树时，npm 会首先处理项目根目录下的依赖，然后逐层处理每个依赖包的依赖，直到所有依赖都被处理完毕。\n\n在处理每个依赖时，npm 会检查该依赖的版本号是否符合依赖树中其他依赖的版本要求，如果不符合，则会尝试安装适合的版本\n\n\n\n\n扁平化#\n\n扁平化理想状态如下\n\n\n\n安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块\n\n因为 A 模块下的 C 模块被安装到了第一级，这使得 B 模块能够复用处在同一级下；且名称，版本，均相同的 C 模块\n\n非理性状态如下\n\n\n\n因为 B 和 A 所要求的依赖模块不同，（B 下要求是 v2.0 的 C，A 下要求是 v1.0 的 C ）\n\n所以 B 不能像 2 中那样复用 A 下的 C v1.0 模块\n\n所以如果这种情况还是会出现模块冗余的情况，他就会给 B 继续搞一层node_modules，就是非扁平化了。\n\n\nnpm install 后续的流程#\n\n通过图片可以很清楚的了解后续的流程\n\nnpmrc 的配置可以参考下面\n\n\n\n\npackage-lock.json 的作用#\n\n很多朋友只知道这个东西可以锁定版本记录即依赖树详细信息\n\n * version 该参数指定了当前包的版本号\n * resolved 该参数指定了当前包的下载地址\n * integrity 用于验证包的完整性\n * dev 该参数指定了当前包是一个开发依赖包\n * bin 该参数指定了当前包中可执行文件的路径和名称\n * engines 该参数指定了当前包所依赖的 Node.js 版本范围\n\n知识点来了，package-lock.json 帮我们做了缓存，他会通过 name + version + integrity\n信息生成一个唯一的key，这个key能找到对应的index-v5 下的缓存记录 也就是npm cache 文件夹下的\n\n> 可以通过命令npm config list输出的 cache 来找到缓存的路径\n\n\n\n如果发现有缓存记录，就会找到tar 包的hash 值，然后将对应的二进制文件解压到node_modeules\n\n","routePath":"/guide/node/3-npm install原理","lang":"","toc":[{"text":"3-npm install 原理","id":"3-npm-install-原理","depth":2,"charIndex":-1},{"text":"执行 npm install 的时候发生了什么","id":"执行-npm-install-的时候发生了什么","depth":3,"charIndex":19},{"text":"扁平化","id":"扁平化","depth":3,"charIndex":257},{"text":"npm install 后续的流程","id":"npm-install-后续的流程","depth":3,"charIndex":535},{"text":"package-lock.json 的作用","id":"package-lockjson-的作用","depth":3,"charIndex":594}],"domain":"","frontmatter":{},"version":""},{"id":65,"title":"","content":"30-防盗链#\n\n防盗链（Hotlinking）是指在网页或其他网络资源中，通过直接链接到其他网站上的图片、视频或其他媒体文件，从而显示在自己的网页上。这种行为通常会给被链接的网\n站带来额外的带宽消耗和资源浪费，而且可能侵犯了原始网站的版权。\n\n为了防止盗链，网站管理员可以采取一些措施：\n\n 1. 通过HTTP引用检查：网站可以检查HTTP请求的来源，如果来源网址与合法的来源不匹配，就拒绝提供资源。这可以通过服务器配置文件或特定的脚本实现。\n 2. 使用Referrer检查：网站可以检查HTTP请求中的Referrer字段，该字段指示了请求资源的来源页面。如果Referrer字段不符合预期，就拒绝提\n    供资源。这种方法可以在服务器配置文件或脚本中实现。\n 3. 使用访问控制列表（ACL）：网站管理员可以配置服务器的访问控制列表，只允许特定的域名或IP地址访问资源，其他来源的请求将被拒绝。\n 4. 使用防盗链插件或脚本：一些网站平台和内容管理系统提供了专门的插件或脚本来防止盗链。这些工具可以根据需要配置，阻止来自未经授权的网站的盗链请求。\n 5. 使用水印技术：在图片或视频上添加水印可以帮助识别盗链行为，并提醒用户资源的来源。\n\n\n编码#\n\n * 第一步需要初始化静态资源目录 express.static\n\n\n\n\n\n\n\n\n增加防盗链#\n\n防盗链一般主要就是验证host 或者 referer\n\n\n\n127.0.0.1无权限\n\n\n\nlocalhost有权限\n\n","routePath":"/guide/node/30-防盗链","lang":"","toc":[{"text":"30-防盗链","id":"30-防盗链","depth":2,"charIndex":-1},{"text":"编码","id":"编码","depth":3,"charIndex":525},{"text":"增加防盗链","id":"增加防盗链","depth":3,"charIndex":571}],"domain":"","frontmatter":{},"version":""},{"id":66,"title":"","content":"31-响应头和请求头#\n\n\n响应头#\n\nHTTP响应头（HTTP response\nheaders）是在HTTP响应中发送的元数据信息，用于描述响应的特性、内容和行为。它们以键值对的形式出现，每个键值对由一个标头字段（header\nfield）和一个相应的值组成。\n\n例如以下示例\n\n\n\n\n响应头和跨域之间的关系#\n\n * cors\n\n跨域资源共享（Cross-Origin Resource Sharing，CORS）是一种机制，用于在浏览器中实现跨域请求访问资源的权限控制。当一个网页通过\nXMLHttpRequest 或 Fetch API 发起跨域请求时，浏览器会根据同源策略（Same-Origin\nPolicy）进行限制。同源策略要求请求的源（协议、域名和端口）必须与资源的源相同，否则请求会被浏览器拒绝。\n\n * 发送请求\n\n\n\n * express编写一个get接口\n\n\n\n发现是有报错的\n根据同源策略我们看到协议一样，域名一样，但是端口不一致，端口也无法一致，会有冲突，否则就是前后端不分离的项目，前后端代码放在一起，只用一个端口，不过我们是分离的\n没法这么做。\n\n\n\n这个时候就需要后端支持跨域资源请求放行\n\n\n\n增加以下响应头 允许localhost 5500 访问\n\n\n\n结果返回\n\n\n\n\n请求头#\n\n默认情况下cors仅支持客户端向服务器发送如下九个请求头\n\n> tips 没有application/json\n\n 1. Accept：指定客户端能够处理的内容类型。\n 2. Accept-Language：指定客户端偏好的自然语言。\n 3. Content-Language：指定请求或响应实体的自然语言。\n 4. Content-Type：指定请求或响应实体的媒体类型。\n 5. DNT (Do Not Track)：指示客户端不希望被跟踪。\n 6. Origin：指示请求的源（协议、域名和端口）。\n 7. User-Agent：包含发起请求的用户代理的信息。\n 8. Referer：指示当前请求的源 URL。\n 9. Content-type: application/x-www-form-urlencoded | multipart/form-data |\n    text/plain\n\n如果客户端需要支持额外的请求那么我们需要在客户端支持\n\n\n\n\n请求方法支持#\n\n我们服务端默认只支持 GET POST HEAD OPTIONS 请求\n\n例如我们遵循restFul风格，要支持PATCH 或者其他请求\n\n * 增加patch\n\n\n\n * 发送patch\n\n\n\n * 发现报错说patch不在我们的methods里面\n\n\n\n * 修改如下\n\n\n\n\n\n\n预检请求 OPTIONS#\n\n现在很多地方都在使用预检请求，如下\n\n\n\n预检请求的主要目的是确保跨域请求的安全性 它需要满足一定条件才会触发\n\n 1. 自定义请求方法：当使用非简单请求方法（Simple Request Methods）时，例如\n    PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH 等，浏览器会发送预检请求。\n 2. 自定义请求头部字段：当请求包含自定义的头部字段时，浏览器会发送预检请求。自定义头部字段是指不属于简单请求头部字段列表的字段，例如\n    Content-Type 为 application/json、Authorization 等。\n 3. 带凭证的请求：当请求需要在跨域环境下发送和接收凭证（例如包含 cookies、HTTP 认证等凭证信息）时，浏览器会发送预检请求。\n\n * 尝试发送预检请求\n\n\n\n * express编写\n\n\n\n会发现报错了\n\n\n\n阅读就知道因为 application/json 不属于cors 范畴需要手动支持\n\n\n\n\n\n输出code 200，成功\n\n\n\n\n自定义响应头#\n\n在我们做需求的时候肯定会碰到后端自定义响应头\n\n\n\n\n\n前端如何读取呢？\n\n\n\n发现是null 这是因为后端没有抛出该响应头，所以后端需要增加抛出的一个字段\n\n\n\n\n\n\nSSE技术#\n\nServer-Sent Events（SSE）是一种在客户端和服务器之间实现单向事件流的机制，允许服务器主动向客户端发送事件数据。在 SSE\n中，可以使用自定义事件（Custom Events）来发送具有特定类型的事件数据。\n\n> webSocket属于全双工通讯，也就是前端可以给后端实时发送，后端也可以给前端实时发送，SSE属于单工通讯，后端可以给前端实时发送\n\n * express 增加该响应头text/event-stream就变成了sse event 事件名称 data 发送的数据\n\n\n\n前端接受\n\n\n\n","routePath":"/guide/node/31-响应头和请求头","lang":"","toc":[{"text":"31-响应头和请求头","id":"31-响应头和请求头","depth":2,"charIndex":-1},{"text":"响应头","id":"响应头","depth":3,"charIndex":13},{"text":"响应头和跨域之间的关系","id":"响应头和跨域之间的关系","depth":3,"charIndex":144},{"text":"请求头","id":"请求头","depth":3,"charIndex":556},{"text":"请求方法支持","id":"请求方法支持","depth":3,"charIndex":995},{"text":"预检请求 OPTIONS","id":"预检请求-options","depth":3,"charIndex":1147},{"text":"自定义响应头","id":"自定义响应头","depth":3,"charIndex":1626},{"text":"SSE技术","id":"sse技术","depth":3,"charIndex":1720}],"domain":"","frontmatter":{},"version":""},{"id":67,"title":"","content":"32-数据库#\n\nMySQL是一种开源的关系型数据库管理系统（RDBMS），它是最受欢迎的数据库系统之一。MySQL广泛用于Web应用程序和其他需要可靠数据存储的应用程序中。\n\n以下是MySQL数据库的一些重要特点和概念：\n\n 1.  数据库：MySQL是一个数据库管理系统，用于创建和管理数据库。数据库是一个组织结构，用于存储和管理数据。\n 2.  表：数据库中的数据被组织成表的形式。表由行和列组成，行表示记录，列表示字段。\n 3.  SQL：MySQL使用结构化查询语言（SQL）进行数据库操作。SQL是一种用于定义、操作和查询数据库的语言。\n 4.  数据类型：MySQL支持各种数据类型，例如整数、浮点数、字符串、日期和时间等。每个列都有自己的数据类型。\n 5.  索引：MySQL允许创建索引以加快数据检索速度。索引是对表中一列或多列的值进行排序的数据结构。\n 6.  主键：主键是表中的唯一标识符。它用于确保表中的每个记录都有唯一的标识。\n 7.  外键：外键用于建立表与表之间的关联。它定义了一个表中的列与另一个表中的列之间的关系。\n 8.  触发器：触发器是一种在数据库中定义的操作，它会在特定事件发生时自动执行。例如，当向表中插入新记录时，可以触发一个触发器来执行其他操作。\n 9.  存储过程：存储过程是一组预编译的SQL语句，可以在数据库中进行重复使用。它可以接受参数并返回结果。\n 10. 备份和恢复：MySQL提供了备份和恢复数据库的工具和命令，以确保数据的安全性和可靠性。\n\n什么是关系型数据库？\n\n在关系型数据库中，数据以结构化的方式存储，其中每个表格由一组列（字段）和一组行（记录）组成。每个列定义了数据的类型和属性，而每个行则表示一个特定的数据实例。表格\n之间的关系通过使用主键和外键进行建立。主键是唯一标识表格中每个行的列，而外键是指向其他表格主键的列，用于建立表格之间的关联关系。\n\n\n安装流程#\n\n官网：www.mysql.com/\n\n\n\n滚动到下面\n\n\n\n\n\n\n\n\n\n下载后打开，默认端口3306\n\n\n\n设置密码\n\n\n\n添加mysql服务 把名字记住(MySQL83)\n\n\n\n继续往下走就行了\n\n\n\n安装完成之后检查Mysql服务是否开启 services.msc，键盘win + r弹出输入检查\n\n\n\n为什么让大家记住那个名字 MySQL83 因为就是服务的名字 出问题可以检查一下服务\n\n\n\n然后配置环境变量，找到你安装MySQL的地方，找到bin目录，复制地址\n\n\n\n添加进来即可\n\n\n\n测试Mysql，打开cmd，输入如下，然后输入密码\n\n\n\n进来即代表成功\n\n\n\n可视化工具安装\n\n打开VScode\n\n选择扩展 搜索 database 然后安装 Database Client\n\n\n\n点击左侧，然后创建连接，输入你刚刚创建的密码，点击连接\n\n\n\n左边出现连接，且头部为√代表成功，保存即可\n\n\n\n新建库，点击左侧新建，出现sql代码，记得增加数据库名称\n\n\n\n右键，点击执行sql\n\n\n\n成功\n\n\n\n我们也可以cmd自己查看，进入mysql，输入show databases;\n\n\n\n新建表，右键执行sql即可\n\n\n\n插入数据\n\n\n\n也可以点击右边的橙色，更方便输入\n\n\n\n","routePath":"/guide/node/32-数据库","lang":"","toc":[{"text":"32-数据库","id":"32-数据库","depth":2,"charIndex":-1},{"text":"安装流程","id":"安装流程","depth":3,"charIndex":812}],"domain":"","frontmatter":{},"version":""},{"id":68,"title":"","content":"33-SQL语句#\n\nSQL（Structured Query\nLanguage）是一种用于管理关系型数据库系统的语言。它是一种标准化语言，用于执行各种数据库操作，包括数据查询、插入、更新和删除等。\n\n\n数据库的操作#\n\n * 创建数据库\n\n\n\n如果进行重复的创建就会失败，不允许重复创建\n\n\n\n为了避免这个问题 可以添加if not exists\n\n\n\n\n\n如果数据库不存在就创建，存在就什么都不做，我宁愿不做，也不愿犯错。\n\n添加字符集utf-8，这样后面数据库中可以添加中文数据\n\n\n\n\n数据表#\n\n * 创建表\n\n\n\n解析如下\n\ncreate table 表名字 (\n\n 1. id字段名称 int数据类型代表数字类型 NOT NULL(不能为空) AUTO_INCREMENT(id自增) PRIMARY KEY(id为主键)\n 2. name(字段名称) varchar(100)字符串类型100字符 COMMENT(注释)\n 3. age(字段名称) int数据类型代表数字类型 COMMENT(注释)\n 4. create_time(字段名称) timestamp(时间戳) DEFAULT CURRENT_TIMESTAMP(自动填充创建时间)\n\n)\n\n\n\n * 修改表名\n\n\n\n\n\n * 增加列\n\n\n\n\n\n * 删除列\n\n\n\n\n\n * 编辑列\n\n\n\n","routePath":"/guide/node/33-SQL语句","lang":"","toc":[{"text":"33-SQL语句","id":"33-sql语句","depth":2,"charIndex":-1},{"text":"数据库的操作","id":"数据库的操作","depth":3,"charIndex":101},{"text":"数据表","id":"数据表","depth":3,"charIndex":246}],"domain":"","frontmatter":{},"version":""},{"id":69,"title":"","content":"34-查询#\n\n目前为止我们已经学到数据库的基本操作，以及库和表的基本语句，不过对于Mysql来说最常用的还是增删改查的语句\n\n\n查询#\n\n> 查询是使用频率最高的语句\n\n查询单个列#\n\n\n\n查询多个列，逗号隔开即可#\n\n\n\n\n\n查询所有列 *#\n\n\n\n\n\n列的别名 as#\n\n\n\n\n\n排序#\n\nORDER BY [字段名称] desc降序(从大到小) asc 升序(从小到大)\n\n\n\n\n\n限制查询结果#\n\nlimit [开始行] [限制条数]\n\n> 使用limit的时候是从0开始的跟数组一样\n\n\n\n\n\n条件查询#\n\n我们需要把搜索条件放在WHERE子句中 例如查询name字段所对应的值 小苏 完全匹配\n\n\n\n\n\n多个条件联合查询#\n\n比如说 我想查询 name 叫 小苏的，并且年龄是20岁以下的\n\n\n\n * and 操作符\n\n在给定多个搜索条件的时候，我们有时需要某条记录只在符合所有搜索条件的时候进行查询，这种情况我们可以使用and操作符来连接多个搜索条件\n\n\n\n\n\n * or 操作符\n\n在给定多个搜索条件的时候，我们有时需要某条记录在符合某一个搜索条件的时候就将其加入结果集中，这种情况我们可以使用OR操作符来连接多个搜索条件\n\n\n\n\n\n模糊查询#\n\n在MySQL中，\"LIKE\"操作符用于模糊匹配字符串。而百分号（%）是用作通配符，表示任意字符（包括零个字符或多个字符）的占位符。\n\n当你在使用\"LIKE\"操作符时，可以在模式（pattern）中使用百分号来匹配一个或多个字符。下面是一些使用百分号的示例：\n\n * \"苏%\"：匹配以\"满\"开头的字符串，后面可以是任意字符。\n * \"%苏\"：匹配以\"满\"结尾的字符串，前面可以是任意字符。\n * \"%苏%\"：匹配包含\"满\"的任意位置的字符串，前后可以是任意字符。\n\n\n\n","routePath":"/guide/node/34-查询","lang":"","toc":[{"text":"34-查询","id":"34-查询","depth":2,"charIndex":-1},{"text":"查询","id":"查询","depth":3,"charIndex":64},{"text":"查询单个列","id":"查询单个列","depth":4,"charIndex":85},{"text":"查询多个列，逗号隔开即可","id":"查询多个列逗号隔开即可","depth":4,"charIndex":95},{"text":"查询所有列 *","id":"查询所有列-","depth":4,"charIndex":114},{"text":"列的别名 `as`","id":"列的别名-as","depth":4,"charIndex":-1},{"text":"排序","id":"排序","depth":4,"charIndex":142},{"text":"限制查询结果","id":"限制查询结果","depth":4,"charIndex":194},{"text":"条件查询","id":"条件查询","depth":4,"charIndex":252},{"text":"多个条件联合查询","id":"多个条件联合查询","depth":4,"charIndex":308},{"text":"模糊查询","id":"模糊查询","depth":4,"charIndex":525}],"domain":"","frontmatter":{},"version":""},{"id":70,"title":"","content":"35-增删改#\n\n上节学习了查询，这节学习增删改\n\n\n新增#\n\n在这个语句中，我们明确了插入的顺序，第一个字段对应name，第二个hobby，第三个age，values里面的值是与之对应的\n\n\n\n\n\n插入null值\n\n在设计表结构的时候，我们允许 name age hobby 为null，所以我们也可以插入null值\n\n\n\n\n\n插入多条数据 逗号隔开即可\n\n\n\n\n\n\n删除#\n\n删除id为10的记录\n\n\n\n\n\n批量删除\n\n\n\n\n\n\n更改#\n\n更新的字段使用 = 赋值, where确定更新的条例\n\n\n\n","routePath":"/guide/node/35-增删改","lang":"","toc":[{"text":"35-增删改","id":"35-增删改","depth":2,"charIndex":-1},{"text":"新增","id":"新增","depth":3,"charIndex":26},{"text":"删除","id":"删除","depth":3,"charIndex":184},{"text":"更改","id":"更改","depth":3,"charIndex":216}],"domain":"","frontmatter":{},"version":""},{"id":71,"title":"","content":"36-表达式和函数#\n\n\n表达式#\n\nMySQL表达式是一种在MySQL数据库中使用的计算式或逻辑式。它们可用于查询、更新和过滤数据，以及进行条件判断和计算。\n\n 1. 算术表达式：可以执行基本的数学运算，例如加法、减法、乘法和除法。例如：SELECT col1 + col2 AS sum FROM\n    table_name;\n 2. 字符串表达式：可以对字符串进行操作，例如连接、截取和替换。例如：SELECT CONCAT(first_name, ' ', last_name) AS\n    full_name FROM table_name;\n 3. 逻辑表达式：用于执行条件判断，返回布尔值（TRUE或FALSE）。例如：SELECT * FROM table_name WHERE age > 18\n    AND gender = 'Male';\n 4. 条件表达式：用于根据条件返回不同的结果。例如：SELECT CASE WHEN age < 18 THEN 'Minor' ELSE 'Adult'\n    END AS age_group FROM table_name;\n 5. 聚合函数表达式：用于计算数据集的聚合值，例如求和、平均值、最大值和最小值。例如：SELECT AVG(salary) AS average_salary\n    FROM table_name;\n 6. 时间和日期表达式：用于处理时间和日期数据，例如提取年份、月份或计算日期差值。例如：SELECT YEAR(date_column) AS year\n    FROM table_name;\n\n例如查询的时候增加数值100\n\n\n\n\n\n如果要换一个列名可以用as\n\n\n\n\n\n\n函数#\n\nMySQL提供了大量的内置函数，用于在查询和操作数据时进行计算、转换和处理。以下是一些常用的MySQL函数分类及其示例：\n\n 1. 字符串函数：\n    * CONCAT(str1, str2, ...)：将多个字符串连接起来。\n    * SUBSTRING(str, start, length)：从字符串中提取子字符串。\n    * UPPER(str)：将字符串转换为大写。\n    * LOWER(str)：将字符串转换为小写。\n    * LENGTH(str)：返回字符串的长度。\n 2. 数值函数：\n    * ABS(x)：返回x的绝对值。\n    * ROUND(x, d)：将x四舍五入为d位小数。\n    * CEILING(x)：返回不小于x的最小整数。\n    * FLOOR(x)：返回不大于x的最大整数。\n    * RAND()：返回一个随机数。\n 3. 日期和时间函数：\n    * NOW()：返回当前日期和时间。\n    * CURDATE()：返回当前日期。\n    * CURTIME()：返回当前时间。\n    * DATE_FORMAT(date, format)：将日期格式化为指定的格式。\n    * DATEDIFF(date1, date2)：计算两个日期之间的天数差。\n 4. 条件函数：\n    * IF(condition, value_if_true, value_if_false)：根据条件返回不同的值。\n    * CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 ELSE result\n      END：根据条件返回不同的结果。\n 5. 聚合函数：\n    * COUNT(expr)：计算满足条件的行数。\n    * SUM(expr)：计算表达式的总和。\n    * AVG(expr)：计算表达式的平均值。\n    * MAX(expr)：返回表达式的最大值。\n    * MIN(expr)：返回表达式的最小值。\n\n * 返回随机数\n\n\n\n * 求和\n\n\n\n * 字符串拼接\n\n\n\n * 获取总数\n\n","routePath":"/guide/node/36-表达式和函数","lang":"","toc":[{"text":"36-表达式和函数","id":"36-表达式和函数","depth":2,"charIndex":-1},{"text":"表达式","id":"表达式","depth":3,"charIndex":12},{"text":"函数","id":"函数","depth":3,"charIndex":742}],"domain":"","frontmatter":{},"version":""},{"id":72,"title":"","content":"37-子查询和连表#\n\n\n子查询#\n\n子查询（Subquery），也被称为嵌套查询（Nested\nQuery），是指在一个查询语句中嵌套使用另一个完整的查询语句。子查询可以被视为一个查询的结果集，它可以作为外层查询的一部分，用于进一步筛选、计算或操作数据。\n\n子查询通常出现在主查询的WHERE子句、FROM子句、HAVING子句或SELECT子句中，以提供更复杂的查询逻辑。子查询可以根据主查询的结果动态生成结果集，用\n于过滤和匹配数据，或者作为函数的参数使用。\n\n子查询可以返回单个值、一列值、一行值或者一个结果集，具体取决于子查询的语法和用法。根据子查询返回的结果类型，可以将其与主查询的其他表达式进行比较、连接或使用作为\n条件进行过滤。\n\n我们之前的案例都是在一张表去查询，现实中不会把所有东西都放在一张表，会进行分表，甚至还会分库分表，读写分离等等。\n\n\n案例通过名字查询photo表#\n\nphoto表数据\n\n\n\nuser表数据\n\n\n\n关联关系为 user表的id 关联 photo表的user_id\n\n但是我们现在需要通过名字查询出photo表的数据 但是photo表没有存名字怎么弄子查询\n\n我们的思路就是通过名字查询user表的id，然后通过user表的id去查询photo的user_id就完成了\n\n\n\n\n\n\n连表#\n\nMysql的连表分为内连接，外连接，交叉连接\n\n 1. 对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的内连接。\n 2. 对于外连接的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。\n 3. 交叉连接是指在两张或多张表之间没有任何连接条件的连接。简单来说，交叉连接可以让你查询所有可能的组合。\n\n内连接#\n\n\n\n\n\n外连接#\n\n左连接#\n\n语法规则 LEFT JOIN [连接的表] ON [连接的条件]\n\n并且以第一个表作为驱动表 被驱动表如果没有值则补充null\n\n\n\n\n\n右连接#\n\n语法规则 RIGHT JOIN [连接的表] ON [连接的条件]\n\n并且以第二个表作为驱动表 被驱动表如果没有值则忽略\n\n\n\n","routePath":"/guide/node/37-子查询和连表","lang":"","toc":[{"text":"37-子查询和连表","id":"37-子查询和连表","depth":2,"charIndex":-1},{"text":"子查询","id":"子查询","depth":3,"charIndex":12},{"text":"案例通过名字查询photo表","id":"案例通过名字查询photo表","depth":3,"charIndex":382},{"text":"连表","id":"连表","depth":3,"charIndex":563},{"text":"内连接","id":"内连接","depth":4,"charIndex":768},{"text":"外连接","id":"外连接","depth":4,"charIndex":778}],"domain":"","frontmatter":{},"version":""},{"id":73,"title":"","content":"38-mysql2#\n\n在之前的篇章中，已经学习完成mysql的基本知识，那么现在开始，我们需要把mysql和express,nodejs连接起来。\n\n\n安装依赖#\n\n在终端输入如下代码，安装依赖\n\n\n\n 1. mysql2 用来连接mysql和编写sq语句\n 2. express 用来提供接口 增删改差\n 3. js-yaml 用来编写配置文件\n\n\n编写代码#\n\ndb.config.yaml\n\n\n\nindex.js\n\n\n\nindex.http，方便测试接口\n\n\n\n\n\n\n\n\n\n","routePath":"/guide/node/38-mysql2","lang":"","toc":[{"text":"38-mysql2","id":"38-mysql2","depth":2,"charIndex":-1},{"text":"安装依赖","id":"安装依赖","depth":3,"charIndex":76},{"text":"编写代码","id":"编写代码","depth":3,"charIndex":176}],"domain":"","frontmatter":{},"version":""},{"id":74,"title":"","content":"39-ORM( Knex + express )#\n\n\nKnex#\n\nKnex是一个基于JavaScript的查询生成器，它允许你使用JavaScript代码来生成和执行SQL查询语句。它提供了一种简单和直观的方式来与关系型数据库\n进行交互，而无需直接编写SQL语句。你可以使用Knex定义表结构、执行查询、插入、更新和删除数据等操作。\n\nKnex的安装和设置#\n\n> Knex支持多种数据库 如pg、sqlite3、mysql2、oracledb、tedious\n\n\n\n连接数据库\n\n\n\n\n定义表结构#\n\n\n\n\n实现增删改差#\n\n新增接口\n\n\n\n删除接口\n\n\n\n删除接口\n\n\n\n查询接口\n\n\n\n\n高级玩法#\n\n反编译为SQL语句，用SQL语句调用\n\n\n\n连表\n\n\n\n排序\n\n\n\n\n事务#\n\n你可以使用事务来确保一组数据库操作的原子性，即要么全部成功提交，要么全部回滚\n\n例如A给B转钱，需要两条语句，如果A语句成功了，B语句因为一些场景失败了，那这钱就丢了，所以事务就是为了解决这个问题，要么都成功，要么都回滚，保证金钱不会丢失。\n\n","routePath":"/guide/node/39-ORM( Knex + express )","lang":"","toc":[{"text":"39-ORM( Knex + express )","id":"39-orm-knex--express-","depth":2,"charIndex":-1},{"text":"Knex","id":"knex","depth":3,"charIndex":27},{"text":"Knex的安装和设置","id":"knex的安装和设置","depth":4,"charIndex":169},{"text":"定义表结构","id":"定义表结构","depth":3,"charIndex":245},{"text":"实现增删改差","id":"实现增删改差","depth":3,"charIndex":256},{"text":"高级玩法","id":"高级玩法","depth":3,"charIndex":298},{"text":"事务","id":"事务","depth":3,"charIndex":340}],"domain":"","frontmatter":{},"version":""},{"id":75,"title":"","content":"4-npm run 原理#\n\n\nnpm run xxx 发生了什么#\n\n按照下面的例子npm run dev举例过程中发生了什么\n\n\n\n读取package json的scripts对应的脚本命令dev:vite,vite 是个可执行脚本，他的查找规则是：\n\n * 先从当前项目的node_modules/.bin去查找可执行命令vite\n\n * 如果没找到就去全局的node_modules去找可执行命令vite\n   \n   > 全局的可以通过npm config list输出的 prefix 找到路径\n\n * 如果还没找到就去环境变量查找\n\n * 再找不到就进行报错\n\n如果成功找到会发现有三个文件\n\n\n\n> 因为 nodejs 是跨平台的所以可执行命令兼容各个平台\n\n * .sh文件是给 Linux、Unix、Macos 使用\n * .cmd给 Windows 的 cmd 使用\n * .ps1给 Windows 的 powerShell 使用\n\n\nnpm 生命周期#\n\n没想到吧 npm 执行命令也有生命周期！\n\n创建了 3 个文件index.js、post.js、prev.js，内容是console.log(文件名字)\n\n> 注意：nodejs 的 console api 是自己实现的，与浏览器的 console api 不同\n\n在package.json的scripts书写如下代码\n\n\n\n执行npm run dev命令的时候predev会自动执行 他的生命周期是在dev之前执行，然后执行dev命令，再然后执行postdev，也就是dev之后执行\n\n运用场景：例如npm run build可以在打包之后删除 dist 目录等等\n\npost 例如你编写完一个工具发布 npm，那就可以在之后写一个 cli 脚本顺便帮你推送到 git 等等\n\n> 谁用到了如上的场景\n> \n> 例如 vue-cli github.com/vuejs/vue-c…\n\n","routePath":"/guide/node/4-npm run原理","lang":"","toc":[{"text":"4-npm run 原理","id":"4-npm-run-原理","depth":2,"charIndex":-1},{"text":"npm run xxx 发生了什么","id":"npm-run-xxx-发生了什么","depth":3,"charIndex":15},{"text":"npm 生命周期","id":"npm-生命周期","depth":3,"charIndex":429}],"domain":"","frontmatter":{},"version":""},{"id":76,"title":"","content":"40-ORM( Prisma + express )#\n\n\n什么是 prisma?#\n\nPrisma 是一个现代化的数据库工具套件，用于简化和改进应用程序与数据库之间的交互。它提供了一个类型安全的查询构建器和一个强大的\nORM（对象关系映射）层，使开发人员能够以声明性的方式操作数据库。\n\nPrisma 支持多种主流数据库，包括 PostgreSQL、MySQL 和 SQLite，它通过生成标准的数据库模型来与这些数据库进行交互。使用\nPrisma，开发人员可以定义数据库模型并生成类型安全的查询构建器，这些构建器提供了一套直观的方法来创建、更新、删除和查询数据库中的数据。\n\nPrisma 的主要特点包括：\n\n 1. 类型安全的查询构建器：Prisma 使用强类型语言（如\n    TypeScript）生成查询构建器，从而提供了在编译时捕获错误和类型检查的能力。这有助于减少错误，并提供更好的开发人员体验。\n 2. 强大的 ORM 层：Prisma 提供了一个功能强大的 ORM 层，使开发人员能够以面向对象的方式操作数据库。它自动生成了数据库模型的\n    CRUD（创建、读取、更新、删除）方法，简化了与数据库的交互。\n 3. 数据库迁移：Prisma 提供了数据库迁移工具，可帮助开发人员管理数据库模式的变更。它可以自动创建和应用迁移脚本，使数据库的演进过程更加简单和可控。\n 4. 性能优化：Prisma\n    使用先进的查询引擎和数据加载技术，以提高数据库访问的性能。它支持高级查询功能，如关联查询和聚合查询，并自动优化查询以提供最佳的性能\n\n\n安装使用#\n\n 1. 安装 Prisma CLI：\n    * 使用 npm 安装：运行 npm install -g prisma。\n    * 使用 yarn 安装：运行 yarn global add prisma。\n 2. 初始化项目\n    * 使用prisma init --datasource-provider mysql\n\n此时就会创建生成基本目录\n\n\n\n 3. 连接mysql\n\n * 修改.env文件 [DATABASE_URL=\"mysql://账号:密码@主机:端口/库名\"]\n * 例子 DATABASE_URL=\"mysql://root:123456@localhost:3306/su\"\n\n\n创建表#\n\nprisma/schema.prisma\n\n> 没有高亮可以去扩展搜索prisma下载，在右下角语言关联prisma即可\n\n\n\n执行命令 创建表\n\n\n\n\n\n\n实现增删改查#\n\n\n\n测试http，仅参考\n\n\n\n\n\n\n\n\n\n\n\n> 注意删除这里：因为post表中有关联我们的user表数据即post表有外键在user表，如果只是用delete方法或者在数据库中删除都会发现不成功，所以我们\n> 需要级联删除，和它相关的都删除了才能删除它本身","routePath":"/guide/node/40-ORM( Prisma + express )","lang":"","toc":[{"text":"40-ORM( Prisma + express )","id":"40-orm-prisma--express-","depth":2,"charIndex":-1},{"text":"什么是 prisma?","id":"什么是-prisma","depth":3,"charIndex":29},{"text":"安装使用","id":"安装使用","depth":3,"charIndex":681},{"text":"创建表","id":"创建表","depth":3,"charIndex":994},{"text":"实现增删改查","id":"实现增删改查","depth":3,"charIndex":1079}],"domain":"","frontmatter":{},"version":""},{"id":77,"title":"","content":"41-项目架构( MVC + loC + 装饰器 )#\n\n到现在为止，我们学习了，express框架，编写接口，mysql数据库读写数据，knex,prisma\nORM框架，现在是时候把这些组合到一起，并且实现一个类似于Nestjs或者java的SpringBoot的架构真正的去开发我们的nodejs项目\n\n\nMVC#\n\nMVC（Model-View-Controller）是一种常用的软件架构模式，用于设计和组织应用程序的代码。它将应用程序分为三个主要组件：模型（Model）、视\n图（View）和控制器（Controller），各自负责不同的职责。\n\n 1. 模型（Model）：模型表示应用程序的数据和业务逻辑。它负责处理数据的存储、检索、验证和更新等操作。模型通常包含与数据库、文件系统或外部服务进行交互的代\n    码。\n 2. 视图（View）：视图负责将模型的数据以可视化的形式呈现给用户。它负责用户界面的展示，包括各种图形元素、页面布局和用户交互组件等。视图通常是根据模型的状\n    态来动态生成和更新的。\n 3. 控制器（Controller）：控制器充当模型和视图之间的中间人，负责协调两者之间的交互。它接收用户输入（例如按钮点击、表单提交等），并根据输入更新模型\n    的状态或调用相应的模型方法。控制器还可以根据模型的变化来更新视图的显示。\n\nMVC 的主要目标是将应用程序的逻辑、数据和界面分离，以提高代码的可维护性、可扩展性和可重用性。通过将不同的职责分配给不同的组件，MVC\n提供了一种清晰的结构，使开发人员能够更好地管理和修改应用程序的各个部分。\n\n\nIoC控制反转和DI依赖注入#\n\n控制反转（Inversion of Control，IoC）和依赖注入（Dependency\nInjection，DI）是软件开发中常用的设计模式和技术，用于解耦和管理组件之间的依赖关系。虽然它们经常一起使用，但它们是不同的概念。\n\n 1. 控制反转（IoC）是一种设计原则，它将组件的控制权从组件自身转移到外部容器。传统上，组件负责自己的创建和管理，而控制反转则将这个责任转给了一个外部的容器\n    或框架。容器负责创建组件实例并管理它们的生命周期，组件只需声明自己所需的依赖关系，并通过容器获取这些依赖。这种反转的控制权使得组件更加松耦合、可测试和可\n    维护。\n 2. 依赖注入（DI）是实现控制反转的一种具体技术。它通过将组件的依赖关系从组件内部移动到外部容器来实现松耦合。组件不再负责创建或管理它所依赖的其他组件，而是\n    通过构造函数、属性或方法参数等方式将依赖关系注入到组件中。依赖注入可以通过构造函数注入（Constructor\n    Injection）、属性注入（Property Injection）或方法注入（Method Injection）等方式实现。\n\n\n安装依赖#\n\n 1. inversify + reflect-metadata 实现依赖注入 官网\n 2. 接口编写express 官网\n 3. 连接工具 inversify-express-utils 文档\n 4. orm框架 prisma 官网\n 5. dto class-validator + class-transformer 文档\n\n\n项目架构#\n\n新建一个文件夹\n\n通过 prisma init --datasource-provider mysql 构建prisma项目 上一章讲过了\n\n目录结构\n\n * /src\n   * /user\n     * /controller.ts\n     * /service.ts\n     * /user.dto.ts\n   * /post\n     * /controller.ts\n     * /service.ts\n     * /post.dto.ts\n   * /db\n     * /index.ts\n   * /prisma\n     * /schema.prisma\n * main.ts\n * .env\n * tsconfig.json\n * package.json\n * README.md\n\n\n代码编写#\n\nmain.ts\n\n\n\nsrc/user/controller.ts\n\n\n\nsrc/user/service.ts\n\n\n\nsrc/user/user.dto.ts\n\n\n\nsrc/db/index.ts\n\n\n\ntsconig.json\n\n支持装饰器和反射 打开一下 严格模式关闭\n\n","routePath":"/guide/node/41-项目架构( MVC + loC + 装饰器 )","lang":"","toc":[{"text":"41-项目架构( MVC + loC + 装饰器 )","id":"41-项目架构-mvc--loc--装饰器-","depth":2,"charIndex":-1},{"text":"MVC","id":"mvc","depth":3,"charIndex":155},{"text":"IoC控制反转和DI依赖注入","id":"ioc控制反转和di依赖注入","depth":3,"charIndex":694},{"text":"安装依赖","id":"安装依赖","depth":3,"charIndex":1210},{"text":"项目架构","id":"项目架构","depth":3,"charIndex":1384},{"text":"代码编写","id":"代码编写","depth":3,"charIndex":1748}],"domain":"","frontmatter":{},"version":""},{"id":78,"title":"","content":"42-项目架构( JWT鉴权 )#\n\n\n什么是jwt?#\n\nJWT（JSON Web Token）是一种开放的标准（RFC\n7519），用于在网络应用间传递信息的一种方式。它是一种基于JSON的安全令牌，用于在客户端和服务器之间传输信息。 jwt.io/\n\nJWT由三部分组成，它们通过点（.）进行分隔：\n\n 1. Header（头部）：包含了令牌的类型和使用的加密算法等信息。通常采用Base64编码表示。\n 2. Payload（负载）：包含了身份验证和授权等信息，如用户ID、角色、权限等。也可以自定义其他相关信息。同样采用Base64编码表示。\n 3. Signature（签名）：使用指定的密钥对头部和负载进行签名，以确保令牌的完整性和真实性。\n\nJWT的工作流程如下：\n\n 1. 用户通过提供有效的凭证（例如用户名和密码）进行身份验证。\n 2. 服务器验证凭证，并生成一个JWT作为响应。JWT包含了用户的身份信息和其他必要的数据。\n 3. 服务器将JWT发送给客户端。\n 4. 客户端在后续的请求中，将JWT放入请求的头部或其他适当的位置。\n 5. 服务器在接收到请求时，验证JWT的签名以确保其完整性和真实性。如果验证通过，服务器使用JWT中的信息进行授权和身份验证。\n\n\n用到的依赖#\n\n 1. passport passport是一个流行的用于身份验证和授权的Node.js库\n 2. passport-jwt Passport-JWT是Passport库的一个插件，用于支持使用JSON Web Token (JWT)\n    进行身份验证和授权\n 3. jsonwebtoken 生成token的库\n\n\n代码编写#\n\n沿用上一章的代码 在src下增加jwt目录\n\nsrc/jwt/index.ts\n\n\n\nmain.ts\n\n\n\nsrc/user/controller.ts\n\n\n\nsrc/user/services.ts\n\n\n\njwt接口验证，哪个接口需要token验证就往哪儿加就可以了，http可自行编写\n\n","routePath":"/guide/node/42-项目架构( JWT鉴权 )","lang":"","toc":[{"text":"42-项目架构( JWT鉴权 )","id":"42-项目架构-jwt鉴权-","depth":2,"charIndex":-1},{"text":"什么是jwt?","id":"什么是jwt","depth":3,"charIndex":19},{"text":"用到的依赖","id":"用到的依赖","depth":3,"charIndex":544},{"text":"代码编写","id":"代码编写","depth":3,"charIndex":713}],"domain":"","frontmatter":{},"version":""},{"id":79,"title":"","content":"43-Redis( 介绍与安装 )#\n\n\n\nRedis（Remote Dictionary\nServer）是一个开源的内存数据结构存储系统，它提供了一个高效的键值存储解决方案，并支持多种数据结构，如字符串（Strings）、哈希（Hashes）、列表（\nLists）、集合（Sets）和有序集合（Sorted Sets）等。它被广泛应用于缓存、消息队列、实时统计等场景。\n\n以下是一些关键特性和用途介绍：\n\n 1. 内存存储：Redis主要将数据存储在内存中，因此具有快速的读写性能。它可以持久化数据到磁盘，以便在重新启动后恢复数据。\n 2. 多种数据结构：Redis不仅仅是一个简单的键值存储，它支持多种数据结构，如字符串、哈希、列表、集合和有序集合。这些数据结构使得Redis能够更灵活地存储\n    和操作数据。\n 3. 发布/订阅：Redis支持发布/订阅模式，允许多个客户端订阅一个或多个频道，以接收实时发布的消息。这使得Redis可以用作实时消息系统。\n 4. 事务支持：Redis支持事务，可以将多个命令打包成一个原子操作执行，确保这些命令要么全部执行成功，要么全部失败。\n 5. 持久化：Redis提供了两种持久化数据的方式：RDB（Redis Database）和AOF（Append Only\n    File）。RDB是将数据以快照形式保存到磁盘，而AOF是将每个写操作追加到文件中。这些机制可以确保数据在意外宕机或重启后的持久性。\n 6. 高可用性：Redis支持主从复制和Sentinel哨兵机制。通过主从复制，可以创建多个Redis实例的副本，以提高读取性能和容错能力。Sentinel是\n    一个用于监控和自动故障转移的系统，它可以在主节点宕机时自动将从节点提升为主节点。\n 7. 缓存：由于Redis具有快速的读写性能和灵活的数据结构，它被广泛用作缓存层。它可以将常用的数据存储在内存中，以加快数据访问速度，减轻后端数据库的负载。\n 8. 实时统计：Redis的计数器和有序集合等数据结构使其非常适合实时统计场景。它可以存储和更新计数器，并对有序集合进行排名和范围查询，用于统计和排行榜功能\n\n\nredis安装#\n\nwindows安装#\n\n 1. 安装包形式\n\n * 可以找人要安装包，建议b站搜索小满zs加vx群要，把解压后的路径添加到环境变量\n\n\n\n * 添加到windows服务(cmd管理员模式进入到该文件夹下)\n\n\n\n * 可以win+r输入services.msc，找到Redis查看是否启动，并设置为自动\n\n\n\n 2. wsl安装\n    \n    * 官方文档\n    \n    * cmd管理员模式 执行 wsl --update 升级wsl版本 wsl --set-default-version 2 设置wsl版本2\n    \n    * 搜索栏搜索功能，打开如下的虚拟机平台\n    \n    * \n    \n    * 打开Microsoft Store 搜索 wsl 安装一个乌班图\n    \n    * \n    \n    * 接着跟着官网执行以下命令即可\n    \n    * \n\nMac,Linux 安装#\n\nMac：brew install redis 启动redis redis-server 连接redis redis-cli\n\nLinux：wget https://download.redis.io/redis-stable.tar.gz\n\n * 编译源文件\n   \n   \n\n * 启动redis\n   \n   \n\n> Redis可视化也可通过之前的连接mysql的Database Client工具来连接Redis","routePath":"/guide/node/43-Redis( 介绍与安装 )","lang":"","toc":[{"text":"43-Redis( 介绍与安装 )","id":"43-redis-介绍与安装-","depth":2,"charIndex":-1},{"text":"redis安装","id":"redis安装","depth":3,"charIndex":915},{"text":"windows安装","id":"windows安装","depth":4,"charIndex":925},{"text":"Mac,Linux 安装","id":"maclinux-安装","depth":4,"charIndex":1324}],"domain":"","frontmatter":{},"version":""},{"id":80,"title":"","content":"44-Redis( 基本使用 )#\n\n上一章配置完环境变量后在cmd输入redis-cli即可运行下面命令，可以通过工具查看是否运行成功操作\n\n\n字符串的操作#\n\n\n\n * key：要设置的键名。\n\n * value：要设置的值。\n\n * NX：可选参数，表示只在键不存在时才设置值。\n\n * XX：可选参数，表示只在键已经存在时才设置值。\n\n * EX seconds：可选参数，将键的过期时间设置为指定的秒数。\n\n * PX milliseconds：可选参数，将键的过期时间设置为指定的毫秒数。\n\n * GET：可选参数，返回键的旧值。\n\n 1. 设置键名为 \"name\" 的值为 \"chenchen\"：\n\n\n\n 2. 设置键名为 \"counter\" 的值为 10，并设置过期时间为 60 秒：\n\n\n\n 3. 只在键名为 \"status\" 不存在时，设置其值为 \"active\"：\n\n\n\n 4. 只在键名为 \"score\" 已经存在时，将其值增加 5：\n\n\n\n 5. 设置键名为 \"message\" 的值为 \"Hello\"，并返回旧的值：\n\n\n\n 6. 删除键名为 \"name\" 的键：\n\n\n\n 7. 批量删除多个键名：\n\n\n\n 8. 删除不存在的键名，不会报错，返回删除的键数量为 0：\n\n\n\n\n集合的操作#\n\n集合（Set）是一种无序且不重复的数据结构，用于存储一组独立的元素。集合中的元素之间没有明确的顺序关系，每个元素在集合中只能出现一次。\n\n 1. 添加成员到集合：\n    \n    \n\n 2. 获取集合中的所有成员：\n    \n    \n    \n    输出结果：\n    \n    \n\n 3. 检查成员是否存在于集合中：\n    \n    \n    \n    输出结果：\n    \n    \n\n 4. 从集合中移除成员：\n    \n    \n    \n    输出结果：\n    \n    \n\n 5. 获取集合中的成员数量：\n    \n    \n    \n    输出结果：\n    \n    \n\n 6. 获取随机成员：\n    \n    \n    \n    输出结果：\n    \n    \n\n 7. 求多个集合的并集：\n    \n    \n    \n    输出结果：\n    \n    \n\n 8. 求多个集合的交集：\n    \n    \n    \n    输出结果：\n    \n    \n\n 9. 求多个集合的差集：\n    \n    \n    \n    输出结果：\n    \n    \n\n\n哈希表操作#\n\n哈希表（Hash）是一种数据结构，也称为字典、关联数组或映射，用于存储键值对集合。在哈希表中，键和值都是存储的数据项，并通过哈希函数将键映射到特定的存储位置，从\n而实现快速的数据访问和查找。\n\n 1.  设置哈希表中的字段值：\n     \n     \n\n 2.  获取哈希表中的字段值：\n     \n     \n     \n     输出结果：\n     \n     \n\n 3.  一次设置多个字段的值：\n     \n     \n\n 4.  获取多个字段的值：\n     \n     \n     \n     输出结果：\n     \n     \n\n 5.  获取哈希表中所有字段和值：\n     \n     \n     \n     输出结果：\n     \n     \n\n 6.  删除哈希表中的字段：\n     \n     \n     \n     输出结果：\n     \n     \n\n 7.  检查哈希表中是否存在指定字段：\n     \n     \n     \n     输出结果：\n     \n     \n\n 8.  获取哈希表中所有的字段：\n     \n     \n     \n     输出结果：\n     \n     \n\n 9.  获取哈希表中所有的值：\n     \n     \n     \n     输出结果：\n     \n     \n\n 10. 获取哈希表中字段的数量：\n     \n     \n     \n     输出结果：\n     \n     \n\n\n列表的操作#\n\n列表（List）是一种有序、可变且可重复的数据结构。在许多编程语言和数据存储系统中，列表是一种常见的数据结构类型，用于存储一组元素\n\n 1. 添加元素：\n\n\n\n>  * LPUSH key element1 element2\n>    ...：将一个或多个元素从列表的左侧插入，即将元素依次插入列表的头部。如果列表不存在，则在执行操作前会自动创建一个新的列表。\n>  * RPUSH key element1 element2\n>    ...：将一个或多个元素从列表的右侧插入，即将元素依次插入列表的尾部。如果列表不存在，则在执行操作前会自动创建一个新的列表。\n\n 1. 获取元素：\n\n\n\n 1. 修改元素：\n\n\n\n 1. 删除元素：\n\n\n\n 1. 获取列表长度：\n\n","routePath":"/guide/node/44-Redis( 基本使用 )","lang":"","toc":[{"text":"44-Redis( 基本使用 )","id":"44-redis-基本使用-","depth":2,"charIndex":-1},{"text":"字符串的操作","id":"字符串的操作","depth":3,"charIndex":72},{"text":"集合的操作","id":"集合的操作","depth":3,"charIndex":551},{"text":"哈希表操作","id":"哈希表操作","depth":3,"charIndex":1059},{"text":"列表的操作","id":"列表的操作","depth":3,"charIndex":1702}],"domain":"","frontmatter":{},"version":""},{"id":81,"title":"","content":"45-Redis( 发布订阅 + 事务 )#\n\n\n发布订阅#\n\n发布-订阅是一种消息传递模式，其中消息发布者（发布者）将消息发送到频道（channel），而订阅者（订阅者）可以订阅一个或多个频道以接收消息。这种模式允许消息的\n解耦，发布者和订阅者之间可以独立操作，不需要直接交互。\n\n在Redis中，发布-订阅模式通过以下命令进行操作：\n\n 1. PUBLISH命令：用于将消息发布到指定的频道。语法为：PUBLISH channel message。例如，PUBLISH news \"Hello,\n    world!\" 将消息\"Hello, world!\"发布到名为\"news\"的频道。\n 2. SUBSCRIBE命令：用于订阅一个或多个频道。语法为：SUBSCRIBE channel [channel ...]。例如，SUBSCRIBE\n    news sports 订阅了名为\"news\"和\"sports\"的频道。\n 3. UNSUBSCRIBE命令：用于取消订阅一个或多个频道。语法为：UNSUBSCRIBE [channel [channel\n    ...]]。例如，UNSUBSCRIBE news 取消订阅名为\"news\"的频道。\n 4. PSUBSCRIBE命令：用于模式订阅一个或多个匹配的频道。语法为：PSUBSCRIBE pattern [pattern\n    ...]。其中，pattern可以包含通配符。例如，PSUBSCRIBE news. 订阅了以\"news.\"开头的所有频道。\n 5. PUNSUBSCRIBE命令：用于取消模式订阅一个或多个匹配的频道。语法为：PUNSUBSCRIBE [pattern [pattern\n    ...]]。例如，PUNSUBSCRIBE news. 取消订阅以\"news.\"开头的所有频道。\n\n> 可以开两个cmd，一个做发布一个做订阅\n\n\n\n\n事务#\n\nRedis支持事务（Transaction），它允许用户将多个命令打包在一起作为一个单元进行执行。事务提供了一种原子性操作的机制，要么所有的命令都执行成功，要么\n所有的命令都不执行。\n\nRedis的事务使用MULTI、EXEC、WATCH和DISCARD等命令来管理。\n\n 1. MULTI命令：用于开启一个事务。在执行MULTI命令后，Redis会将接下来的命令都添加到事务队列中，而不是立即执行。\n 2. EXEC命令：用于执行事务中的所有命令。当执行EXEC命令时，Redis会按照事务队列中的顺序执行所有的命令。执行结果以数组的形式返回给客户端。\n 3. WATCH命令：用于对一个或多个键进行监视。如果在事务执行之前，被监视的键被修改了，事务将被中断，不会执行。\n 4. DISCARD命令：用于取消事务。当执行DISCARD命令时，所有在事务队列中的命令都会被清空，事务被取消。\n\n使用事务的基本流程如下：\n\n 1. 使用MULTI命令开启一个事务。\n 2. 将需要执行的命令添加到事务队列中。\n 3. 如果需要，使用WATCH命令监视键。\n 4. 执行EXEC命令执行事务。Redis会按照队列中的顺序执行命令，并返回执行结果。\n 5. 根据返回结果判断事务执行是否成功。\n\n事务中的命令在执行之前不会立即执行，而是在执行EXEC命令时才会被执行。这意味着事务期间的命令并不会阻塞其他客户端的操作，也不会中断其他客户端对键的读写操作。\n\n需要注意的是，Redis的事务不支持回滚操作。如果在事务执行期间发生错误，事务会继续执行，而不会回滚已执行的命令。因此，在使用Redis事务时，需要保证事务中的\n命令是幂等的，即多次执行命令的结果和一次执行的结果相同\n\n\n\n","routePath":"/guide/node/45-Redis( 发布订阅 + 事务 )","lang":"","toc":[{"text":"45-Redis( 发布订阅 + 事务 )","id":"45-redis-发布订阅--事务-","depth":2,"charIndex":-1},{"text":"发布订阅","id":"发布订阅","depth":3,"charIndex":24},{"text":"事务","id":"事务","depth":3,"charIndex":812}],"domain":"","frontmatter":{},"version":""},{"id":82,"title":"","content":"46-Redis( 持久化RDB AOF )#\n\n\nredis持久化#\n\nRedis提供两种持久化方式：\n\n 1. RDB（Redis\n    Database）持久化：RDB是一种快照的形式，它会将内存中的数据定期保存到磁盘上。可以通过配置Redis服务器，设置自动触发RDB快照的条件，比如在\n    指定的时间间隔内，或者在指定的写操作次数达到一定阈值时进行快照保存。RDB持久化生成的快照文件是一个二进制文件，包含了Redis数据的完整状态。在恢复数\n    据时，可以通过加载快照文件将数据重新加载到内存中。\n 2. AOF（Append-Only\n    File）持久化：AOF持久化记录了Redis服务器执行的所有写操作命令，在文件中以追加的方式保存。当Redis需要重启时，可以重新执行AOF文件中保存\n    的命令，以重新构建数据集。相比于RDB持久化，AOF持久化提供了更好的数据恢复保证，因为它记录了每个写操作，而不是快照的形式。然而，AOF文件相对于RD\n    B文件更大，恢复数据的速度可能会比较慢。\n\n\nRDB使用#\n\n打开redis配置文件\n\n\n\n找到save\n\n\n\n他提供了三个案例\n\n 1. 3600秒内也就是一小时进行一次改动就会触发快照\n 2. 300秒内也就是5分钟，进行100次修改就会进行快照\n 3. 60秒内一万次修改就会进行快照\n\n具体场景需要根据你的用户量，以及负载情况自己定义.\n\n\n\n其次就是可以通过命令行手动触发快照\n\n\n\n\nAOF使用#\n\n将 appendonly 配置项的值设置为 yes：默认情况下，该配置项的值为 no，表示未启用AOF持久化。将其值修改为 yes，以启用AOF持久化。\n\n","routePath":"/guide/node/46-Redis( 持久化RDB AOF )","lang":"","toc":[{"text":"46-Redis( 持久化RDB AOF )","id":"46-redis-持久化rdb-aof-","depth":2,"charIndex":-1},{"text":"redis持久化","id":"redis持久化","depth":3,"charIndex":25},{"text":"RDB使用","id":"rdb使用","depth":3,"charIndex":468},{"text":"AOF使用","id":"aof使用","depth":3,"charIndex":643}],"domain":"","frontmatter":{},"version":""},{"id":83,"title":"","content":"47-Redis( 主从复制 )#\n\nRedis主从复制是一种数据复制和同步机制，其中一个Redis服务器（称为主服务器）将其数据复制到一个或多个其他Redis服务器（称为从服务器）。主从复制提供了\n数据冗余备份、读写分离和故障恢复等功能。\n\n\n\n以下是Redis主从复制的一般工作流程：\n\n 1. 配置主服务器：在主服务器上，你需要在配置文件中启用主从复制并指定从服务器的IP地址和端口号。你可以使用replicaof配置选项或slaveof配置选项\n    来指定从服务器。\n 2. 连接从服务器：从服务器连接到主服务器并发送复制请求。从服务器通过发送SYNC命令请求进行全量复制或通过发送PSYNC命令请求进行部分复制（增量复制）。\n 3. 全量复制（SYNC）：如果从服务器是第一次连接或无法执行部分复制，主服务器将执行全量复制。在全量复制期间，主服务器将快照文件（RDB文件）发送给从服务器\n    ，从服务器将接收并加载该文件以完全复制主服务器的数据。\n 4. 部分复制（PSYNC）：如果从服务器已经执行过全量复制并建立了复制断点，主服务器将执行部分复制。在部分复制期间，主服务器将发送增量复制流（replica\n    tion stream）给从服务器，从服务器将接收并应用该流以保持与主服务器的同步。\n 5. 复制持久化：从服务器接收到数据后，会将其保存在本地磁盘上，以便在重启后仍然保持数据的一致性。\n 6. 同步延迟：从服务器的复制是异步的，因此存在复制延迟。延迟取决于网络延迟、主服务器的负载和从服务器的性能等因素。\n 7. 读写分离：一旦建立了主从复制关系，从服务器可以接收读操作。这使得可以将读流量从主服务器分散到从服务器上，从而减轻主服务器的负载。\n 8. 故障恢复：如果主服务器发生故障，可以将一个从服务器提升为新的主服务器，以继续提供服务。当主服务器恢复时，它可以作为从服务器连接到新的主服务器，继续进行数\n    据复制。\n\n\n修改配置文件#\n\n在根目录下面新建一个 redis-6378.conf 配置文件 作为redis从服务器,默认的配置文件6379作为主服务器\n\nredis-6378.conf 文件配置，配置文件名字随便取\n\n\n\n启动从服务器\n\n\n\n打开从服务器cli\n\n\n\n启动主服务器\n\n\n\n主服务器写入一个值\n\n\n\n从服务器直接同步过来这个值 就可以直接获取到\n\n> 注意从服务器是不允许写入的操作","routePath":"/guide/node/47-Redis( 主从复制 )","lang":"","toc":[{"text":"47-Redis( 主从复制 )","id":"47-redis-主从复制-","depth":2,"charIndex":-1},{"text":"修改配置文件","id":"修改配置文件","depth":3,"charIndex":832}],"domain":"","frontmatter":{},"version":""},{"id":84,"title":"","content":"48-Redis( ioredis )#\n\nioredis 是一个强大且流行的 Node.js 库，用于与 Redis 进行交互。Redis 是一个开源的内存数据结构存储系统。ioredis\n提供了一个简单高效的 API，供 Node.js 应用程序与 Redis 服务器进行通信。\n\n以下是 ioredis 的一些主要特点：\n\n 1. 高性能：ioredis 设计为快速高效。它支持管道操作，可以在一次往返中发送多个 Redis\n    命令，从而减少网络延迟。它还支持连接池，并且可以在连接丢失时自动重新连接到 Redis 服务器。\n 2. Promises 和 async/await 支持：ioredis 使用 promises，并支持 async/await 语法，使得编写异步代码和处理\n    Redis 命令更加可读。\n 3. 集群和 sentinel 支持：ioredis 内置支持 Redis 集群和 Redis Sentinel，这是 Redis\n    的高级功能，用于分布式设置和高可用性。它提供了直观的 API，用于处理 Redis 集群和故障转移场景。\n 4. Lua 脚本：ioredis 允许你使用 eval 和 evalsha 命令在 Redis 服务器上执行 Lua\n    脚本。这个功能使得你可以在服务器端执行复杂操作，减少客户端与服务器之间的往返次数。\n 5. 发布/订阅和阻塞命令：ioredis 支持 Redis 的发布/订阅机制，允许你创建实时消息系统和事件驱动架构。它还提供了对 BRPOP 和 BLPOP\n    等阻塞命令的支持，允许你等待项目被推送到列表中并原子地弹出它们。\n 6. 流和管道：ioredis 支持 Redis\n    的流数据类型，允许你消费和生成数据流。它还提供了一种方便的方式将多个命令进行管道化，减少与服务器之间的往返次数。\n\n\n使用方法#\n\n安装\n\n\n\n连接redis\n\n\n\n 1. 字符串\n\n\n\n 2. 集合\n\n\n\n 3. 哈希\n\n\n\n 4. 队列\n\n\n\n\n发布订阅#\n\n","routePath":"/guide/node/48-Redis( ioredis )","lang":"","toc":[{"text":"48-Redis(  ioredis )","id":"48-redis--ioredis-","depth":2,"charIndex":-1},{"text":"使用方法","id":"使用方法","depth":3,"charIndex":805},{"text":"发布订阅","id":"发布订阅","depth":3,"charIndex":871}],"domain":"","frontmatter":{},"version":""},{"id":85,"title":"","content":"49-lua( 安装-介绍 )#\n\n\nlua#\n\nLua是一种轻量级、高效、可嵌入的脚本语言，最初由巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de\nJaneiro）的一个小团队开发而成。它的名字\"Lua\"在葡萄牙语中意为\"月亮\"，寓意着Lua作为一门明亮的语言。\n\nLua具有简洁的语法和灵活的语义，被广泛应用于嵌入式系统、游戏开发、Web应用、脚本编写等领域。它的设计目标之一是作为扩展和嵌入式脚本语言，可以与其他编程语言无\n缝集成。Lua的核心只有很小的代码库，但通过使用模块和库可以轻松地扩展其功能。\n\n以下是一些关键特点和用途介绍：\n\n 1. 简洁高效：Lua的语法简单清晰，语义灵活高效。它使用动态类型和自动内存管理，支持面向过程和函数式编程风格，并提供了强大的协程支持。\n 2. 嵌入式脚本语言：Lua被设计为一种可嵌入的脚本语言，可以轻松地与其他编程语言集成。它提供了C\n    API，允许开发者将Lua嵌入到C/C++程序中，或者通过扩展库将Lua嵌入到其他应用程序中。\n 3. 游戏开发：Lua在游戏开发中广泛应用。许多游戏引擎（如Unity和Corona\n    SDK）都支持Lua作为脚本语言，开发者可以使用Lua编写游戏逻辑、场景管理和AI等。\n 4. 脚本编写：由于其简洁性和易学性，Lua经常被用作脚本编写语言。它可以用于编写各种系统工具、自动化任务和快速原型开发。\n 5. 配置文件：Lua的语法非常适合用作配置文件的格式。许多应用程序和框架使用Lua作为配置文件语言，因为它易于阅读、编写和修改。\n\n为了增强性能和扩展性，可以将Lua与Redis和Nginx结合使用。这种组合可以用于构建高性能的Web应用程序或API服务。\n\n 1. Redis：Redis是一个快速、高效的内存数据存储系统，它支持各种数据结构，如字符串、哈希、列表、集合和有序集合。与Lua结合使用，可以利用Redis\n    的高速缓存功能和Lua的灵活性来处理一些复杂的计算或数据查询。\n    * 缓存数据：使用Redis作为缓存存储，可以将频繁访问的数据存储在Redis中，以减轻后端数据库的负载。Lua可以编写与Redis交互的脚本，通过读取\n      和写入Redis数据来提高数据访问速度。\n    * 分布式锁：通过Redis的原子性操作和Lua的脚本编写能力，可以实现分布式锁机制，用于解决并发访问和资源竞争的问题。\n 2. Nginx：Nginx是一个高性能的Web服务器和反向代理服务器。它支持使用Lua嵌入式模块来扩展其功能。\n    * 请求处理：使用Nginx的Lua模块，可以编写Lua脚本来处理HTTP请求。这使得可以在请求到达应用程序服务器之前进行一些预处理、身份验证、请求路由\n      等操作，从而减轻后端服务器的负载。\n    * 动态响应：通过结合Lua和Nginx的subrequest机制，可以实现动态生成响应。这对于根据请求参数或其他条件生成动态内容非常有用。\n    * 访问控制：使用Lua脚本，可以在Nginx层面对访问进行细粒度的控制，例如IP白名单、黑名单、请求频率限制等。\n\n\n安装#\n\nlua官网\n\n\n\n\n\n\n\n选择对应的平台下载就好\n\n\n\n下载完成，解压到文件夹，将文件夹路径配置环境变量即可\n\n使用lua54 测试一下\n\n\n\n\nvscode支持#\n\n找到扩展安装以下两个插件\n\n\n\n调试代码\n\n","routePath":"/guide/node/49-lua( 安装-介绍 )","lang":"","toc":[{"text":"49-lua( 安装-介绍 )","id":"49-lua-安装-介绍-","depth":2,"charIndex":-1},{"text":"lua","id":"lua","depth":3,"charIndex":18},{"text":"安装","id":"安装","depth":3,"charIndex":1353},{"text":"vscode支持","id":"vscode支持","depth":3,"charIndex":1431}],"domain":"","frontmatter":{},"version":""},{"id":86,"title":"","content":"5-npx#\n\n\nnpx 是什么#\n\nnpx是一个命令行工具，它是npm 5.2.0 版本中新增的功能。它允许用户在不安装全局包的情况下，运行已安装在本地项目中的包或者远程仓库中的包。\n\nnpx的作用是在命令行中运行 node 包中的可执行文件，而无需全局安装这些包\n\n这可以使开发人员更轻松地管理包的依赖关系，并且可以避免全局污染的问题。\n\n它还可以帮助开发人员在项目中使用不同版本的包，而不会出现版本冲突的问题。\n\nnpx 的优势\n\n 1. 避免全局安装：npx允许你执行npm package，而不需要你先全局安装它。\n 2. 总是使用最新版本：如果你没有在本地安装相应的npm package，npx会从npm的package仓库中下载并使用最新版。\n 3. 执行任意npm包：npx不仅可以执行在package.json的scripts部分定义的命令，还可以执行任何npm package。\n 4. 执行 GitHub gist：npx甚至可以执行GitHub gist或者其他公开的JavaScript文件。\n\n\nnpm 和 npx 区别#\n\nnpx侧重于执行命令的，执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令\n\nnpm侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。\n\n\n示例 1#\n\ncreate-react-app.bootcss.com/docs/gettin…\n\n\n\n例如创建一个 react 项目 在之前需要安装到全局\n\n\n\n然后执行 create-react-app my-app这样的话会有两个问题\n\n * 首先需要全局安装这个包占用磁盘空间\n * 并且如果需要更新还得执行更新命令\n\n如果使用npx命令就不会有上面的问题了\n\n\n示例 2#\n\n查看全局安装的包\n\n\n\n\n\n> 我全局并没有安装vite\n\n当前项目安装vite\n\n\n\n安装完成之后发现无法执行运行vite命令\n\n\n\n这时候就可以使用npx vite 了\n\n\n\nnpx的运行规则和npm是一样的\n\n本地目录查找.bin看有没有 如果没有就去全局的 node_moduels 查找\n\n如果还没有就去下载这个包，然后运行命令，然后删除这个包","routePath":"/guide/node/5-npx","lang":"","toc":[{"text":"5-npx","id":"5-npx","depth":2,"charIndex":-1},{"text":"npx 是什么","id":"npx-是什么","depth":3,"charIndex":8},{"text":"npm 和 npx 区别","id":"npm-和-npx-区别","depth":3,"charIndex":462},{"text":"示例 1","id":"示例-1","depth":3,"charIndex":-1},{"text":"示例 2","id":"示例-2","depth":3,"charIndex":746}],"domain":"","frontmatter":{},"version":""},{"id":87,"title":"","content":"50-lua( lua的基本使用 )#\n\n\nlua基本使用#\n\n全局变量局部变量\n\n * 全局变量是在全局作用域中定义的变量，可以在脚本的任何地方访问。\n * 全局变量在定义时不需要使用关键字，直接赋值即可。\n\n\n\n * 局部变量是在特定作用域内定义的变量，只能在其所属的作用域内部访问。\n * 局部变量的作用域通常是函数体内部，也可以在代码块（使用 do...end）中创建局部变量。\n * 在局部作用域中，可以通过简单的赋值语句定义局部变量。\n\n\n\n条件语句\n\n在Lua中，条件判断语句可以使用 if、elseif 和 else 关键字来实现\n\n\n\n函数\n\n在Lua中，函数是一种可重复使用的代码块，用于执行特定的任务或操作\n\n\n\n\n数据类型#\n\n 1. nil：表示无效值或缺失值。\n 2. boolean：表示布尔值，可以是 true 或 false。\n 3. number：表示数字，包括整数和浮点数。\n 4. string：表示字符串，由字符序列组成。\n 5. table：表示表，一种关联数组，用于存储和组织数据。\n 6. function：表示函数，用于封装可执行的代码块。\n 7. userdata：表示用户自定义数据类型，通常与C语言库交互使用。\n 8. thread：表示协程，用于实现多线程编程。\n 9. metatable：表示元表，用于定义表的行为。\n\n常用数据类型用法\n\n\n\n字符串拼接 ..\n\n\n\ntable 可以描述 对象和数组\n\n> lua索引从1开始\n\n\n\n循环\n\n\n\n循环table\n\n\n\n循环数组\n\n\n\n\n模块化#\n\ntest.lua 暴露一个方法add\n\n\n\nindex.lua 引入该文件调用add方法\n\n","routePath":"/guide/node/50-lua( 基本使用 )","lang":"","toc":[{"text":"50-lua( lua的基本使用 )","id":"50-lua-lua的基本使用-","depth":2,"charIndex":-1},{"text":"lua基本使用","id":"lua基本使用","depth":3,"charIndex":21},{"text":"数据类型","id":"数据类型","depth":3,"charIndex":318},{"text":"模块化","id":"模块化","depth":3,"charIndex":673}],"domain":"","frontmatter":{},"version":""},{"id":88,"title":"","content":"抽奖","routePath":"/guide/node/51-lua + Redis( 限流阀 )","lang":"","toc":[{"text":"51-lua + Redis( 限流阀 )","id":"51-lua--redis-限流阀-","depth":2,"charIndex":-1},{"text":"限流功能","id":"限流功能","depth":3,"charIndex":-1},{"text":"安装依赖","id":"安装依赖","depth":3,"charIndex":-1},{"text":"代码编写","id":"代码编写","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":89,"title":"","content":"52-定时任务( 自动签到 )#\n\n\n什么是定时任务？#\n\n定时任务是指在预定的时间点或时间间隔内执行的任务或操作。它们是自动化执行特定逻辑的一种方式，可用于执行重复性的、周期性的或计划性的任务。\n\n定时任务通常用于以下情况：\n\n 1. 执行后台任务：定时任务可用于自动执行后台任务，如数据备份、日志清理、缓存刷新等。通过设定适当的时间点或时间间隔，可以确保这些任务按计划进行，而无需手动干\n    预。\n 2. 执行定期操作：定时任务可用于执行定期操作，如发送电子邮件提醒、生成报告、更新数据等。通过设定适当的时间点，可以自动触发这些操作，提高效率并减少人工操作的\n    需求。\n 3. 调度任务和工作流：定时任务可以用于调度和协调复杂的任务和工作流程。通过设置任务之间的依赖关系和执\n\n\n安装依赖#\n\n\n\nnode-schedule官方文档，request调用接口\n\n> 一般定时任务都是用cron表达式去表示时间的\n\n\ncron表达式#\n\nCron表达式是一种用于指定定时任务执行时间的字符串表示形式。它由6个或7个字段组成，每个字段表示任务执行的时间单位和范围。\n\nCron表达式的典型格式如下：\n\n\n\n域               是否必需   取值范围                                             特殊字符\n秒 Seconds       是      [0, 59]                                          * , - /\n分钟 Minutes      是      [0, 59]                                          * , - /\n小时 Hours        是      [0, 23]                                          * , - /\n日期 DayofMonth   是      [1, 31]                                          * , - / ? L W\n月份 Month        是      [1, 12]或[JAN, DEC]                               * , - /\n星期 DayofWeek    是      [1, 7]或[MON, SUN]。若使用[1, 7]表达方式，1代表星期一，7代表星期日。   * , - / ? L #\n年 Year          否      1970+                                            - * /\n\n每个字段可以接受特定的数值、范围、通配符和特殊字符来指定任务的执行时间：\n\n * 数值：表示具体的时间单位，如1、2、10等。\n * 范围：使用-连接起始和结束的数值，表示一个范围内的所有值，如1-5表示1到5的所有数值。\n * 通配符：使用*表示匹配该字段的所有可能值，如*表示每分钟、每小时、每天等。\n * 逗号分隔：使用逗号分隔多个数值或范围，表示匹配其中任意一个值，如1,3表示1或3。\n * 步长：使用/表示步长，用于指定间隔的数值，如*/5表示每隔5个单位执行一次。\n * 特殊字符：Cron表达式还支持一些特殊字符来表示特定的含义，如?用于替代日和星期字段中的任意值，L表示最后一天，W表示最近的工作日等。\n\n以下是一些常见的Cron表达式示例：\n\n * * * * * *：每分钟执行一次任务。\n * 0 * * * *：每小时的整点执行一次任务。\n * 0 0 * * *：每天的午夜执行一次任务。\n * 0 0 * * 1：每周一的午夜执行一次任务。\n * 0 0 1 * *：每月的1号午夜执行一次任务。\n * 0 0 1 1 *：每年的1月1日午夜执行一次任务。\n\n\n代码编写(掘金自动签到)#\n\n\n\nconfig.js\n\n\n\n运行，在这我设置每秒调用，所以返回重复签到了\n\n\n\n> aid和uid可以在掘金网页f12中网络随便一个接口都有显示，cookie可以通过f12应用查看\n\n查看是否签到成功，发现成功\n\n","routePath":"/guide/node/52-定时任务( 自动签到 )","lang":"","toc":[{"text":"52-定时任务( 自动签到 )","id":"52-定时任务-自动签到-","depth":2,"charIndex":-1},{"text":"什么是定时任务？","id":"什么是定时任务","depth":3,"charIndex":18},{"text":"安装依赖","id":"安装依赖","depth":3,"charIndex":346},{"text":"cron表达式","id":"cron表达式","depth":3,"charIndex":413},{"text":"代码编写(掘金自动签到)","id":"代码编写掘金自动签到","depth":3,"charIndex":1650}],"domain":"","frontmatter":{},"version":""},{"id":90,"title":"","content":"53-serverLess( 云函数 )#\n\n\n什么是serverLess?#\n\nserverLess并不是一个技术，他只是一种架构模型，(无服务器架构)，在传统模式下，我们部署一个服务，需要选择服务器Linux,windows等,并且还要安\n装环境，熟悉操作系统命令，知晓安全知识等，有一定成本，serverLess，核心思想就是，让开发者更多的是关注业务本身，而不是服务器运行成本。\n\n\nFaaS与BaaS#\n\n 1. 函数即服务（FaaS）：\n    FaaS是一种Serverless计算模型，它允许开发人员编写和部署函数代码，而无需关心底层的服务器管理。在FaaS中，开发人员只需关注函数的实现和逻辑\n    ，将其上传到云平台上，平台会负责函数的运行和扩展。当有请求触发函数时，云平台会自动为函数提供所需的计算资源，并根据请求量进行弹性扩展。这种按需计算的模式\n    使开发人员可以更专注于业务逻辑的实现，同时实现了资源的高效利用。\n\n> 每个函数即一个服务，函数内只需处理业务，可以使用BASS层提供的服务已完成业务，无需关心背后计算资源的问题。\n\n 2. 后端即服务（BaaS）：\n    后端即服务是一种提供面向移动应用和Web应用的后端功能的云服务模型。BaaS为开发人员提供了一组预构建的后端服务，如用户身份验证、数据库存储、文件存储、\n    推送通知等，以简化应用程序的开发和管理。开发人员可以使用BaaS平台提供的API和SDK，直接集成这些功能到他们的应用中，而无需自己构建和维护后端基础设\n    施。\n\n> 对后端的资源当成一种服务，如文件存储，数据存储，推送服务，身份验证。该层只需提供对应的服务，无需关心业务。定义为底层基础服务，由其他服务调用，正常不触及用户\n> 终端。\n\n\n编写serverLess云函数#\n\n安装依赖\n\n\n\n@serverless-devs/s文档\n\nServerless Devs 是一个开源开放的 Serverless 开发者平台，致力于为开发者提供强大的工具链体系。通过该平台，开发者不仅可以一键体验多云\nServerless 产品，极速部署 Serverless 项目，还可以在 Serverless 应用全生命周期进行项目的管理，并且非常简单快速的将\nServerless Devs 与其他工具/平台进行结合，进一步提升研发、运维效能。\n\n 1. 配置密钥\n\n我们需要选择一款云产品，这里用阿里云演示，当然你也可以用别的。\n\n访问旁边链接，登录阿里云，RAM控制\n\n\n\n 2. 添加密钥\n\ns命令 你安装完成 @serverless-devs/s 这个之后就有了\n\n\n\n\n\n选择阿里云 输入刚才的 AccessKeyID AccessKeySecret 第三个是个别名可以自定义\n\n\n\n检查密钥是否正确,能输出信息就是对的\n\n\n\n\n\n 3. 创建项目\n\n直接运行s命令即可，根据下图创建\n\n\n\n\n\n打开生成好的项目，在目录下执行s deploy,上传成功\n\n\n\n访问此链接即可找到函数，如果没有就找到你所选的服务器地区\n\n\n\n","routePath":"/guide/node/53-serverLess( 云函数 )","lang":"","toc":[{"text":"53-serverLess( 云函数 )","id":"53-serverless-云函数-","depth":2,"charIndex":-1},{"text":"什么是serverLess?","id":"什么是serverless","depth":3,"charIndex":23},{"text":"FaaS与BaaS","id":"faas与baas","depth":3,"charIndex":195},{"text":"编写serverLess云函数","id":"编写serverless云函数","depth":3,"charIndex":758}],"domain":"","frontmatter":{},"version":""},{"id":91,"title":"","content":"54-net#\n\nnet模块是Node.js的核心模块之一，它提供了用于创建基于网络的应用程序的API。net模块主要用于创建TCP服务器和TCP客户端，以及处理网络通信。\n\n\n\nTCP（Transmission Control\nProtocol）是一种面向连接的、可靠的传输协议，用于在计算机网络上进行数据传输。它是互联网协议套件（TCP/IP）的一部分，是应用层和网络层之间的传输层协议\n。\n\nTCP的主要特点包括：\n\n 1. 可靠性：TCP通过使用确认机制、序列号和重传策略来确保数据的可靠传输。它可以检测并纠正数据丢失、重复、损坏或失序的问题。\n 2. 面向连接：在进行数据传输之前，TCP需要在发送方和接收方之间建立一个连接。连接的建立是通过三次握手来完成的，确保双方都准备好进行通信。\n 3. 全双工通信：TCP支持双方同时进行双向通信，即发送方和接收方可以在同一时间发送和接收数据。\n 4. 流式传输：TCP将数据视为连续的字节流进行传输，而不是离散的数据包。发送方将数据划分为较小的数据块，但TCP在传输过程中将其作为连续的字节流处理。\n 5. 拥塞控制：TCP具备拥塞控制机制，用于避免网络拥塞和数据丢失。它通过动态调整发送速率、使用拥塞窗口和慢启动算法等方式来控制数据的发送速度。\n\n\n场景#\n\n服务端之间的通讯#\n\n服务端之间的通讯可以直接使用TCP通讯，而不需要上升到http层\n\nserver.js\n\n创建一个TCP服务，并且发送套接字，监听端口号3000\n\n\n\nclient.js\n\n连接server端，并且监听返回的数据\n\n\n\n传输层实现http协议#\n\n创建一个TCP服务\n\n\n\nnet.createServer创建 Unix 域套接字并且返回一个server对象接受一个回调函数\n\nsocket可以监听很多事件\n\n 1. close 一旦套接字完全关闭就触发\n 2. connect 当成功建立套接字连接时触发\n 3. data 接收到数据时触发\n 4. end 当套接字的另一端表示传输结束时触发，从而结束套接字的可读端\n\n通过node http.js 启动之后我们使用浏览器访问一下，打不开，但控制台输出了如下\n\n\n\n可以看到浏览器发送了一个http get 请求 我们可以通过关键字get 返回相关的内容例如html\n\n\n\n这时我们再访问localhost:3000就会有信息了\n\n","routePath":"/guide/node/54-net","lang":"","toc":[{"text":"54-net","id":"54-net","depth":2,"charIndex":-1},{"text":"场景","id":"场景","depth":3,"charIndex":552},{"text":"服务端之间的通讯","id":"服务端之间的通讯","depth":4,"charIndex":557},{"text":"传输层实现http协议","id":"传输层实现http协议","depth":4,"charIndex":678}],"domain":"","frontmatter":{},"version":""},{"id":92,"title":"","content":"55-socket.io#","routePath":"/guide/node/55-socket.io","lang":"","toc":[{"text":"55-socket.io","id":"55-socketio","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":93,"title":"","content":"6-发布 npm 包#\n\n\n发布 npm 的包的好处是什么#\n\n * 方便团队或者跨团队共享代码，使用 npm 包就可以方便的管理，并且还可以进行版本控制\n * 做开源造轮子必备技术，否则你做完的轮子如何让别人使用，难道是 U 盘拷贝？\n * 面试很经常问到\n * 增加个人 IP让更多的人知道你的技术能力和贡献\n\n\n发布前准备工作#\n\n\n\n首先先检查一下是否是 npm 源然后创建一个 npm 账号\n\n\n\n> 创建完成之后使用 npm login 登录账号\n\n\n\n登录完成之后使用npm publish 发布 npm 包\n\n\n\n发布成功，如果出现 403 说明包名被占用了","routePath":"/guide/node/6-发布npm包","lang":"","toc":[{"text":"6-发布 npm 包","id":"6-发布-npm-包","depth":2,"charIndex":-1},{"text":"发布 npm 的包的好处是什么","id":"发布-npm-的包的好处是什么","depth":3,"charIndex":13},{"text":"发布前准备工作","id":"发布前准备工作","depth":3,"charIndex":158}],"domain":"","frontmatter":{},"version":""},{"id":94,"title":"","content":"7-搭建 npm 私服#\n\n\n构建 npm 私服#\n\n构建私服有什么收益吗？\n\n * 可以离线使用，你可以将npm 私服部署到内网集群，这样离线也可以访问私有的包。\n * 提高包的安全性，使用私有的 npm 仓库可以更好的管理你的包，避免在使用公共的 npm 包的时候出现漏洞。\n * 提高包的下载速度，使用私有 npm 仓库，你可以将经常使用的 npm\n   包缓存到本地，从而显著提高包的下载速度，减少依赖包的下载时间。这对于团队内部开发和持续集成、部署等场景非常有用\n\n\n如何搭建 npm 私服#\n\nverdaccio.org/zh-CN/\n\nVerdaccio 是可以帮我们快速构建 npm 私服的一个工具\n\n\n\n使用方式非常简单，直接运行命令verdaccio即可\n\n> 可以通过verdaccio --help查看配置\n\n\n\n然后访问 4873 默认端口即可\n\n\n\n如果不是中文，点击设置切换为中文简体即可\n\n\n\n\n基本命令#\n\n\n\n其他配置文件项\n\nverdaccio.org/zh-CN/docs/…","routePath":"/guide/node/7-搭建npm私服","lang":"","toc":[{"text":"7-搭建 npm 私服","id":"7-搭建-npm-私服","depth":2,"charIndex":-1},{"text":"构建 npm 私服","id":"构建-npm-私服","depth":3,"charIndex":14},{"text":"如何搭建 npm 私服","id":"如何搭建-npm-私服","depth":3,"charIndex":238},{"text":"基本命令","id":"基本命令","depth":3,"charIndex":413}],"domain":"","frontmatter":{},"version":""},{"id":95,"title":"","content":"8-模块化(cjs、esm、源码)#\n\nNodejs 模块化规范遵循两套：CommonJS规范和ESM规范\n\n\nCommonJS 规范#\n\n注意：需要通过npm init -y生成package.json，在该文件中添加或修改一个属性\"type\":\"commonjs\"，如下图\n\n\n\n引入模块（require）支持五种格式\n\n * 支持引入自己编写的模块 ./ ../ 等\n\n * 支持引入第三方模块express md5 koa 等\n\n * 支持引入内置模块例如 http os fs child_process 等nodejs内置模块\n   \n   > 高版本 nodejs 引入需要这样写node:模块名，低版本直接写模块名即可\n\n * 支持引入addon.node 等 C++扩展模块 .node文件\n\n * 支持引入json文件\n\n\n\n导出模块exports 和 module.exports\n\n\n\n如果不想导出对象，可以直接导出值\n\n\n\n\nESM 模块规范#\n\n引入模块 import 必须写在头部\n\n> 注意使用 ESM 模块的时候需要打开 package.json 设置\"type\":\"module\"\n\n\n\n> 如果要引入 json 文件需要特殊处理 需要增加断言并且指定类型 json，node 低版本不支持\n\n\n\n可以加载模块的不同导出\n\n\n\n加载，并可以起别名\n\n\n\n加载模块的整体对象\n\n\n\n动态导入模块\n\nimport 静态加载不支持掺杂在逻辑中，如果想动态加载请使用 import 函数模式\n\n\n\n模块导出\n\n * 导出一个默认对象export default，default 只能有一个不可重复\n\n\n\n * 导出变量\n\n\n\n\nCjs 和 ESM 的区别#\n\n 1. Cjs是基于运行时的同步加载，ESM是基于编译时的异步加载\n\n 2. Cjs是可以修改值的，ESM值并且不可修改（可读的）\n\n 3. Cjs不可以 Tree shaking，ESM支持 Tree shaking\n    \n    > Tree shaking 是一个用于在打包过程中去除未使用代码（dead code）的技术，它可以有效地减小最终生成的 JavaScript\n    > 文件的大小。\n\n 4. Cjs中顶层的this指向这个模块本身，而 ES6 中顶层this指向undefined\n\n\nnodejs 部分源码解析#\n\n可以去官网下载源代码\n\n.json 文件如何处理#\n\n> 文件在modules目录下的cjs下的loader.js\n\n使用fs读取 json 文件读取完成之后是个字符串，然后JSON.parse变成对象返回\n\n\n\n.node 文件如何处理#\n\n发现是通过 process.dlopen 方法处理.node 文件\n\n\n\n.js 文件如何处理#\n\n\n\n如果缓存过这个模块就直接从缓存中读取，如果没有缓存就从fs读取文件\n\n判断如果是cjs但是type为module就报错，并且从父模块读取详细的行号进行报错，如果没问题就调用 compile\n\n\n\n首先，它检查是否存在安全策略对象 policy.manifest，如果存在，表示有安全策略限制需要处理 将函数将模块文件名转换为 URL\n格式，redirects是一个 URL\n映射表，用于处理模块依赖关系，manifest则是一个安全策略对象，用于检测模块的完整性和安全性，然后调用wrapSafe\n\n\n\nwrapSafe调用了wrap方法\n\n\n\nwrap方法，发现就是把我们的代码包装到一个函数里面\n\n\n\n然后继续看wrapSafe函数，发现把返回的字符串即包装之后的代码放入nodejs 虚拟机里面Script，看有没有动态 import\n去加载，最后返回执行后的结果\n\n然后继续看**_compile**，获取到wrapSafe返回的函数，通过Reflect.apply调用因为要填充五个参数[exports, require,\nmodule, filename, dirname],最后返回执行完的结果","routePath":"/guide/node/8-模块化(cjs、esm、源码)","lang":"","toc":[{"text":"8-模块化(cjs、esm、源码)","id":"8-模块化cjsesm源码","depth":2,"charIndex":-1},{"text":"CommonJS 规范","id":"commonjs-规范","depth":3,"charIndex":55},{"text":"ESM 模块规范","id":"esm-模块规范","depth":3,"charIndex":425},{"text":"Cjs 和 ESM 的区别","id":"cjs-和-esm-的区别","depth":3,"charIndex":727},{"text":"nodejs 部分源码解析","id":"nodejs-部分源码解析","depth":3,"charIndex":1000}],"domain":"","frontmatter":{},"version":""},{"id":96,"title":"","content":"9-全局变量 & 全局 API#\n\n\n全局变量#\n\n如何在nodejs定义全局变量呢？\n\n在nodejs中使用global定义全局变量，新建文件index.js\n\n\n\n创建文件child.js，运行会输出全局变量\n\n\n\n> 注意 require 引入 child 文件需要在定义变量后，否则会访问到 undefined\n\n在浏览器中我们定义的全局变量都在window，nodejs在global，不同的环境还需要判断，于是在 ECMAScript 2020\n出现了一个**globalThis**全局变量，在nodejs环境自动切换global，浏览器环境自动切换window，非常方便\n\n\n\n\n关于其他全局 API#\n\n> nodejs 中没有 DOM 和 BOM，除了这些 API，其他的 ECMAscriptAPI 基本都能用\n\n例如下面，这些 API 都是可以正常用的\n\n\n\n\nnodejs 内置全局 API#\n\n__dirname#\n\n它表示当前模块的所在目录的绝对路径\n\n\n\n__filename#\n\n它表示当前模块文件的绝对路径，包括文件名和文件扩展名\n\n\n\nrequire module#\n\n\n\n引入模块和模块导出上一章已经详细讲过了\n\nprocess#\n\n 1. process.argv: 这是一个包含命令行参数的数组。第一个元素是 Node.js 的执行路径，第二个元素是当前执行的 JavaScript\n    文件的路径，之后的元素是传递给脚本的命令行参数\n 2. process.env: 这是一个包含当前环境变量的对象。您可以通过process.env访问并操作环境变量\n 3. process.cwd(): 这个方法返回当前工作目录的路径\n 4. process.on(event, listener):\n    用于注册事件监听器。您可以使用process.on监听诸如exit、uncaughtException等事件，并在事件发生时执行相应的回调函数\n 5. process.exit([code]): 用于退出当前的 Node.js 进程。您可以提供一个可选的退出码作为参数\n 6. process.pid: 这个属性返回当前进程的PID（进程 ID）\n\n这些只是process对象的一些常用属性和方法，还有其他许多属性和方法可用于监控进程、设置信号处理、发送 IPC 消息等\n\n需要注意的是，process对象是一个全局对象，可以在任何模块中直接访问，无需导入或定义\n\nBuffer#\n\n 1. 创建 Buffer 实例：\n    * Buffer.alloc(size[, fill[, encoding]]):\n      创建一个指定大小的新的Buffer实例，初始内容为零。fill参数可用于填充缓冲区，encoding参数指定填充的字符编码\n    * Buffer.from(array): 创建一个包含给定数组的Buffer实例\n    * Buffer.from(string[, encoding]): 创建一个包含给定字符串的Buffer实例\n 2. 读取和写入数据：\n    * buffer[index]: 通过索引读取或写入Buffer实例中的特定字节\n    * buffer.length: 获取Buffer实例的字节长度\n    * buffer.toString([encoding[, start[, end]]]): 将Buffer实例转换为字符串\n 3. 转换数据：\n    * buffer.toJSON(): 将Buffer实例转换为JSON 对象\n    * buffer.slice([start[, end]]): 返回一个新的Buffer实例，其中包含原始Buffer实例的部分内容\n 4. 其他方法：\n    * Buffer.isBuffer(obj): 检查一个对象是否是Buffer实例\n    * Buffer.concat(list[, totalLength]): 将一组Buffer实例或字节数组连接起来形成一个新的Buffer实例\n\n请注意，从Node.js\n6.0版本开始，Buffer构造函数的使用已被弃用，推荐使用Buffer.alloc()、Buffer.from()等方法来创建Buffer实例\n\nBuffer类在处理文件、网络通信、加密和解密等操作中非常有用，尤其是在需要处理二进制数据时","routePath":"/guide/node/9-全局变量和全局API","lang":"","toc":[{"text":"9-全局变量 & 全局 API","id":"9-全局变量--全局-api","depth":2,"charIndex":-1},{"text":"全局变量","id":"全局变量","depth":3,"charIndex":18},{"text":"关于其他全局 API","id":"关于其他全局-api","depth":3,"charIndex":297},{"text":"nodejs 内置全局 API","id":"nodejs-内置全局-api","depth":3,"charIndex":392},{"text":"__dirname","id":"__dirname","depth":4,"charIndex":410},{"text":"__filename","id":"__filename","depth":4,"charIndex":443},{"text":"require module","id":"require-module","depth":4,"charIndex":486},{"text":"process","id":"process","depth":4,"charIndex":526},{"text":"Buffer","id":"buffer","depth":4,"charIndex":1055}],"domain":"","frontmatter":{},"version":""},{"id":97,"title":"","content":"Node#\n\n本章你将学习到 Node 的相关知识","routePath":"/guide/node/","lang":"","toc":[{"text":"Node","id":"node","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":98,"title":"","content":"React 进阶篇#\n\n这是接下来进阶篇的学习目标","routePath":"/guide/react/advance/","lang":"","toc":[{"text":"React 进阶篇","id":"react-进阶篇","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":99,"title":"","content":"属性默认值和类型验证#\n\n在Vue中，我们可以针对props属性进行类型验证，那么在React中同样也能对props进行验证。\n\n> 官网文档地址: https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html\n\n从React v15.5开始，React.PropTypes已移入另一个包中。因此首先我们需要安装prop-types库。\n\n> prop-types 库文档地址: https://www.npmjs.com/package/prop-types\n\n有关props验证这一块，我们主要需要搞清楚以下几个知识点:\n\n * 提供了哪些验证类型\n * 如何设置默认值\n\n\n验证类型#\n\n有关props能够验证的类型，官网实际上已经全部罗列出来了。\n\n> 对应地址:\n> https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html#proptypes\n\n下面是一个简单示例。 在根组件中我们使用到了子组件，并向子组件传递了name和age这两个props属性:\n\n\n\n在子组件中，我们针对props做了类型的限制，要求name为string 类型，age为number类型:\n\n\n\n如果官方为你提供的验证规则不够用?没关系，我们还可以自定义验证器，它在验证失败时应返回一个Error对象。例如：\n\n\n\n另外，针对props是数组或者对象时，如果要验证的不仅仅是否是数组或对象类型，而是要验证数组和对象的每项，那么可以使用arrayOf或objectOf验证器。\n\n例如，我们现在有一个需求，要求数组的每一项为数字， 验证器示例如下:\n\n\n\n子组件下面的props是无法通过验证的：\n\n\n\nscore对应的数组值每一项都应为number类型，以下的用法能够通过验证：\n\n\n\n\n插槽的验证#\n\nReact的插槽也通过props来实现\n\n针对插槽，使用prop-types 可以进行插槽元素的单一验证，例如：\n\n\n\n在上面的示例中，我们为ChildCom设置了一个插槽，并且设置了一个验证，要求父组件在使用ChildCom子组件时，必须要插入一个根元素。\n\n以下的使用方式无法通过验证:\n\n\n\n\n\n以下的使用可以通过验证：\n\n\n\n\n默认值#\n\nprops属性还可以设置默认值，这一点官网已经有了很好的示例，请参阅：\n\n> 官网地址：默认Prop值","routePath":"/guide/react/advance/第一章/1-属性默认值和类型验证","lang":"","toc":[{"text":"属性默认值和类型验证","id":"属性默认值和类型验证","depth":2,"charIndex":-1},{"text":"验证类型","id":"验证类型","depth":3,"charIndex":324},{"text":"插槽的验证","id":"插槽的验证","depth":3,"charIndex":810},{"text":"默认值","id":"默认值","depth":3,"charIndex":986}],"domain":"","frontmatter":{},"version":""},{"id":100,"title":"","content":"高阶组件#\n\n高阶组件英语全称为 Higher-Order Components，简称 HOC，所谓高阶组件，是 React 中一种复用逻辑的技巧。\n高阶组件的学习，主要有下面2个点：\n\n * 认识到高阶组件并非一个组件，而是增强组件功能的一个函数\n * 高阶组件的作用是对多组件公共逻辑进行横向抽离\n\n\n高阶组件是一个函数#\n\n这个点非常有意思，很多人一看到这个名字，自然到会认为高阶组件是一个组件，但是名字往往具有欺骗性，就像javascript和java相关一样\n\n官方对高阶组件给出了很明确的定义，甚至还给了一个公式\n\n> 高阶组件是参数为组件，返回值为新组件的函数。\n\n\n高阶组件要做的事情#\n\n高阶组件作为一个函数，接收你传入的组件。然后又返回一个新组件给你，那你猜都猜得到在高阶组件的内部肯定是对你原有的组件做了一些增强操作，然后为你返回的是增强后的组\n件。\n\n那什么又叫做对组件公共逻辑进行横向抽离呢？看下图：\n\n\n\n假设我们这里有三个组件，每个组件有一部分公共逻辑，一部分该组件自身的业务逻辑，那么很明显每个组件都书写遍这样的公共逻辑是不划算的。\n\n作为一个程序员，我们自然而然想到的就是将这部分公共逻辑提取出来。\n\n早期的React采用的是mixins 来解决这种横切关注点相关的问题。Mixins 的原理可以简单理解为将一个mixin对象上的方法增加到组件上。\n\n\n\n眼熟不?没错，在Vue2.x中也支持mixins这样的混合注入。\n\n不过这只能在React的旧语法React.createClasss 中使用，目前已经不再推荐使用了。\n\n> mixins 问题\n> \n>  * mixins 引入了隐式的依赖关系\n> \n> 你可能会写一个有状态的组件，然后你的同事可能添加一个读取这个组件state的mixin。几个月之后，你可能希望将该state移动到父组件，以便与其兄弟组件共\n> 享。你会记得更新这个mixin来读取props而不是state吗?如果此时，其它组件也在使用这个mixin呢?\n> \n>  * mixins 引起名称冲突\n> \n> 无法保证两个特定的mixin可以一起使用。例如，如果 FluxListenerMixin 和 WindowSizeMixin\n> 都定义来handleChange(),则不能一起使用它们。同时，你也无法在自己的组件上定义具有此名称的方法。\n> \n>  * mixins 导致滚雪球式的复杂性\n> \n> 每一个新的需求都使mixins更难理解。使用相同mixin的组件会随着时间的推移变得越来越耦合。任何新功能都可以使用mixins添加到所有组件中。渐渐地，封\n> 装边界被侵蚀了，由于很难更改或删除现有的mixins,它们变得越来越抽象，直到没有人理解它们是如何工作的。\n> \n> 关于 mixins\n> 的讨论，参考官网：https://zh-hans.reactjs.org/blog/2016/07/13/mixins-considered-harmful\n> .html\n\n之后 React 推出了高阶组件的抽离方式，如下：\n\n\n\n在高阶组件中，接收一个组件作为参数，然后在高阶组件中会返回一一个新组件，新组件中会将公共逻辑附加上去，传入的组件一般作为新组件的视图。\n\n下面举个具体例子：\n\n\n\n\n\n上面的代码中，我们有两个子组件，父组件在使用这两个子组件时，一个需要传入name,另一个需要传入age\n\n正常来讲，父组件使用子组件的方式如下:\n\n\n\n但是现在我们新增了一个需求，\n那就是每个子组件需要记录创建和销毁时的日志。很显然，对于每个子组件来讲，日志相关的逻辑都是相同的，也就算是公共逻辑，没有必要在每个组件中引入一份，因此这里我们来\n使用HOC的方式抽离这一段公共逻辑， 如下:\n\n\n\n在上面的高阶组件中，唯一需要注意的就是返回的新组件在接受了props后，一般需要原封不动的传递给原来的组件。\n\n有了这个高阶组件后，我们就可以对原有的子组件进行加强，如下:\n\n\n\n高阶组件还可以进行嵌套操作，比如我有两段公共逻辑，但是这两段公共逻辑写在一个高阶组件中又不太合适，因此我们就可以拆分成两个高阶组件,例如我们新增一个withTi\nmer的高阶组件:\n\n\n\n然后我们在原基础上增加\n\n\n\n\n高阶组件的现状#\n\n高阶组件的出现，解决了组件之间如何横向抽离公共逻辑的问题，因此你也能过在各大生态库中见到高阶组件的身影。\n\n例如在react-redux中的connect用法，这里connect明显返回的就是一个高阶组件， 之后开发者可以传入自己的组件进行组件强化。\n\n> 官网：https://react-redux.js.org/api/connect#connect-returns\n\n高阶组件是为了解决早期类组件公共逻辑抽离的问题，如果你看官网的示例的话\n\n由于React的Hook出现，函数组件占主流，抽离公共逻辑也能够使用自定义Hook 来实现了\n\n因此你可以在Redux官网看到如下，推荐你使用hooks API\n\n","routePath":"/guide/react/advance/第一章/2-高阶组件","lang":"","toc":[{"text":"高阶组件","id":"高阶组件","depth":2,"charIndex":-1},{"text":"高阶组件是一个函数","id":"高阶组件是一个函数","depth":3,"charIndex":152},{"text":"高阶组件要做的事情","id":"高阶组件要做的事情","depth":3,"charIndex":290},{"text":"高阶组件的现状","id":"高阶组件的现状","depth":3,"charIndex":1789}],"domain":"","frontmatter":{},"version":""},{"id":101,"title":"","content":"Ref#\n\n这一讲，我们就来彻底看一下 Ref，包含以下的内容\n\n * 过时 API: String 类型的 Refs\n * createRefAPI\n * Ref 转发\n * useRef 与useImperativeHandle\n\n\n过时 API: String 类型的 Refs#\n\n首先，我们还是需要认识到 Ref 是为了解决什么问题。我们都知道，现代前端框架的一大特点就是响应式，开发人员不需要再去手动操作 DOM 元素，只需要关心和\nDOM 元素绑定的响应式数据即可。\n\n但是有些时候，我们需要操作 DOM 元素，例如官方所列举的这几个场景:\n\n * 管理焦点，文本选择或媒体播放\n * 触发强制动画\n * 集成第三方 DOM 库\n\n在最最早期的时候，React 中 Ref 的用法非常简单，类似于 Vue,给一个字符串类型的值，之后在方法中通过this.refs.x就能够引用到。\n\n示例如下:\n\n\n\n在上面的代码中，我们在 input 上面挂了一个 ref 属性，对应的值为 inputRef,之后查看组件实例，可以看到该组件实例中的 refs 里面就保存了该\ninput 的 DOM 元素。\n\n\n\n然后我们就可以像之前一样进行 DOM 元素的操作了。例如在上面的示例中我们进行了聚焦的操作。\n\n但是这里需要注意两点:\n\n * 避免使用 refs 来做任何可以通过声明式实现来完成的事情\n * 该 API 已经过时，可能会在未来的版本被移除，官方建议我们使用回调函数或 createRef API 的方式来代替(后面还是用 useRef)\n\n> 关于为何被废弃可以看 Github 的 issue 解释\n\n\ncreateRef API#\n\n接下来我们来看用官方后面推出的 createRef API\n\n\n\n在上面的代码中，我们创建 Ref 不再是通过字符串的形式，而是采用的 createRef 这个静态方法创建了一个 Ref 对象，并在组件实例上面\n\n新增了一个 inputRef 属性来保存这个 Ref 对象。\n\n\n\ncreateRef 这个方法本质也很简单，就是返回了一个{current: null}的对象，源码如下\n\n\n\n最后我们把这个对象和 input 进行关联。\n\n如果要获取 DOM 元素，可以通过this.inputRef.current来获取。\n\n除了在 JSX 中关联 Ref,我们还可以直接关联一个类组件， 这样就可以直接调用该组件内部的方法。 例如：\n\n\n\n\n\n> 虽然提供了这个方式，但他是一个反模式，咱们就回到了 jQuery 时代，尽量避免这么做\n\nReact.createRef APl 是在 React 16.3 版本引入的，如果是稍早一点的版本，官方推荐使用回调 Refs,也就是函数的形式。例如:\n\n\n\n你可能会好奇，为什么上面的例子都是使用的类组件，现在不都是使用函数组件了么?这是因为默认情况下，你不能在函数组件上使用 ref\n属性，因为它们没有实例，但是在函数组件内部是可以使用 ref 的，这涉及到后面要说的 useRef.\n\n\nRef 转发#\n\n既然要讲 Ref,咱们就一起把它整个知识点一 起讲完，接下来要介绍的是 Ref 的转发。\n\nRef 转发是一个可选特性，其允许某些组件接收 ref,并将其向下传递(换句话说，\"转发\"它)给子组件。\n\n那么什么时候需要 Ref 的转发呢?往往就在使用高阶组件的时候。\n\n我们先来看一下如果没有 Ref 转发，在高阶组件中使用 Ref 会遇到什么问题。\n\n\n\n在上面的代码中，我们使用了 withLog 这个高阶组件来包裹 ChildCom1 子组件，从而添加日志功能。在使用由高阶组件返回的增强组件时，我们传递了一个\nRef,我们的本意是想要这个 Ref 关联原本的子组件，从而可以触发子组件里面的方法。\n\n但是我们会发现 Ref 关联的是高阶组件中返回的增强组件，而非原来的子组件。\n\n要解决这个问题就会涉及到 Ref 的转发。说直白一点就是 Ref 的向下传递给子组件。\n\n这里 React 官方为我们提供了一个React.forwardRef APl。我们需要修改的仅仅是高阶组件:\n\n\n\n在上面的代码中，React.forwardRef接受一个渲染函数，该函数接收 props 和 ref 参数并返回原本我们直接返回的增强组件。\n\n接下来我们在增强组件的 render 方法中，通过this.props拿到 ref 继续传递给子组件。\n那么React.forwardRef究竟做了啥呢?源码如下:\n\n\n\n可以看到，实际上 forwardRef 这个静态方法实际上也就是返回一个 elementType 的对象而已，该对象包含一个 render\n方法，也就是我们在使用React.forwardRef时传入的渲染函数。\n\n之所以要这么多此一举，是因为该渲染函数会自动传入 props 和 ref，关键点就在这里，拿到 ref 后，后我们就可以将 ref 继续往下面传递。\n\n\nuseRef 与 useImperativeHandle#\n\n关于 Ref 这一块，最后要看一下的就是这两个 Hook。\n\n我们知道，现在整个 React 是函数组件大行其道，那么自然我们会遇到函数组件下如何进行 Ref 的关联。\n\n在函数组件中，官方为我们提供了新的useRef这个 Hook 来进行关联，但是也可以使用createRefAPI，示例如下:\n\n\n\n通过上面的示例我们可以看出，虽然createRef和useRef都是创建 Ref 的，但是还是有一些区别， 主要体现在下面的点:\n\n * useRef是 hooks 的一种，一般用于函数组件，而createRef一般用于类组件\n * 由useRef创建的 ref 对象在组件的整个生命周期内都不会改变，但是由createRef创建的 ref 对象，组件每更新一次，ref\n   对象就会被重新创建\n\n实际上，就是因为在函数式组件中使用createRef创建 ref 时存在弊端，组件每次更新，ref 对象就会被重新创建，所以出现了useRef来解决这个问题。\n\nuseRef 还接受一个初始值，这在用作关联 DOM 元素时通常没什么用，但是在作为存储不需要变化的全局变量时则非常方便。来看下面的例子:\n\n\n\n上面的写法存在一个问题，如果这个 App 组件里有 state 变化或者他的父组件重新 render 等原因导致这个 App 组件重新 render\n的时候，我们会发现，点击停止按钮，定时器依然会不断的在控制台打印，定时器清除事件无效了。\n\n因为组件重新渲染之后，这里的 timer 以及 clearTimer 方法都会重新创建，timer 已经不是存储的之前的定时器的变量了。\n\n此时根据 useRef 在组件的整个生命周期内都不会改变的特性，我们可以将定时器变量存储到 useRef 所创建的对象上面，示例如下:\n\n\n\n最后，我们要看一下另外一个useImperativeHandle这个 Hook。\n\n该 Hook 一般配合React.forwardRef使用，主要作用是父组件传入 Ref 时，自定义要暴露给父组件的实例值。\n\n来看一个具体的示例:\n\n\n\n\n\n在上面的代码中，我们使用了uselmperativeHandle这个 Hook, 该 Hook 的第一个参数是父组件传递进来的 ref,\n第二个回调函数返回一个对象，该对象是个映射关系， 映射关系中的键之后能够暴露给父组件使用，映射关系中的值对应的是对应的方法。\n\n> 但建议少用，毕竟这是 ref","routePath":"/guide/react/advance/第一章/3-Ref","lang":"","toc":[{"text":"Ref","id":"ref","depth":2,"charIndex":-1},{"text":"过时 API: String 类型的 Refs","id":"过时-api-string-类型的-refs","depth":3,"charIndex":118},{"text":"createRef API","id":"createref-api","depth":3,"charIndex":711},{"text":"Ref 转发","id":"ref-转发","depth":3,"charIndex":1296},{"text":"useRef 与 useImperativeHandle","id":"useref-与-useimperativehandle","depth":3,"charIndex":2095}],"domain":"","frontmatter":{},"version":""},{"id":102,"title":"","content":"Context#\n\n有关 Context ，这是一个非常重要的知识点，甚至我们之后在书写 mini-react，mini-react-router、 mini-redux\n时都会用到的一个知识点，所以这一小节，我们就来好好看一下 Context 的相关内容，主要包含以下几个点:\n\n * Context 要解决的问题\n * Context 的用法\n * Context 相关 Hook\n\n\nContext 要解决的问题#\n\n首先来看一下 Context\n要解决的问题。正常来讲，我们单页应用中的组件会形成一个像组件树一样结构，当内部组件和组件之间要进行数据传递时，就免不了一层一层先传递到共同的父组件，然后再一层一\n层传递下去。\n\n\n\n假设 subComA-1 组件的状态数据要传递给 subComB-2 组件，应该怎么做?\n\n根据我们前面所讲的单项数据流的规则，那么数据应该被提升到 App 根组件，然后通过 props 一层一层的传递给下面的子组件，最终 subComA-1\n拿到所需要的数据；如果 subComA-1 组件需要修改传递下来的数据，那么该组件就还需接收从 App 根组件一层一层传递下来的能够修改数据的方法。\n\n官方在\"何时使用 Context 这一小节也举了一个形象的例子：何时使用 Context\n\n因此，简单概括 Context ，就是解决组件之间数据共享的问题，避免一层一层的传递。\n\nContext\n如果直接翻译成中文，会被翻译成\"上下文\"，这其实在软件领域很常见的一个词，比如前面我们也学习过\"执行上下文\"，所谓上下文，往往指的是代码执行时所需的数据环境信息\n。\n\n\nContext 的用法#\n\nReact 官方对于 Context 的用法，分为旧版 API 和新版 API,有关旧版 API 的用法，本文档就不再赘述，如果有需要的同学，可以参阅: 过时的\nContext\n\n新版 API 使用#\n\n这里我们来看一下新版 API 的使用，示例如下:\n\n\n\n首先，使用React.createContext API 创建的一个上下文对象，该对象里面会提供两个组件，分别是 Provider 和 Consumer\n，表示数据的提供者和消费者。\n\n\n\n在根组件 App.jsx 中，我们设置了一个根组件的状态数据 count，然后从 MyContext 中解构出 Provider\n组件来作为数据的提供者，value 属性用来设置要提供的数据。\n\n\n\n在 ChildCom1 子组件中，无需再像中转站一样接受父组件的数据然后又传递给 ChildCom2 和 ChildCom3 组件。\n\n\n\nChildCom2 组件是一个函数组件，函数组件想要获取 Context 上下文中的数据，需要使用 Consumer\n组件，这种方法需要一个函数作为主元素，这个函数接收当前的 context 值，并返回一个 React 节点。\n\n\n\nChildCom3 组件是一个类组件， 类组件当然也可以使用上面 Consumer 的方式来获取上下文中的数据，但对于类组件而言，还可以使用\ncontextType 的方式。挂载在 class 上的 contextType 属性可以赋值为由React createContext()创建的\nContext 对象。\n\n> 最终效果就是点击 ChildCom2 或者 ChildCom3，count 数据都会增加\n\ndisplayName#\n\n如果安装了 React Developer Tools 工具，那么在 components\n选项卡中可以看到如下的组件树结构，默认的名字就为Context.Provider和Context.Consumer\n\n\n\n通过设置 displayName 可以修改显示名字，如下：\n\n\n\n默认值#\n\nContext 上下文环境可以设置默认值，如下：\n\n\n\n此时就不再需要 Provider 组件来提供数据了，子组件可以直接消费上下文环境的默认数据。\n\n多个上下文环境#\n\n在上面的示例中，我们示例的都是一个 Context 上下文环境，这通常也够用了，但是这并不意味着只能提供一个上下文环境，我们可以创建多个上下文环境，示例如下:\n\n\n\n首先，我们导出两个上下文环境，接下来在 App.jsx 中，使用多个 Provider 作为数据的提供者\n\n\n\n之后在 ChildCom2 中同样也可以使用多个 Consumer 来消费不同上下文中的数据\n\n\n\n> 如果重名回调里面 context 参数重名，就会根据最近的 context 读取\n\n\nContext 相关 Hook#\n\n在 React Hook API 中，为我们提供了一个更加方便的useContext钩子函数，该 Hook 接收一个由React.createContext\nAPI 创建的上下文对象，并返回该 context 的当前值。\n\n例如:\n\n\n\nuseContext(MyContext)相当于类组件中的static contextType =\nMyContext或者，但是我们仍然需要在上层组件树中使用来为下层组件提供 context 。","routePath":"/guide/react/advance/第一章/4-Context","lang":"","toc":[{"text":"Context","id":"context","depth":2,"charIndex":-1},{"text":"Context 要解决的问题","id":"context-要解决的问题","depth":3,"charIndex":194},{"text":"Context 的用法","id":"context-的用法","depth":3,"charIndex":699},{"text":"新版 API 使用","id":"新版-api-使用","depth":4,"charIndex":803},{"text":"displayName","id":"displayname","depth":4,"charIndex":1431},{"text":"默认值","id":"默认值","depth":4,"charIndex":1585},{"text":"多个上下文环境","id":"多个上下文环境","depth":4,"charIndex":1667},{"text":"Context 相关 Hook","id":"context-相关-hook","depth":3,"charIndex":1911}],"domain":"","frontmatter":{},"version":""},{"id":103,"title":"","content":"Render Props#\n\n在 React 中，代码复用的最基本单位就是组件，但是如果组件中也出现了重复的代码，该怎么做呢?\n\n那么我们需要通过某种方式将代码中公共的部分抽取出来，这些公共的部分就被称之为横切关注点 (Cross-Cutting Concern)\n\n在 React 中，常见有两种方式来进行横切关注点的抽离:\n\n * 高阶组件(HOC)\n * Render Props\n\nRender Props 实际上本身并非什么新语法，而是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术。\n\n有关Render Props，咱们主要需要掌握以下 2 个点:\n\n * 如何用?\n * 何时用?\n\n\n如何使用 Render Props#\n\n我们首先还是来看一个示例：\n\n\n\n\n\n\n\n在上面的代码中，App 根组件下渲染了两个子组件，这两个子组件一个是显示鼠标的位置，另外一个是根据鼠标位置显示一个跟随鼠标移动的小球。\n\n观察代码，你会发现这两个子组件内部的逻辑基本上是一模一 样的， 只是最终渲染的内容不一样， 此时我们就可以使用 Render Props\n对横切关注点进行一个抽离。\n\n方式也很简单，就是在一个组件中使用一个值为函数的 prop，函数的返回值为要渲染的视图。\n\n\n\n在上面的代码中，我们新创建了个 MouseMove 组件，该组件就封装了之前 ChildCom1 和 ChildCom2 组件的公共逻辑。该组件的 props\n接收一个名为 render 的参数，只不过该参数对应的值为一个函数，我们调用时将对应的状态和处理函数传递过去，该函数的调用结果为 返回一段视图。\n\n\n\n接下来在 App 根组件中，我们使用 MouseMove 组件，该组件上有一个 render 属性，对应的值就是函数，函数返回要渲染的组件。\n\n\n\n\n\n最后就是子组件 ChildCom1 和 ChildCom2 的改写，可以看到这两个子组件就只需要书写要渲染的视图了。公共的逻辑已经被 MouseMove\n抽取出去了。\n\n另外需要说明的是，虽然这个技巧的名字叫做 Render Props，但不是说必须要提供一个名为 render 的属性，事实上，封装公共逻辑的组件(例如上面的\nMouseMove ) 只要能够得到要渲染的视图即可，所以传递的方式可以有多种。\n\n例如:\n\n\n\n上面使用 MouseMove 组件时，并没有传递什么 render 属性，而是通过 props.children 的形式将要渲染的视图传递到了组件内部。\n\n在 MouseMove 组件内部，就不再是执行 render 方法了，而是应该执行 props.children，如下:\n\n\n\n\n何时使用 Render Props#\n\n我们发现上面的例子其实用高阶组件也能实现\n\n> 这里就不列举代码了，你可以自己尝试\n\n那么自然而然疑问就来了，什么时候使用 Render Props ?什么时候使用 HOC ?\n\n一般来讲， Render Props 应用于组件之间功能逻辑完全相同，仅仅是渲染的视图不同。这个时候我们可以通过 Render Props\n来指定要渲染的视图是什么。\n\n而 HOC 一般是抽离部分公共逻辑，也就是说组件之间有一部分逻辑相同，但是各自也有自己独有的逻辑，那么这个时候使用 HOC\n比较合适，可以在原有的组件的基础上做一个增强处理。","routePath":"/guide/react/advance/第一章/5-Render Props","lang":"","toc":[{"text":"Render Props","id":"render-props","depth":2,"charIndex":-1},{"text":"如何使用 Render Props","id":"如何使用-render-props","depth":3,"charIndex":315},{"text":"何时使用 Render Props","id":"何时使用-render-props","depth":3,"charIndex":1145}],"domain":"","frontmatter":{},"version":""},{"id":104,"title":"","content":"Portals#\n\nPortals 被翻译成传送门，它要做的事情实际上也确实和传送门很相似，根据官方的解释：\n\n> Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。\n\n其语法为：\n\n\n\n第一个参数 (child) 是任何可渲染的 React 子元素，第二个参数 (container) 是一个 DOM 元素。\n\n学习一个知识我们仍然是应该从以下 2 个点着手：\n\n * 何时使用？\n * 如何用？\n\n\n什么场景下需要使用 Portals#\n\n首先我们来看一个场景，如下：\n\n\n\n\n\n在上面的示例中，Modal 是一个模态框，在 App 根组件中能够控制该模态框组件是否显示。\n\n\n\n上面的示例，功能倒是没有什么问题，但是从最终渲染出来的 html 结构上来讲，将整个模态框都放在 root 这个 div 中不是那么合适，我们生成的 html\n结构上，这个模态框能够渲染到 modal 那个 div 里面。\n\n\n\n并且一旦父组件上面设置了额外的样式，都会影响这个子组件的渲染，例如：\n\n\n\n我们在 App 组件中添加一条相对定位的样式，此时我们就会发现由于 Modal 是放在整个 root 元素里面的，模态框的位置就会收到影响。\n\n\n\n因此，在这种时候，我们就可以使用 Portals 来解决这个问题。\n\n\n如何使用 Portals#\n\nPortals 的使用方式也非常简单，只需要使用createPortal方法来指定渲染到哪个元素中即可。需要注意的是这是和 React 渲染相关的，所以\ncreatePortal 方法来自于 react-dom 这个库。\n\n\n\n在上面的代码中，我们将要渲染的视图作为createPortal方法的第一个参数，而第二个参数用于指定要渲染到哪个 DOM 元素中。\n\n\n\n可以看到，这一次模态框就被渲染到了 id 为 modal 的 div 中。并且在 root 中所设置的样式都不会影响到模态框的显示。\n\n> 其实根据官方的介绍，Portals 的典型用例是当父组件有 overflow: hidden 或 z-index\n> 样式时，但你需要子组件能够在视觉上\"跳出\"其容器。例如，对话框、悬浮卡以及提示框。\n\n\n通过 Portals 进行事件冒泡#\n\n最后需要注意一下的就是使用 Portal 所渲染的元素在触发事件时的冒泡问题。\n\n以上面的例子为例，看上去模态框已经渲染到了 modal 这个元素里面，但是在 React\n中事件冒泡是按照组件结构来进行冒泡的，我们可以看到即使模态框已经渲染到了 modal 里面，但是在组件树中模态框组件仍然是在根组件中。\n\n\n\n我们也可以书写一个例子来验证一下，例如我们为 App 根组件绑定一个点击事件，如下:\n\n\n\n然后我们点击 Modal，会发现事件也被触发了\n\n> 官方解释：\n> \n> 尽管 portal 可以被放置在 DOM 树中的任何地方，但在任何其他方面，其行为和普通的 React 子节点行为一致。由于 portal 仍存在于\n> React 树，且与 DOM 树中的位置无关，那么无论其子节点是否是 portal,像 context 这样的功能特性都是不变的。\n> \n> 这包含事件冒泡。一个从 portal 内部触发的事件会一直冒泡至包含 React 树的祖先，即便这些元素并不是 DOM 树中的祖先。","routePath":"/guide/react/advance/第一章/6-Portals","lang":"","toc":[{"text":"Portals","id":"portals","depth":2,"charIndex":-1},{"text":"什么场景下需要使用 Portals","id":"什么场景下需要使用-portals","depth":3,"charIndex":218},{"text":"如何使用 Portals","id":"如何使用-portals","depth":3,"charIndex":571},{"text":"通过 Portals 进行事件冒泡","id":"通过-portals-进行事件冒泡","depth":3,"charIndex":942}],"domain":"","frontmatter":{},"version":""},{"id":105,"title":"","content":"错误边界#\n\n部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16引入了一个新的概念——错误边界。\n\n错误边界是一种React组件，这种组件可以捕获发生在其子组件树任何位置的 JavaScript 错 误，并打印这些错误，同时展示降级 UI\n，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。\n\n我们来看一个例子：\n\n\n\n\n\n\n\n\n\n在上面的代码中，我们整个组件树结构如下：\n\n\n\n可以看到，ChildCom1 下面的ChildCom3存在问题，这一个组件的问题会导致整个应用崩溃。\n\n这在某些场景下，实际上是没有必要的，例如有问题的组件是广告、或者些无关紧要的组件， 此时我们就期望渲染出问题组件以外的组件树。\n\n错误边界就是用来解决这个问题的。\n\n> 错误边界是一种 React 组件，这种组件可以捕获发生在其子组件树任何位置的 JavaScript\n> 错误，并打印这些错误，同时展示降级UI，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。\n\n如果一个class组件中定义了static getDerivedStateFromError()或\ncomponentDidCatch()这两个生命周期方法中的任意一个(或两个) 时，那么它就变成一个 错误边界。当抛出错误后，请使用static\ngetDerivedStateFromError()渲染备用UI，使用componentDidCatch()打印错误信息。\n\n\n\n然后我们给 ChildCom3 外面包裹一下这个组件\n\n\n\n然后我们就会发现页面不会崩溃了，ChildCom3的位置出现了我们降级 UI 渲染的东西\n\n\n\n在上面的代码中，我们就创建了一个错误边界组件，该组件有一个 getDerivedStateFromError 静态方法以及 componentDidCatch\n实例方法，这两个方法都会在组件渲染出错时调用，但是略有区别，具体的区别如下:\n\n * getDerivedStateFromError 静态方法\n   * 运行时间点：渲染子组件的过程中，发生错误之后，在更新页面之前（整个应用没有崩溃，直接渲染降级 UI）\n   * 注意：只有子组件发生错误，才会运行该函数\n   * 该函数返回一个对象，React 会将该对象的属性覆盖掉当前组件的 state\n   * 参数：错误对象\n   * 通常，该函数用于改变状态\n * componentDidCatch 实例方法\n   * 运行时间点：渲染子组件的过程中，发生错误，更新页面之后（整个应用已经崩溃，之后再重新渲染整个应用，当然会将有问题的UI渲染成降级UI），由于其运行时间\n     点比较靠后，因此不太会在该函数中改变状态\n   * 通常，该函数用于记录错误信息\n\n> 最佳实践，使用 static getDerivedStateFromError 渲染备用UI，使用 componentDidCatch 打印错误信息。\n\n最后需要注意的是，错误边界组件主要是用来捕获 UI 渲染时的错误，因此如下场景错误无法捕获：\n\n * 事件处理\n * 异步代码（例如 setTimeout 或者 requestAnimationFrame 回调函数\n * 服务端渲染\n * 它自身抛出来的错误(并非它的子组件)\n\n总之，错误边界组件仅能用于处理渲染子组件期间的同步错误。","routePath":"/guide/react/advance/第一章/7-错误边界","lang":"","toc":[{"text":"错误边界","id":"错误边界","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":106,"title":"","content":"组件渲染性能优化#\n\n在本小节，我们将会探讨组件在渲染时，如何优化渲染性能问题。\n\n涉及到的内容会包含 shouldComponentUpdate、PureComnent、 React.memo、 useMemo、 useCallback 等。\n\n\nshouldComponentUpdate 与 PureComnent#\n\nshouldComponentUpdate#\n\nshouldComponentUpdate 与 PureComnent 都与类组件相关，所以下面会以类组件来示例。\n\n\n\n在上面的代码中，我们书写了一个简单的计数器，按钮在点击的时候仍然是设置 counter 的值为 1，不过，虽然 counter\n的值没有变，整个组件仍然是重新渲染了的。显然，这一次渲染是没有必要的。\n\n此时，我们就可以使用 shouldComponentUpdate 来进行优化。\n\n\n\n这边有个功能函数用来浅层比较两个对象是否相等\n\n\n\n这样再次点击控制台就不会输出 App 渲染了\n\n> 官方：此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent\n> 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state\n> 进行浅层比较，并减少了跳过必要更新的可能性。\n\nPureComponent#\n\nReact.PureComponent 与 React.Component 很相似。\n\n两者的区别在于React.Component 并未实现 shouldComponentUpdate()，而React.PureComponent中以浅层对比\nprop 和 state 的方式来实现了该函数。\n\n如果赋予 React 组件相同的 props 和 state，render() 函数会渲染相同的内容，那么在某些情况下使用React.PureComponent\n可提高性能。\n\n同样的示例，只改一个地方\n\n\n\n值得注意的是，React.PureComponent 中的 shouldComponentUpdate()\n仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。\n\n仅在你的 props 和 state 较为简单时，才使用React.PureComponent ，或者在深层数据结构发生变化时调用 forceUpdate()\n来确保组件被正确地更新。你也可以考虑使用 immutable 对象加速嵌套数据的比较。\n\n比如下面的例子\n\n\n\n我点击后 push 了值进去，应该视图上要显示王五，但并没有显示\n\n\n\n通过 React 插件工具查看，发现 push 进去了\n\n\n\n为什么视图没有更新呢？\n\n究其原因，是因为数组的地址并没有发生更改，而是数组内部发生的更改，但是 PureComponent\n是浅比较，会认为数组并没有发生更改，因此不会进行渲染更新。(如果使用 Component 则是没有问题的，因为 React.Component 并未实现\nshouldComponentUpdate)\n\n当然我们可以解决这个问题：返回一个新的数组，而不是把原数组赋值给 stu\n\n\n\n\nReact.memo#\n\nshouldComponentUpdate 与 PureComnent 主要是优化类组件的渲染性能，那么如果是函数组件该怎么办呢?\n\n> 函数组件没有上面类组件中设置 state 为一个值进行重新渲染的问题，这是和类组件的不同，具体的原因在后面再讲解\n\n在 React 中，为我们提供了 React.memo，文档地址：React.memo\n\n这是一个高阶组件，如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo\n中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。\n\n来看一个例子:\n\n\n\n\n\n当我们点击 ChildCom 里的+1 时，两个都渲染，这是对的，因为 ChildCom 用的是 App 里的设置的状态。但我们点击 App 的+1\n时，会发现两个也都渲染，因为 App 整体都渲染，自然包括子组件 ChildCom 了。\n\n但我们只改变了 App 的 counter1，传给 ChildCom 的是 counter2，所以 ChildCom 应该不渲染才对，这里就可以通过\nReact.memo 进行优化了\n\n\n\n之后我们再更新 counter1 时，由于传递给子组件的 counter2 这个 props 属性并没有变化，因此子组件不会更新。\n\n注意：默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。\n\n举个例子：\n\n\n\n\n\n这个例子和我们之前的 PureComponent 所组的例子很相似，由于是在原来的数组上面进行的修改，数组的地址并没有发生变化，因此 React.memo\n返回的组件并不会更新。\n\n> 实际上 React.memo 的源码就是返回一个 PureComponent 组件：\n\n此时要解决这个问题也很简单，和前面一样，直接返回一个新的数组，例如：\n\n\n\n另外，在使用 React.memo 的时候还支持传入第二个自定义的比较函数参数，例如:\n\n\n\n\nuseCallback#\n\n正常情况下，如果组件各自内部维护自己的数据，那么组件更新的时候相互并不会影响，例如: App 根组件对应样式：\n\n\n\nApp 根组件，引入了 ChildCom1 和 ChildCom2 这两个子组件：\n\n\n\n\n\n\n\n在上面的代码中，我们还向两个子组件传入了一个 test 函数，由于每次 App 组件的重新渲染会生成新的 test 函数，所以对于两个子组件来讲传入的 test\n导致 props 不同所以都会重新渲染。\n\n此时就可以使用 useCallback 来解决这个问题，语法如下:\n\n\n\n把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的memoized 版本，该回调函数仅在某个依赖项改变时才会更新。\n\n接下来我们来使用 useCallback 优化上面的问题，对 App.jsx 做如下的修改:\n\n\n\n在上面的代码中，我们对 test 函数做了缓存，从而保证每次传入到子组件的这个 props 和之前是相同的。\n\n> useCallbak 主要就是对函数进行缓存\n\n\nuseMemo#\n\n最后要介绍的是 useMemo，其语法如下：\n\n\n\n主要用于返回一个 memoized 值，文档地址: useMemo\n\n某些时候，组件中某些值需要根据状态进行一个二次计算(类似于 Vue\n中的计算属性)，由于函数组件一旦重新渲染，就会重新执行整个函数，这就导致之前的二次计算也会重新执行一次，例如：\n\n\n\n在上面的示例中，文本框的输入会导致整个 App 组件重新渲染，导致 getNum 函数一直被调用。但是 count 的值是没有改变的，所以 getNum\n这个函数也是没有必要重新执行的。\n\n> 用 useCallback 是没用的，因为每次渲染都要去调用这个函数，所以还是会执行\n\n我们换成 useMemo，来优化它：\n\n\n\n在上面的示例中，我们使用了useMemo 来缓存二次计算的值，并设置了依赖项 count,只有在 count 发生改变时，才会重新执行二次计算。\n\n\nuseMemo 和 useCallback 的区别和使用场景#\n\nuseMemo 和 useCallback 接收的参数都是一样，第一个参数为回调函数，第二个参数为要依赖的数据。\n\n共同的作用：只有依赖的数据发生变化，才会重新计算结果，起到了缓存的效果。\n\n两者的区别：\n\n * useMemo 计算结果是 return 回来的值，主要用于缓存计算结果的值，应用场景如：需要进行二次计算的状态\n * useCallback 计算结果是函数，主要用于缓存函数，应用场景如 需要缓存起来的函数，因为函数式组件每次任何一个 state\n   的变化，整个组件都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能和减少资源浪费。","routePath":"/guide/react/advance/第一章/8-组件渲染性能优化","lang":"","toc":[{"text":"组件渲染性能优化","id":"组件渲染性能优化","depth":2,"charIndex":-1},{"text":"shouldComponentUpdate 与 PureComnent","id":"shouldcomponentupdate-与-purecomnent","depth":3,"charIndex":124},{"text":"shouldComponentUpdate","id":"shouldcomponentupdate","depth":4,"charIndex":162},{"text":"PureComponent","id":"purecomponent","depth":4,"charIndex":612},{"text":"React.memo","id":"reactmemo","depth":3,"charIndex":1397},{"text":"useCallback","id":"usecallback","depth":3,"charIndex":2266},{"text":"useMemo","id":"usememo","depth":3,"charIndex":2737},{"text":"useMemo 和 useCallback 的区别和使用场景","id":"usememo-和-usecallback-的区别和使用场景","depth":3,"charIndex":3139}],"domain":"","frontmatter":{},"version":""},{"id":107,"title":"","content":"前端框架的理解#\n\n> 问题：谈一谈你对前端框架的理解？\n\n什么是前端框架？首先我们需要划定边界：\n\n * React 或者 Vue 究竟是库（library）还是框架（framework）？\n\n实际上，无论是 React 也好，还是 Vue 也好，他们的核心是 \"构建 UI 的库\"，提供了如下的功能：\n\n * 基于状态的声明式渲染\n * 提供组件化开发\n\n比如 React 官方文档的首页就是如图：\n\n\n\n当应用进一步的扩展，从简单的页面升级为了 SPA，此时意味着需要前端要有前端路由方案，React 阵营有 React-router, Vue 阵营有了\nVue-router,有了这些前端路由库。\n\n随着应用复杂度的进一步提升，组件的数量越来越多，状态管理越来越复杂，因此就需要状态管理的库，React 阵营有\nredux、react-redux，zustand，jotai 等，vue 阵营有 vuex、pinia\n\n我们发现，除了上面提到这些功能以外，还有很多其他的功能(构建支持、数据流方案、文档工具)，React 和 Vue 本身其实不支持的，所以说 React 和\nVue 本身只是专注于 UI 的渲染（构建 UI），因此我们可以将\"React 或者 Vue\n本身以及其他附加功能或者说和它相关的生态\"，整个一起的解决方案称之为框架（技术栈）\n\n比如下面的例子：\n\n * UmiJS 是一个框架，基于 React、内置路由、构建、部署等功能\n * NextJS 是一个框架，基于 React、支持 SSR、SSG 两大功能的服务端框架\n\n在平时我们经常能够听到\"React 框架、Vue 框架”这样的说法，这个时候所指的 React 或者 Vue 往往指的是整个 React、Vue\n本身以及它们周边的生态产品，算是一种约定俗成的说法。\n\n现代前端框架至少包含以下几个方面：\n\n * 基于状态的声明式渲染\n * 提供组件化开发（复用）\n * 前端路由方案\n * 状态管理方案\n\n\n问题解答#\n\n问题：谈一谈你对前端框架的理解？\n\n解答：\n\n在早期使用 jQuery 时代，那时的开发人员需要手动的去操作 DOM 节点，那个时候流行的还是 MPA 的模式，各个页面的 JS 代码量还在能够接收的范围。\n\n但是随着单页应用的流行，客户端的 JS 代码量出现井喷，此时如果还是采用传统的手动操作 DOM 的方式，对于开发人员来讲有非常大的心智负担。\n\n此时就出现了能够基于状态声明式渲染以及提供组件化开发模式的库，例如 Vue 和 React。这两者本质上仅仅是构建 UI\n的库，但是随着应用的复杂度的提升，还需要前端路由方案、状态管理方案，所以有了\nvue-router、react-router、vuex、redux、zustand、pinia 等周边生态产品。\n\nVue 或 React 和周边生态产品共同构成了一个技术栈，现在我们会将 React 或者 Vue 称之为框架，这可以算是一种约定俗成的说法。\n\n一款现代前端框架，在它本身以及它的周边生态中，至少要包含以下几个方面:\n\n * 基于状态的声明式渲染\n * 提供组件化开发（复用）\n * 前端路由方案\n * 状态管理方案","routePath":"/guide/react/advance/第二章/1-前端框架的理解","lang":"","toc":[{"text":"前端框架的理解","id":"前端框架的理解","depth":2,"charIndex":-1},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":848}],"domain":"","frontmatter":{},"version":""},{"id":108,"title":"","content":"React 和 Vue 描述页面的区别#\n\n> 问：React 和 Vue 是如何描述 UI 界面的？有一些什么样的区别？\n\n标准且浅显的回答：\n\n> React 中使用的是 JSX，Vue 中使用的是模板来描述界面\n\n前端领域经过长期的发展，目前有两种主流的描述 UI 的方案：\n\n * JSX\n * 模板\n\n\nJSX 历史来源#\n\nJSX 最早起源于 React 团队在 React 中所提供的一种类似于 XML 的 ES 语法糖:\n\n\n\n经过 Babel 编译之后，就会变成：\n\n\n\n无论在 17 版本之前还是 17 版本之后，执行代码会得到一个对象：\n\n\n\n> 这个其实就是虚拟 DOM\n\nReact 团队认为，UI 本质上和逻辑是有耦合部分的：\n\n * 在 UI 上面绑定事件\n * 数据变化后通过 JS 去改变 UI 的样式或者结构\n\n作为一个前端工程师，JS 是用得最多，所以 React 团队思考屏蔽 HTML,整个都用 JS 来描述 UI,因为这样做的话，可以让 UI\n和逻辑配合得更加紧密，所以最终设计出来了类 XML 形式的 JS 语法糖\n\n由于 JSX 是 JS 的语法糖(本质上就是 JS)，因此可以非常灵活的和 JS 语法组合使用，例如:\n\n * 可以在 if 或者 for 当中使用 jsx\n * 可以将 jsx 赋值给变量\n * 可以将 jsx 当作参数来传递，当然也可以在一个函数中返回一段 jsx\n\n\n\n这种灵活性就使得 jsx 可以轻松的描述复杂的 UI，如果和逻辑配合，还可以描述出复杂 UI 的变化。\n\n使得 React\n社区的早期用户可以快速实现各种复杂的基础库，丰富社区生态。又由于生态的丰富，慢慢吸引了更多的人来参与社区的建设，从而源源不断的形成了一个正反馈。\n\n\n模板的历史来源#\n\n模板的历史就要从后端说起。\n\n在早期前后端未分离的时候，最流行的方案就是使用模板引擎，模板引擎可以看作是在正常的 HTML\n上面进行挖坑(不同的模板引擎语法不一样)，挖了坑之后，服务器端会将数据填充到挖了坑的模板里面，生成对应的 html 页面返回给客户端。\n\n所以在那个时期前端人员的工作，主要是 html、css 和一些简单的 js 特效(轮播图、百叶...)， 写好的 html\n是不能直接用的，需要和后端确定用的是哪一个模板引擎，接下来将自己写好的 html 按照对应模板引擎的语法进行挖坑\n\n不同的后端技术对应的有不同的模板引擎，甚至同- 种后端技术，也会对应很多种模板引擎，例如:\n\n * Java (JSP、Thymeleaf、Velocity、Freemarker)\n * PHP (Smarty、Twig、HAML、Liquid、Mustache、Plates)\n * Python (pyTenjin、Tornado.templote、Pylade、Mako、Jinja2)\n * node.js(Jade、Ejs、art-template、handlebars、mustache、swig、doT)\n\n比如 EJS 模板引擎\n\n\n\n这些模板弓|擎对应的模板语法就和 Vue 里面的模板非常的相似。\n\n现在随着前后端分离开发的流行，已经没有再用模板引擎的模式了，\n\n后端开发人员只需要书写数据接口即可。但是如果让一个后端人员来开发前端的代码，那么 Vue 的模板语法很明显对后端来讲更加熟悉\n\n最后我们做一个总结，虽然现在前端存在两种方式: JSX 和模板的形式都可以描述 UI，但是出发点是不同\n\n模板语法的出发点是，既然前端框架使用 HTML 来描述 UI，那么我们就扩展 HTML ，让 HTML 中能够描述一定程度的逻辑，也就是“从 UI 出发，扩展\nUI，在 UI 中能够描述逻辑\"。\n\nJSX 的出发点，既然前端使用 JS 来描述逻辑，那么就扩展 JS，让 JS 也能描述 UI，也就是“从逻辑出发，扩展逻辑，描述 UI\"。\n\n\n问题解答#\n\n问：React 和 Vue 是如何描述 UI 界面的？有一些什么样的区别？\n\n解答：\n\n在 React 中，使用 JSX 来描述 UI。因为 React 团队认为 UI 本质上与逻辑存在耦合的部分，所为前端工程师，JS 是用的最多的，如果同样使用\nJS 来描述 UI，就可以让 UI 和逻辑配合的更密切。\n\n使用 JS 来描述页面，可以更加灵活，主要体现在:\n\n * 可以在 if 语句和 for 循环中使用 JsX\n * 可以将 JSX 赋值给变量\n * 可以把 JSX 当作参数传入，以及在函数中返回 JSX\n\n而模板语言的历史则需要从后端说起。早期在前后端未分离时代，后端有各种各样的模板引擎，其本质是扩展了 HTML，在 HTML\n中加入逻辑相关的语法，之后在动态的填充数据进去。如果单看 Vue 中的模板语法，实际上和后端语言中的各种模板引擎是非常相似的。\n\n总结起来就是:\n\n模板语法的出发点是，既然前端框架使用 HTML 来描述 UI，那么我们就扩展 HTML ，让 HTML 中能够描述一定程度的逻辑，也就是“从 UI 出发，扩展\nUI，在 UI 中能够描述逻辑\"。\n\nJSX 的出发点，既然前端使用 JS 来描述逻辑，那么就扩展 JS，让 JS 也能描述 UI，也就是“从逻辑出发，扩展逻辑，描述 UI\"。\n\n虽然这两者都达到了同样的目的，但是对框架的实现产生了不同的影响。","routePath":"/guide/react/advance/第二章/2-React 和 Vue 描述页面的区别","lang":"","toc":[{"text":"React 和 Vue 描述页面的区别","id":"react-和-vue-描述页面的区别","depth":2,"charIndex":-1},{"text":"JSX 历史来源","id":"jsx-历史来源","depth":3,"charIndex":156},{"text":"模板的历史来源","id":"模板的历史来源","depth":3,"charIndex":756},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":1647}],"domain":"","frontmatter":{},"version":""},{"id":109,"title":"","content":"前端框架的分类#\n\n> 问：现代前端框架不仅仅是React、Vue,还出现了像Svelte、Solid.js 之类的框架，你觉得这些新框架相比React、Vue有什么样的区别?\n\n\n自变量和因变量#\n\n现代前端框架，有一个非常重要的特点，那就是基于状态的声明式渲染。如果要概括的话，可以使用一个公式:\n\n> UI = f (state)\n\n * state：当前视图的一个状态\n * f：框架内部的一个运行机制\n * UI：宿主环境的视图描述\n\nstate的变化会导致最终计算出来的 UI 发生变化，所以 state 是自变量，UI 就是因变量\n\n目前在 React 中有很多 Hook，例如：\n\n\n\n比如上面的代码，我们就是定义了一个自变量\n\n\n\n上面的 useState 这个 hook 可以看作是定义了一个自变量，自变量一变化，就会到导致依赖它的因变量发生变化，在上面的例子中，返回的 jsx 所描述的\nUI 就是因变量。\n\n因变量又可以分为两类：\n\n * 没有副作用的因变量\n * 有副作用的因变量\n\n没有副作用的因变量\n\n在 React 中，useMemo就是定义一个没有副作用的因变量\n\n\n\n在上面的代码中，我们使用 useMemo 定义了一个没有副作用的因变量y，y的值取决于x的值，x的值一变化，y的值也会跟着变化\n\n有副作用的因变量\n\n在 React 中，可以使用 useEffect 来定义一个有副作用的因变量\n\n\n\n上面的代码依赖于自变量x的变化，当x发生变化的时候，会修改页面的标题，这就是一个副作用操作。\n\n那么接下来，我们来总结一下：自变量的变化，会导致三种情况的因变量发生改变:\n\n * 自变量的变化，导致UI因变量变化\n\n\n\n * 自变量的变化，导致无副作用的因变量发生变化\n\n\n\n * 自变量的变化，导致有副作用的因变量发生变化\n\n\n\n\n框架的分类#\n\n上面我们介绍了自变量和因变量，state 实际上就是自变量，自变量的变化直接或者间接的改变了 UI，上面的公式实际上还可以分为两个\n\n * 根据自变量 state 计算出 UI 的变化\n * 根据 UI 的变化执行具体的宿主环境的 API\n\n以前端工程师最熟悉的浏览器为例，那么第二个步骤就是执行DOM相关API，对于这个步骤来讲，不同的框架实际上实现基本是相同的，这个步骤不能作为框架分类的依据，差别\n主要体现在步骤一上面。所以步骤一也是针对各大框架的一个分类依据\n\n前端框架需要关注自变量和x (UI、\n组件、应用)的对应关系，随着x的抽象层级不断下降，自变量到UI变化的路径条数就会增多。路径越多，则意味着前端框架在运行时消耗在“寻找自变量与UI对应关系\"上面的\n时间越少。\n\n根据上面的特点，就可以对现代前端框架分为三大类：\n\n * 元素级框架\n * 组件级框架\n * 应用级框架\n\n以常见的前端框架React为例，它属于应用级框架，Vue属于组件级框架，而新的Svelte、Solid.js属于元素级别框架\n\n\n问题解答#\n\n题目：现代前端框架不仅仅是React、Vue,还出现了像Svelte、Solid.js 之类的框架，你觉得这些新框架相比React、Vue有什么样的区别?\n\n解答：\n\n所有的现代前端框架，都有一个非常重要的特点，那就是“基于状态的声明式渲染”。概括成一个公式的话，那就是UI = f (state)\n\n这里有一点类似于自变量与因变量之间的关系。例如在上面的公式中，state 就是一个自变量，state 的变化会导致 UI 这个因变量发生变化。\n\n不同的框架，在根据自变量(state) 的变化计算出UI的变化这一步骤有所区别，自变量和x (应用、 组件、UI)\n的对应关系，随着x抽象的层级不断下降，\"自变量到UI变化”的路径则不断增多。路径越多，则意味着前端框架在运行时消耗在寻找”自变量与 UI\n的对应关系\"上的时间越少。\n\n以“与自变量建立对应关系的抽象层级\"可以作为其分类的依据，按照这个标准，前端框架可以分为以下三类:\n\n * 元素级框架\n * 组件级框架\n * 应用级框架\n\n以常见的前端框架为例，React 属于应用级框架，Vue属于组件级框架，Svelte、 Solid.jis 属于元素级框架。","routePath":"/guide/react/advance/第二章/3-前端框架的分类","lang":"","toc":[{"text":"前端框架的分类","id":"前端框架的分类","depth":2,"charIndex":-1},{"text":"自变量和因变量","id":"自变量和因变量","depth":3,"charIndex":90},{"text":"框架的分类","id":"框架的分类","depth":3,"charIndex":785},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":1254}],"domain":"","frontmatter":{},"version":""},{"id":110,"title":"","content":"虚拟 DOM#\n\n> 什么是虚拟DOM？其优点有哪些？\n\n虚拟DOM 最早是由React团队提出来的，因此React团队在对虚拟DOM的定义上有着如下\n\n> 官网：虚拟DOM\n\nVirtual DOM是一种编程概念。在这个概念里，UI 以一种理想化的，或者说\"虚拟的\"表现形式被保存于内存中。\n\n也就是说，只要我们有一种方式，能够将真实DOM的层次结构描述出来，那么这就是一个虚拟DOM。\n\n在React中，React 团队使用的是 JS 对象来对DOM结构进行一个描述。但是很多人会直接把JS对象和虚拟DOM划等号，这种理解是不太准确的，比较片面的。\n\n虛拟DOM和JS对象之间的关系：前者是一种思想，后者是一种思想的具体实现\n\n\n为什么需要虚拟 DOM#\n\n使用虚拟 DOM 主要有两个方面的优势：\n\n * 相较于 DOM 的体积优势和速度优势\n\n> 这里的速度优势并不全面，因为虚拟DOM是通过比较差异来减少对实际DOM的访问，以提高性能，在一些场景中其实直接操作DOM更高效，但在复杂UI变化中，心智负担\n> 严重\n\n * 多平台的渲染抽象能力\n\n相较于 DOM 的体积优势和速度优势\n\n首先我们需要明确一个点，JS 层面的计算速度要比DOM层面的计算要快:\n\n * DOM对象最终要被浏览器渲染出来之前，浏览器会有很多工作要做(浏览器的渲染原理)\n * DOM对象上面的属性也非常非常多\n\n比如这两行代码，可以直接浏览器控制台运行一下看看：\n\n\n\n操作JS对象的时间和操作DOM对象的时间是完全不一样的。\n\nJS层面的计算速度要高于DOM层面的计算速度。\n\n\n\n此时有一个问题：虽然使用了 JS 对象来描述 UI，但是最终不还是要用原生 DOM API 去操作 DOM 么?\n\n虛拟 DOM在第一次渲染页面的时候， 并没有什么优势，速度肯定比直接操作原生 DOM API 要慢一些，虚拟 DOM真正体现优势是在更新阶段。\n\n根据React团队的研究，在更新页面时，相比使用原生 DOM API，开发人员更加倾向于使用 innerHTML\n\n\n\n\n\n因此在使用 innerHTML 的时候，就涉及到了两个层面的计算:\n\n * JS 层面：解析字符串\n * DOM 层面：创建对应的 DOM 节点\n\n接下来我们加入虚拟 DOM 来进行对比\n\n           INNERHTML      虚拟 DOM\nJS 层面计算    解析字符串          创建 JS 对象\nDOM 层面计算   创建对应的 DOM 节点   创建对应的 DOM 节点\n\n虚拟 DOM 真正发挥威力的时候，是在更新阶段\n\ninnerHTML进行更新的时候，要全部重新赋值，这意味着之前创建的DOM节点需要全部销毁掉，然后重新进行创建，但是虚拟DOM只需要更新必要的DOM节点即可\n\n           INNERHTML        虚拟 DOM\nJS 层面计算    解析字符串            创建 JS 对象\nDOM 层面计算   销毁原来所有的 DOM 节点   修改必要的 DOM 节\nDOM 层面计算   创建对应的 DOM 节点     \n\n多平台的渲染抽象能力\n\n虚拟 DOM 只是多真实 UI 的一个描述，根据不同的宿主环境，可以执行不同的渲染代码：\n\n * 浏览器、Node.js宿主环境使用 ReactDOM 包\n\n * Native宿主环境使用 ReactNative 包\n\n * Canvas, SVG或者VML (IE8) 宿主环境使用 ReactArt 包\n\n * ReactTest包用于渲染出 JS 对象，可以很方便地测试\"不隶属于任何宿主环境的通用功能\"\n\n\nReact 中的虚拟 DOM#\n\n在 React 中通过 JSX 来描述 UI, JSX最终会被转为一个叫做 createElement 方法的调用，调用该方法后就会得到虚拟DOM对象。\n\n经过 Babel 编译过后结果如下：在线Babel工具地址\n\n\n\n在源码中 createElement 方法如下：\n\n\n\n在上面的代码中，最终返回的element对象就是我们所说的虚拟DOM对象。在官方文档中，官方更倾向于将这个对象称之为React元素\n\n\n问题解答#\n\n问：什么是虚拟DOM？其优点有哪些？\n\n答：\n\n虚拟 DOM 最初是由 React 团队所提出的概念，这是一种编程的思想，指的是针对真实UI DOM 的一种描述能力。\n\n在React中，使用了 JS 对象来描述真实的 DOM 结构。虚拟 DOM 和 JS 对象之间的关系：前者是一种思想，后者是这种思想的具体实现。\n\n使用虚拟DOM有如下的优点:\n\n * 相较于DOM的体积和速度优势\n\n * 多平台渲染的抽象能力\n\n相较于 DOM 的体积和速度优势\n\n * JS 层面的计算的速度， 要比DOM层面的计算快得多 。DOM对象最终要被浏览器显示出来之前，浏览器会有很多工作要做(浏览器渲染原理)\n   。DOM上面的属性也是非常多的\n * 虚拟DOM发挥优势的时机主要体现在更新的时候，相比较innerHTML要将已有的DOM节点全部销毁，虚拟DOM能够做到针对DOM节点做最小程度的修改\n\n多平台渲染的抽象能力\n\n * 浏览器、Node.js宿主环境使用 ReactDOM 包\n\n * Native宿主环境使用 ReactNative 包\n\n * Canvas、 SVG或者VML (IE8) 宿主环境使用 ReactArt 包\n\n * ReactTest包用于渲染出JS对象，可以很方便地测试\"不隶属于任何宿主环境的通用功能”\n\n在React中，通过JSX来描述UI, Jsx 仅仅是个语法糖， 会被Babel 编译为createElement 方法的调用。\n该方法调用之后会返回一个JS对象，该对象就是虚拟DOM对象，官方更倾向于称之为一个React 元素。","routePath":"/guide/react/advance/第二章/4-虚拟DOM","lang":"","toc":[{"text":"虚拟 DOM","id":"虚拟-dom","depth":2,"charIndex":-1},{"text":"为什么需要虚拟 DOM","id":"为什么需要虚拟-dom","depth":3,"charIndex":316},{"text":"React 中的虚拟 DOM","id":"react-中的虚拟-dom","depth":3,"charIndex":1548},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":1772}],"domain":"","frontmatter":{},"version":""},{"id":111,"title":"","content":"React 整体架构#\n\n> 问：是否了解过 React 的新架构？新的 Fiber 架构相较于之前的 Stack 架构有什么优势？\n\n浅显的回答：\n\n> Stack架构在进行虚拟DOM树比较的时候，采用的是递归，计算会消耗大量的时间，新的Fiber架构采用的是链表，可以实现时间切片，防止JS的计算占用过多的时\n> 间从而导致浏览器出现丢帧的现象。\n\nReact v15 以及之前的架构称之为 Stack 架构，从 v16 开始，React 重构了整体的架构，新的架构被称之为 Fiber\n架构，新的架构相比旧架构有一个最大的特点就是能够实现时间切片。\n\n * 旧架构的问题？\n * 新架构的解决思路\n\n\n旧架构的问题#\n\n> React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式\n\n有哪些情况会导致我们的Web应用无法快速响应?\n\n总结起来，实际上有两大类场景会限制快速响应:\n\n * 当你需要执行大量计算或者设备本身的性能不足的时候，页面就会出现掉帧、卡顿的现象，这个本质上是来自于 CPU 的瓶颈\n * 进行 I/O 的时候，需要等待数据返回后再进行后续操作，等待的过程中无法快速响应，这种情况实际上是来自于 I/O 的瓶颈\n\nCPU 瓶颈#\n\n平时我们在浏览网页的时候，这张网页实际上是由浏览器绘制出来的，就像一个画家画画一样\n\n平时我们所浏览的网页，里面往往会有一些动起来的东西，比如轮播图、百叶窗之类的，本质其实就是浏览器不停的在进行绘制。\n\n目前，大多数设备的刷新频率为60FPS,意味着1秒钟需要绘制60次，1000ms / 60= 16.66ms，也就是说浏览器每隔 16.66ms\n就需要绘制一帧。\n\n浏览器在绘制一帧画面的时候，实际上还有很多的事情要做（浏览器渲染原理）\n\n\n\n绘制画面的任务被称之为“渲染流水线”，每次执行流水线的时候，大致是需要如上的一些步骤，但是并不是说每一次所有的任务都需要全部执行：\n\n * 当通过 JS 或者 CSS 修改 DOM 元素的几何属性(比如长度、 宽度)时，会触发完整的渲染流水线，这种情况称之为重排(回流)\n * 当修改的属性不涉及几何属性(比如字体、颜色)时，会省略掉流水线中的Layout、Layer 过程，这种情况称之为重绘\n * 当修改\"不涉及重排、重绘的属性(比如 transform\n   属性)\"时，会省略流水线中Layout、Layer、Print过程，仅执行合成线程的绘制工作，这种情况称之为合成\n\n按照性能高低进行排序的话：合成>重绘>重排\n\n前面说过，浏览器绘制的频率是16.66ms 一帧，但是执行 JS\n与渲染流水线实际上是在同一个线程上面执行，也就意味着如果JS执行的时间过长，不能够及时的渲染下一帧，也就意味着页面掉帧，表现出来的现象就是页面卡顿\n\n在React v15 之前就存在这个问题，JS 代码执行的时间过长。在 React 中，需要去计算整颗虚拟 DOM 树，虽然说是 JS 层面的计算，相比直接操作\nDOM，节省了很多时间，但是每次重新去计算整颗虚拟 DOM 树，会造成每一帧的 JS\n代码的执行时间过长，从而导致动画、还有一些实时更新得不到及时的响应，造成卡顿的视觉效果。\n\n在 React v16 版本之前，进行两颗虚拟 DOM\n树的对比的时候，需要涉及到遍历上面的结构，这个时候只能使用递归，而且这种递归是不能够打断的，一条路走到黑，从而造成了 JS 执行时间过长。\n\n这样的架构模式，官方就称之为 Stack 架构模式，因为采用的是递归，会不停的开启新的函数栈。\n\nI/O 瓶颈#\n\n对于前端开发来讲，最主要的 I/O 瓶颈就是网络延迟。\n\n网络延迟是一种客观存在的现象，那么如何减少这种现象对用户的影响呢? React团队给出的答案是:将人机交互的研究成果整合到UI中。\n\n用户对卡顿的感知是不一样的，输入框哪怕只有轻微的延迟，用户也会认为很卡，假设是加载一个列表，哪怕 loading 好几秒，用户也不会觉得卡顿\n\n对于React来讲，所有的操作都是来自于自变量的变化导致的重新渲染，我们只需要针对不同的操作赋予不同的优先级即可。\n\n具体来说，主要包含以下三个点:\n\n * 为不同操作造成的\"自变量变化\"赋予不同的优先级\n * 所有优先级统一调度，优先处理\"最高优先级的更新\"\n * 如果更新正在进行(进入虚拟DOM 相关工作)，此时有\"更高优先级的更新\"产生的话，中段当前的更新，优先处理高优先级更新\n\n要实现上面的这三个点，就需要 React 底层能实现:\n\n * 用于调度优先级的调度器\n * 调度器对应的调度算法\n * 支持可中断的虚拟 DOM 的实现\n\n所以不管是解决 CPU 的瓶颈还是 I/O 的瓶颈，底层的诉求都是需要实现 time slice(时间切片)\n\n\n新架构的解决思路#\n\n解决 CPU 瓶颈#\n\n从 React v16 开始，官方团队正式引用了 Fiber 的概念，这是一种通过链表来描述 UI 的方式，本质上你也可以看作是一种虚拟 DOM的实现\n\n> 与其将\"Virtual\n> DOM\"视为一种技术，不如说它是一种模式，一种编程概念。人们提到它时经常是要表达不同的东西。在React的世界里，术语\"Virtual\n> DOM\"通常与React元索关联在一起，因为它们都是代表了用户界面的对象。而React也使用一个名为\"fibers\"的内部对象来存放组件树的附加信息。上述二\n> 者也被认为是React中\"Virtual DOM\"实现的一部分。\n\nFiber 本质上也是一个对象，但是和之前 React 元素不同的地方在于对象之间使用链表的结构串联起来，child 指向子元素，sibling\n指向兄弟元素，return 指向父元素。\n\n如下图：\n\n\n\n使用链表这种结构，有一个最大的好处就是在进行整颗树的对比(reconcile) 计算时，这个过程是可以被打断。\n\n在发现一帧时间已经不够，不能够再继续执行JS,需要渲染下一帧的时候，这个时候就会打断 JS 的执行，优先渲染下一帧。渲染完成后再接着回来完成上一次没有执行完的\nJS 计算。\n\n官方还提供了一个 Stack 架构和 Fiber 架构的对比示例: 对比实例网址\n\n两个案例打开后你会发现 Stack 架构一卡一卡的，而 Fiber 非常流畅\n\n下面是 React 源码中创建 Fiber 对象的相关代码：\n\n\n\n解决 I/O 瓶颈#\n\n从React v16 开始引入了 Scheduler (调度器)，用来调度任务的优先级。\n\nReact v16之前：\n\n * Reconciler (协调器) : vdom的实现，根据自变量的变化计算出UI的变化\n * Renderer (渲染器) ：负责将UI的变化渲染到宿主环境\n\n从Reactv16开始，多了一个组件：\n\n * Scheduler (调度器) :调度任务的优先级，高优先级的任务会优先进入到Reconciler\n * Reconciler (协调器) : vdom的实现，根据自变量的变化计算出UI的变化\n * Renderer (渲染器) :负责将UI的变化渲染到宿主环境\n\n新架构中，Reconciler 的更新(计算)流程也从之前的递归变成了\"可中断的循环过程\"。\n\n\n\n每次循环都会调用 shouldYield 判断当前的时间切片是否有足够的剩余时间，如果没有足够的剩余时间，就暂停 reconciler\n的执行，将主线程还给渲染流水线，进行下一帧的渲染操作，渲染工作完成后，再等待下一个宏任务进行后续代码的执行。\n\n\n问题解答#\n\n问：是否了解过 React 的架构?新的 Fiber 架构相较于之前的 Stack 架构有什么优势?\n\n答：\n\nReact v15及其之前的架构：\n\n * Reconciler (协调器) : VDOM 的实现，负责根据自变量变化计算出UI变化\n * Renderer (渲染器) :负责将UI变化渲染到宿主环境中\n\n这种架构称之为 Stack 架构，在 Reconciler 中，mount 的组件会调用mountComponent，update 的组件会调用\nupdateComponent，这两个方法都会递归更新子组件，更新流程一旦开始，中途无法中断。\n\n但是随着应用规模的逐渐增大，之前的架构模式无法再满足\"快速响应\"这一需求， 主要受限于如下两个方面:\n\n * CPU瓶颈：由于 VDOM 在进行差异比较时，采用的是递归的方式，JS计算会消耗大量的时间，从而导致动画、还有一些需要实时更新的内窗产生视觉上的卡顿。\n * I/O瓶颈：由于各种基于\"自变量”\"变化而产生的更新任务没有优先级的概念，因此在某些更新任务(例如文本框的输入)有稍微的延迟，对于用户来讲也是非常敏感的，\n   会让用户产生卡顿的感觉。\n\n新的架构称之为 Fiber 架构:\n\n * Scheduler (调度器) :调度任务的优先级，高优先级任务会优先进入到Reconciler\n * Reconciler (协调器) : VDOM的实现，负责根据自变量变化计算出UI变化\n * Renderer (渲染器) :负责将UI变化渲染到宿主环境中\n\n首先引入了 Fiber 的概念，通过一个对象来描述一个 DOM 节点，但是和之前方案不同的地方在于，每个Fiber对象之间通过链表的方式来进行串联。通过\nchild 来指向子元素，通过 sibling 指向兄弟元素，通过 return 来指向父元素。\n\n在新架构中，Reconciler 中的更新流程从递归变为了\"可中断的循环过程\"。每次循环都会调用 shouldYield 判断当前的 TimeSlice\n是否有剩余时间，没有剩余时间则暂停更新流程，将主线程还给渲染流水线，等待下一个宏任务再继续执行。这样就解决了CPU的瓶颈问题。\n\n另外在新架构中还引入了 Scheduler 调度器用来调度任务的优先级，从而解决了 I/O 的瓶颈问题。","routePath":"/guide/react/advance/第二章/5-React 整体架构","lang":"","toc":[{"text":"React 整体架构","id":"react-整体架构","depth":2,"charIndex":-1},{"text":"旧架构的问题","id":"旧架构的问题","depth":3,"charIndex":303},{"text":"CPU 瓶颈","id":"cpu-瓶颈","depth":4,"charIndex":534},{"text":"I/O 瓶颈","id":"io-瓶颈","depth":4,"charIndex":1507},{"text":"新架构的解决思路","id":"新架构的解决思路","depth":3,"charIndex":2015},{"text":"解决 CPU 瓶颈","id":"解决-cpu-瓶颈","depth":4,"charIndex":2026},{"text":"解决 I/O 瓶颈","id":"解决-io-瓶颈","depth":4,"charIndex":2680},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":3167}],"domain":"","frontmatter":{},"version":""},{"id":112,"title":"","content":"React 渲染流程#\n\n> 问：是否了解过 React 的整体渲染流程？里面主要有哪些阶段？\n\n现代前端框架都可以总结为一个公式：\n\n> UI = f (state)\n\n上面的公式还可以进行一个拆分：\n\n * 根据自变量 (state) 的变化计算出 UI 的变化\n * 根据 UI 的变化执行具体的宿主环境的 API\n\n对应的公式：\n\n\n\n对应到 React 里面就两大阶段：\n\n * render 阶段： 调合虚拟 DOM，计算出最终要渲染出来的虚拟 DOM\n * commit 阶段：根据上一步计算出来的虚拟 DOM，渲染具体的 UI\n\n每个阶段对应不同的组件：\n\n\n\n * 调度器 (Scheduler) ：调度任务，为任务排序优先级，让优先级高的任务先进入到 Reconciler\n * 协调器 (Reconciler) ：生成 Fiber 对象，收集副作用，找出哪些节点发生了变化，打上不同的 flags，著名的 Diff\n   算法也是在这其中执行的\n * 渲染器 (Renderer) ：根据协调器计算出来的虚拟 DOM 同步地渲染节点到视图上\n\n接下来我们来看一个例子：\n\n\n\n当用户点击按钮时，首先是由 Scheduler 进行任务的调度，排序任务优先级，render 阶段的工作流程是可以随时被以下原因中断：\n\n * 有其他更高优先级的任务需要执行\n * 当前的 time slice（时间切片）没有剩余的时间\n * 发生了其他错误\n\n注意上面的 render 阶段是在内存中进行的，不会更新宿主环境 UI，因此这个阶段即使工作流程反复被中断，用户也不会看到更新不完整的 UI\n\n当 Scheduler 调度完成后，将任务交给 Reconciler，Reconciler 需要计算出新的 UI，最后就由 Renderer 同步进行渲染更新\n\n如下图所示：\n\n\n\n\n调度器#\n\n在 React v16 版本之前，采用的是 Stack 架构，所有任务只能同步进行，无法被打断，这就导致浏览器可能会出现丢帧的现象，表现出卡顿。React\n为了解决这个问题，从 v16 版本开始从架构上面进行了两大更新：\n\n * 引入了 Fiber\n * 新增了 Scheduler\n\nScheduler 在浏览器的原生 API 中实际上是有类似的实现的，这个API就是 requestIdleCallback\n\nrequestIdleCallback#\n\n尝试一下：\n\n\n\n查看控制台：\n\n\n\n我们会发现有些时间有 50ms 或者接近 50ms，为什么呢？\n\n虽然每一帧绘制的时间约为16.66ms，但是如果屏幕没有刷新，那么浏览器会安排长度为 50ms 左右的空闲时间\n\n为什么是 50ms 呢？\n\n根据研究报告表明，用户操作之后，100ms 以内的响应给用户的感觉都是瞬间发生，也就是说不会感受到延迟感，因此将空闲时间设置为 50ms，浏览器依然还剩下\n50ms 可以处理用户的操作响应，不会让用户感到延迟。\n\n我们可以通过 requestIdleCallback 来模拟一下 Scheduler 的工作流程\n\n\n\n然后我们查看一下控制台：\n\n\n\n类似机制#\n\n虽然浏览器有类似的 API，但是 React 团队并没有使用该API，因为该 API 存在兼容性问题。因此 React\n团队自己实现了一套这样的机制，这个就是调度器 Scheduler。\n\nReact 团队单独发行了 Scheduler，这意味着调度器不仅仅只能在 React 中使用，凡是有涉及到任务调度需求的项目都可以使用 Scheduler\n\n\n协调器#\n\n协调器是 render 阶段的第二阶段工作，类组件或者函数组件本身就是在这个阶段被调用的。\n\n协调器起点和流程#\n\n根据 Scheduler 调度结果的不同，协调器起点可能是不同的\n\n * performSyncWorkOnRoot（同步更新流程）\n\n\n\n * performConcurrentWorkOnRoot（并发更新流程）\n\n\n\n新的架构使用 Fiber (对象) 来描述 DOM 结构，最终需要形成一颗 Fiber tree，不过这棵树是通过链表的形式串联在一起的，流程如下\n\n * workInProgres 代表的是当前的 FiberNode\n * performUnitOfWork 方法会创建下一个 FiberNode，并且还会将已创建的 FiberNode 连接起来(通过\n   child、return、sibling)，从而形成一个链表结构的 Fiber tree\n * 如果 workInProgres 为 null，说明已经没有下一个 FiberNode，也就是说明整棵 Fiber tree 树已经构建完毕\n * 上面两个方法唯一的区别就是是否调用了 shouldYield 方法，该方法表明了是否可以中断。\n\nperformUnitOfWork 工作流程#\n\nperformUnitOfWork 在创建下一个 FiberNode 的时候，整体上的工作流程可以分为两大块：\n\n * 递阶段\n * 归阶段\n\n递阶段#\n\n递阶段会从 HostRootFiber 开始向下，以深度优先的原则进行遍历，遍历到的每一个 FiberNode 执行 beginWork\n方法。该方法会根据传入的 FiberNode 创建下一级的 FiberNode，此时可能存在两种情况：\n\n * 下一级只有一个元素，beginWork 方法会创建对应的 FiberNode，并与 workInProgress 连接\n   \n   \n   \n   这里就会创建 li 对应的 FiberNode，类似如下：\n   \n   \n\n * 下一级有多个元素，这时 beginWork 会依次创建所有的子 FiberNode 并且通过 sibling 连接到一起，每个子 FiberNode\n   也会和 workInProgress 连接\n   \n   \n   \n   此时会创建3个 li 对应的 FiberNode，连接情况类似如下：\n   \n   \n\n由于采用的是深度优先的原则，因此无法再往下走的时候，会进入到归阶段。\n\n归阶段#\n\n归阶段会调用 completeWork 方法来处理 FiberNode，做一些副作用的收集\n\n当某个 FiberNode 执行完了 completeWork 方法后，如果存在兄弟元素，就会进入到兄弟元素的递阶段，如果不存在兄弟元素，就会进入父\nFiberNode 的归阶段\n\n\n\n最后我们来看一个图：\n\n\n\n\n渲染器#\n\nRenderer 工作的阶段被称之为 commit 阶段。该阶段会将各种副作用 commit 到宿主环境的 UI 中。\n\n相较于之前的 render 阶段可以被打断，commit 阶段一旦开始就会同步执行直到完成渲染工作。\n\n整个渲染器渲染过程中可以分为三个子阶段：\n\n * BeforeMutation 阶段\n * Mutation 阶段\n * Layout 阶段\n\n\n\n\n问题解答#\n\n问：是否了解过 React 的整体渲染流程？里面主要有哪些阶段？\n\n答：\n\nReact 整体的渲染流程可以分为两大阶段，分别是 render 阶段和 commit 阶段。\n\n * render 阶段里面会经由调度器和协调器处理，此过程是在内存中运行，是异步可中断的。\n\n * commit 阶段会由渲染器进行处理，根据副作用进行UI的更新，此过程是同步不可中断的，否则会造成UI和数据显示不一致。\n\nReact 整体架构分为调度器，协调器，渲染器\n\n * 调度器\n\n调度器的主要工作就是调度任务，让所有的任务有优先级的概念，这样的话紧急的任务可以优先执行。\n\nScheduler 实际上在浏览器的 API 中是有原生实现的，这个 API 叫做 requestIdleCallback，但是由于兼容性问题，React\n放弃了使用这个API，而是自己实现了一套这样的机制，并且把 Scheduler 这个包单独的进行发布，变成一个独立的包。\n\n这就意味Scheduler 不仅仅是只能在React 中使用，后面如果有其他的项目涉及到了任务调度的需求，都可以使用这个Scheduler。\n\n * 协调器\n\n协调器是 Render 的第二阶段工作。该阶段会采用深度优先的原则遍历并且创建一个一个的\nFiberNode，并将其串联在一起，在遍历时分为了\"递\"与\"归\"两个阶段。\n\n在\"递\"阶段会执行 beginWork 方法，该方法会根据传入的 FiberNode 创建下一级 FiberNode。\n\n在\"归\"阶段则会执行 completeWork 方法，做一些副作用的收集\n\n * 渲染器\n\n渲染器的工作主要就是将各种副作用(flags 表示) commit 到宿主环境的UI中。\n\n整个阶段可以分为三个子阶段，分别是 BeforeMutation 阶段、Mutation 阶段和 Layout 阶段。","routePath":"/guide/react/advance/第二章/6-React 渲染流程","lang":"","toc":[{"text":"React 渲染流程","id":"react-渲染流程","depth":2,"charIndex":-1},{"text":"调度器","id":"调度器","depth":3,"charIndex":793},{"text":"requestIdleCallback","id":"requestidlecallback","depth":4,"charIndex":1006},{"text":"类似机制","id":"类似机制","depth":4,"charIndex":1326},{"text":"协调器","id":"协调器","depth":3,"charIndex":1509},{"text":"协调器起点和流程","id":"协调器起点和流程","depth":4,"charIndex":1562},{"text":"performUnitOfWork 工作流程","id":"performunitofwork-工作流程","depth":4,"charIndex":2037},{"text":"渲染器","id":"渲染器","depth":3,"charIndex":2738},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":2932}],"domain":"","frontmatter":{},"version":""},{"id":113,"title":"","content":"","routePath":"/guide/react/advance/第二章/7-Fiber双缓冲","lang":"","toc":[{"text":"Fiber双缓冲","id":"fiber双缓冲","depth":2,"charIndex":-1},{"text":"对 Fiber 的理解","id":"对-fiber-的理解","depth":3,"charIndex":-1},{"text":"Fiber 双缓冲","id":"fiber-双缓冲","depth":3,"charIndex":-1},{"text":"**mount阶段**","id":"mount阶段","depth":4,"charIndex":-1},{"text":"**update阶段**","id":"update阶段","depth":4,"charIndex":-1},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":114,"title":"","content":"给 port1 发消息 给 port2 发消息","routePath":"/guide/react/advance/第二章/8-MessageChannel","lang":"","toc":[{"text":"MessageChannel","id":"messagechannel","depth":2,"charIndex":-1},{"text":"回顾事件循环","id":"回顾事件循环","depth":3,"charIndex":-1},{"text":"MessageChannel 以及为什么选择它","id":"messagechannel-以及为什么选择它","depth":3,"charIndex":-1},{"text":"为什么不选择 setTimeout","id":"为什么不选择-settimeout","depth":4,"charIndex":-1},{"text":"为什么没有选择 requestAnimationFrame","id":"为什么没有选择-requestanimationframe","depth":4,"charIndex":-1},{"text":"为什么没有选择包装成一个微任务？","id":"为什么没有选择包装成一个微任务","depth":4,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":115,"title":"","content":"React 入门篇#\n\n这是接下来入门篇的学习目标\n\n\n第一章#\n\n * React核心概念\n   * React基本介绍\n   * React中的组件\n   * 组件状态传递\n   * 事件\n   * 生命周期\n   * 表单\n * Hooks\n   * Hooks介绍\n   * useState\n   * useEffect\n\n\n第二章#\n\n * React-Router-Dom v6\n   * v6 版本 router的基本使用\n   * 完成学生管理系统\n * React-redux\n   * redux核心概念\n   * react-redux的基本使用\n   * 完善学生管理系统\n\n\n第三章#\n\n * Coder Station项目介绍\n * 完成Coder Station前台项目\n\n\n第四章#\n\n * dva的基本使用\n * antd和antdpro\n * Umi4 基本介绍\n * 完成Coder Station后台项目","routePath":"/guide/react/base/","lang":"","toc":[{"text":"React 入门篇","id":"react-入门篇","depth":2,"charIndex":-1},{"text":"第一章","id":"第一章","depth":3,"charIndex":27},{"text":"第二章","id":"第二章","depth":3,"charIndex":167},{"text":"第三章","id":"第三章","depth":3,"charIndex":301},{"text":"第四章","id":"第四章","depth":3,"charIndex":353}],"domain":"","frontmatter":{},"version":""},{"id":116,"title":"","content":"React 基本介绍#\n\n本章主要包含以下内容：\n\n * React基本介绍\n * React特点\n * 搭建开发环境\n\n\nReact 基本介绍#\n\nReact起源于Facebook的内部项目，因为该公司对市场上所有JavaScript MVC框架都不满意，就决定自己写-套，用来架设Instagram的网站。\n\nReact的实质其实是一个用于构建用户界面的JavaScript库。React 主要用于构建Ul。React\n于2013年5月开源，由于拥有较高的性能，代码逻辑简单，越来越多的人已开始关注和使用它。\n\n> UI = fn(state)\n\n由于React的设计思想极其独特，属于革命性创新，性能出众，所以，越来越多的人开始关注和使用，认为它可能是将来Web开发的主流工具。\n\n这个项目本身也越滚越大，从最早的UI引擎变成了-整套前后端通吃的Web App解决方案。\n\nReact 官网：英文网, 中文网\n\nReact 从诞生到现在，一直带给我们惊喜，如全新的Hooks概念等，从2015年开始，每年都会举行 React Conf\n大会，介绍React本年度所更新的新特性有哪些\n\n> React Conf官网：https://conf.react.dev/\n\n介绍React几个重要版本的更新：\n\n * React 16：出现了 Fiber，弃用了 Stack 架构，整个更新变的可中断、可分片、具有优先级\n * React 16.8：推出了 Hooks，标志着从类组件正式转为函数组件\n * React 17：过渡版本，没有添加任何面向开发人员的新功能，主要侧重升级简化 React 本身\n * React 18\n   * transition\n   * Suspense\n   * 新的 Hooks\n   * Offscreen\n   * .......\n\n\nReact 特点#\n\n在React官网，罗列了3个特点\n\n * 声明式\n * 组件化\n * 一次学习，跨平台编写\n\n除此之外，React还具有以下特点：\n\n * 单项数据流\n * 虚拟DOM\n * Diff算法\n\n\n搭建开发环境#\n\n虽然官方提供了通过CDN引入React的方式：https://zh-hans.legacy.reactjs.org/docs/cdn-links.html\n\n但实际开发肯定使用React的脚手架工具来搭建，如之前提供的React官方脚手架工具https://create-react-app.dev/docs/gett\ning-started/\n\n快速开始\n\n\n\n官网的新站点现在最近推荐通过Nextjs开始，但这是服务端渲染框架，不建议先从这开始，我们也可以通过Vite来搭建，根据提示选择即可\n\n\n\n> create-react-app：通过webpack搭建\n\n进去后，只留public下的favicon.ico和index.html，src下的App.js和index.js即可，这样简洁，有报错一般就是引入没了，删除就\n行","routePath":"/guide/react/base/第一章/1-React基本介绍","lang":"","toc":[{"text":"React 基本介绍","id":"react-基本介绍","depth":2,"charIndex":61},{"text":"React 基本介绍","id":"react-基本介绍-1","depth":3,"charIndex":-1},{"text":"React 特点","id":"react-特点","depth":3,"charIndex":787},{"text":"搭建开发环境","id":"搭建开发环境","depth":3,"charIndex":895}],"domain":"","frontmatter":{},"version":""},{"id":117,"title":"","content":"JSX 基础语法#\n\n本章主要包括以下内容：\n\n * JSX 基础语法\n * createElement 方法\n\n\nJSX 基础语法#\n\n在 React 中，使用JSX来描述页面。\n\n\n\n你可以把类似于 HTML 的代码单独提取出来，例如：\n\n\n\n\n\n注意这种类似于 HTML 的语法在 React 中称之为 JSX,这是一种 JavaScript 的语法扩展。在 React 中推荐使用 JSX\n来描述用户界面。JSX 乍看起来可能比较像是模版语言，但事实上它完全是在 JavaScript 内部实现的。\n\n使用 JSX 来描述页面时，有如下的一些语法规则：\n\n * 根元素只能有一个 如下，这样会报错，需要在两个 div 外面包裹一个标签\n\n> <></>也可以用来包裹，表示空标签，这样不会显示在 DOM 中\n\n\n\n * JSX 中使用 Javascript 表达式。表达式写在花括号{}中\n\n\n\n * 属性值指定为字符串字面量，或者在属性值中插入一个 Javascript 表达式\n\n\n\n * style 对应样式对象，class 要写作 className，且要驼峰命名写样式\n\n\n\n * 注释需要写在花括号，指的是 jsx 里面的注释\n\n\n\n * JSX 允许在模板中插入数组，数组会自动展开所有成员\n\n\n\n> 可以装 vscode 插件：搜索 React，可自行选择喜欢的插件，如 ES7 React/Redux/React-Native snippets for\n> es6/es7\n\n\ncreateElement 方法#\n\n如果你输出到了 arr2，会发现 arr2 输出的其实是一段不一样的，而且 JSX 是一种 Javascript 的语法扩展，它是通过 Babel\n会把JSX转译成一个名为 React.createElement 函数调用。\n\n\n\n参数说明：\n\n * type：创建的 React 元素类型（可选的值有：标签名字符串、React 组件）。\n * props（可选）：React 元素的属性。\n * children（可选）：React 元素的子元素。\n\n例如：下面两种代码的作用完全是相同的：\n\n\n\n这些对象被称为\"React 元素\"。它们描述了你希望在屏幕上看到的内容。\n\n可以看出，JSX 的本质其实就是 React.createElement 方法的一种语法糖\n\n> React 就是为了方便书写，所以才使用 JSX 来书写","routePath":"/guide/react/base/第一章/2-JSX基础语法","lang":"","toc":[{"text":"*JSX* 基础语法","id":"jsx-基础语法","depth":2,"charIndex":-1},{"text":"*JSX* 基础语法","id":"jsx-基础语法-1","depth":3,"charIndex":-1},{"text":"createElement 方法","id":"createelement-方法","depth":3,"charIndex":651}],"domain":"","frontmatter":{},"version":""},{"id":118,"title":"","content":"组件与事件绑定#\n\n本章包含以下内容：\n\n * React 中的组件\n * 为组件绑定事件\n * this 的指向\n * 向事件处理程序传递参数\n\n\nReact 中的组件#\n\n在 React 中，可以使用类的方式来声明一个组件。\n\n\n\n除了类组件，React 中还支持使用函数来创建组件，同样需要返回一段 JSX，来表示这个组件的 UI 是什么样的。\n\n\n\n早期的函数组件被称之为无状态组件，一般仅仅用来做纯 UI 的展示，里面不会有复杂的逻辑。 但是从 React 16.8 推出 Hooks\n后，现在更多的是使用函数组件了。 这不仅仅是语法的改变，同时也代表着整个 React 编程思想的一种转变。\n\n\n为组件绑定事件#\n\n在 React 中绑定事件的写法如下：\n\n\n\n在 React 中无法通过 return false 来阻止默认行为，所以只有使用e.preventDefault的方式来阻止默认行为。\n\n\n\n如果是类组件，那么事件处理函数写作一个类方法。\n\n\n\n在 React 的事件处理函数中所传入的事件对象，是一个合成事件对象。 React 也提供了访问原生事件对象的方式。如下:\n\n\n\n\nthis 的指向#\n\n由于 JS 中 this 的特殊性，事件处理函数中的 this 并不会指向当前的组件，这就需要我们自行对 this 进行指向的修正。\n\n这里介绍 3 种解决方式:\n\n * 将事件处理函数修改为箭头函数\n * 将事件绑定修改为箭头函数\n * 使用 bind 方法来强制绑定 this 的指向\n\n\n\n> this 的修正，只针对类组件，函数组件不需要用到 this\n\n\n向事件处理程序传递参数#\n\n另外还有一个非常重要的问题，就是如何向事件处理程序传递参数。\n\n如果要传递参数，可以使用下面的两种方式来进行传参:\n\n * 通过 bind 方法在绑定 this 指向时向事件处理函数进行传参\n * 绑定事件时，通过书写箭头函数的形式来传参\n\n\n\n> 上面只包括类组件，函数组件的传参很容易，如下\n\n","routePath":"/guide/react/base/第一章/3-组件与事件绑定","lang":"","toc":[{"text":"组件与事件绑定","id":"组件与事件绑定","depth":2,"charIndex":-1},{"text":"React 中的组件","id":"react-中的组件","depth":3,"charIndex":74},{"text":"为组件绑定事件","id":"为组件绑定事件","depth":3,"charIndex":303},{"text":"this 的指向","id":"this-的指向","depth":3,"charIndex":501},{"text":"向事件处理程序传递参数","id":"向事件处理程序传递参数","depth":3,"charIndex":695}],"domain":"","frontmatter":{},"version":""},{"id":119,"title":"","content":"React 前言#\n\n本章你将从入门开始，了解 React 的基本概念，并使用 React 进行开发。\n\n\n学习目标#\n\n * 入门篇\n * 进阶篇\n * 源码篇\n\n个人实现的手写 React: suReact","routePath":"/guide/react/","lang":"","toc":[{"text":"React 前言","id":"react-前言","depth":2,"charIndex":-1},{"text":"学习目标","id":"学习目标","depth":3,"charIndex":53}],"domain":"","frontmatter":{},"version":""},{"id":120,"title":"","content":"React 源码篇#\n\n本章你将从源码开始","routePath":"/guide/react/senior/","lang":"","toc":[{"text":"React 源码篇","id":"react-源码篇","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":121,"title":"","content":"Scheduler 调度普通任务#\n\nScheduler 的核心源码位于 package/scheduler/src/forks/Scheduler.js，如下：\n\n\n\n\nSchedulerCallback#\n\n该函数的主要目的就是用调度任务，该方法的分析如下:\n\n\n\n该方法主要注意以下几个关键点：\n\n * 关于任务队列有两个，一个 taskQueue，另一个是 timerQueue，taskQueue 存放普通任务，timerQueue\n   存放延时任务，任务队列内部用到了小顶堆的算法，保证始终放进去 (push) 的任务能够进行正常的排序，回头通过 peek\n   取出任务时，始终取出的是时间优先级最高的那个任务\n * 根据传入的不同的priorityLevel，会进行不同的 timeout 的设置，任务的 timeout\n   时间也就不一样了，有的比当前时间还要小，这个代表立即需要执行的，绝大部分时间比当前时间大。\n * 不同的任务，最终调用的函数不一样\n   * 普通任务调用 requestHostCallback\n   * 延时任务调用 requestHostTimeout\n\n\nrequestHostCallback#\n\n该方法主要就是调用 schedulePerformWorkUntilDeadline 方法\n\n\n\n\nschedulePerformWorkUntilDeadline#\n\n该方法一开始是 undefined，根据不同的环境选择不同生成宏任务的方式(一般就是 MessageChannel)\n\n\n\n\nperformWorkUntilDeadline#\n\n该方法主要就是在调用\nflushWork，调用之后返回一个布尔值，根据布尔值来判断是否还有剩余的任务，如果还有，就是用messageChannel进行一个宏任务的包装，\n放入到任务队列里面\n\n\n\n\nflashWork#\n\n核心就是调用 workLoop 函数\n\n\n\n\nworkLoop#\n\n\n\n首先有一个 while 循环，该while循环保证了能够从任务队列中不停的取任务出来\n\n\n\n当然，不是说一直从任务队列里面取任务出来执行就完事，每次取出一个任务后，我们还需要一系列的判断\n\n\n\n * currentTask.expirationTime > currentTime 表示任务还没有过期\n * shouldYieldToHost 任务是否应该暂停，归还主线程\n * 如果进入if，说明因为某些原因不能再执行任务，需要立即归还主线程，那么我们就跳出while\n\n\nshouldYieldToHost#\n\n首先计算 timeElapsed，然后判断是否超时，没有的话就返回 false，表示不需要归还，否则就返回 true，表示需要归还\n\nframeInterval 默认设置是 5ms\n\n\n\n\nadvanceTimers#\n\n该方法就是遍历整个 timerQueue，查看是否有已经过期的方法，如果有，不是直接执行，而是将这个过期的方法添加到 taskQueue\n\n","routePath":"/guide/react/senior/第一章/1-Scheduler 调度普通任务","lang":"","toc":[{"text":"Scheduler 调度普通任务","id":"scheduler-调度普通任务","depth":2,"charIndex":-1},{"text":"SchedulerCallback","id":"schedulercallback","depth":3,"charIndex":85},{"text":"requestHostCallback","id":"requesthostcallback","depth":3,"charIndex":503},{"text":"schedulePerformWorkUntilDeadline","id":"scheduleperformworkuntildeadline","depth":3,"charIndex":575},{"text":"performWorkUntilDeadline","id":"performworkuntildeadline","depth":3,"charIndex":673},{"text":"flashWork","id":"flashwork","depth":3,"charIndex":799},{"text":"workLoop","id":"workloop","depth":3,"charIndex":834},{"text":"shouldYieldToHost","id":"shouldyieldtohost","depth":3,"charIndex":1085},{"text":"advanceTimers","id":"advancetimers","depth":3,"charIndex":1200}],"domain":"","frontmatter":{},"version":""},{"id":122,"title":"","content":"Scheduler 调度延时任务#\n\n\nunstable_scheduleCallback#\n\n可以看到，调度一个延时任务的时候，主要是执行 requestHostTimeout\n\n\n\n\nrequestHostTimeout#\n\n可以看到，requestHostTimeout 实际上就是调用 setTimeout，然后在 setTimeout 中，调用传入的 handleTimeout\n\n\n\n\nhandleTimeout#\n\nhandleTimeout 主要就是调用 advanceTimers，该方法的作用是将时间已经到了的延时任务放入到 taskQueue，那么现在\ntaskQueue 里面就有要执行的任务，然后使用 requestHostCallback 进行调度。\n\n如果 taskQueue 里面没有任务了，再次从 timerQueue 里面去获取延时任务，然后使用 requestHostTimeout 进行调度\n\n\n\n\n流程图#\n\nScheduler 这一块大致的流程图如下\n\n","routePath":"/guide/react/senior/第一章/2-Scheduler 调度延时任务","lang":"","toc":[{"text":"Scheduler 调度延时任务","id":"scheduler-调度延时任务","depth":2,"charIndex":-1},{"text":"unstable_scheduleCallback","id":"unstable_schedulecallback","depth":3,"charIndex":19},{"text":"requestHostTimeout","id":"requesthosttimeout","depth":3,"charIndex":93},{"text":"handleTimeout","id":"handletimeout","depth":3,"charIndex":198},{"text":"流程图","id":"流程图","depth":3,"charIndex":419}],"domain":"","frontmatter":{},"version":""},{"id":123,"title":"","content":"最小堆#","routePath":"/guide/react/senior/第一章/3-最小堆","lang":"","toc":[{"text":"最小堆","id":"最小堆","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":124,"title":"","content":"RN 基本介绍#\n\n本小节主要包含以下知识点：\n\n * 什么是 RN\n * RN 特点\n * 谁在使用 RN\n\n\n什么是 RN#\n\nRN 英文全称 ReactNative，是 Facebook 于 2015 年 4 月开源的跨平台移动应用开发框架，也是 Facebook 早先所开源的\nJavaScript 框架 React 在原生移动应用平台的衍生产物，目前支持 ios 和安卓两大平台。\n\nRN 使用 Javascript 和 React 中类似于 html 的 JSX，以及 css 来开发移动应用，因此熟悉 Web\n前端开发的技术人员只需很少的学习就可以快速进入移动应用开发领域。\n\nRN 官网：https://reactnative.dev/\n\n\n\nRN 中文网：https://reactnative.cn\n\n\n\n\nRN 特点#\n\n根据官网的介绍，RN 主要有如下的特点\n\n * 使用 React 来创建 Android 和 iOS 的原生应用\n * 预览速度快\n * 无缝跨平台\n\n使用 React 来创建 Android 和 iOS 的原生应用#\n\n目前来讲，我们的移动端应用主要分为三大类: WebApp、NativeApp 和 HybridApp。\n\nWebApp 指的是移动端的 Web 浏览器，其实和 PC 端的 Web 浏览器没有任何区别，只不过 Web 浏览器所依附的操作系统不再是 Windows 和\nLinux 了，而是 iOS 和 Android，WebApp 采用的技术主要是，传统的 HTML、JavaScript、 CSS 等 Web 技术栈，当然现在\nHTML5 也得到了广泛的应用。另外，WebApp 所访问的页面内容都是放在服务器端的，本质上就是 Web\n网页，所以天生就是跨平台的。不能在商店中下载，只能在移动设备浏览器中打开。\n\nNativeApp 指的是移动端的原生应用，对于 Android 是 apk，对于 iOS 就是 ipa。NativeApp 是一种基于手机操作系统(iOS 和\nAndroid)，并使用原生程序编写运行的第三方应用程序。NativeApp 的开发，Android 使用的语言通常是 Java 或者 Kotlin，iOS\n使用的语言是 Objective-C 或者Swift。通常来说，NativeApp\n可以提供比较好的用户体验以及性能，而且可以方便地操作手机本地资源，可在应用商店内进行下载，以 app 的形式打包。\n\nHybridApp，俗称混合应用，是介于 WebApp 和 NativeApp 两者之间的一种 App 形式，HybridApp 利用了 WebApp 和\nNativeApp 的优点，通过一个原生实现的 Native Container展示 HTML5\n的页面。更通俗的讲法可以归结为，在原生移动应用中嵌入了Webview，然后通过该 Webview 来访问网页。HybridApp\n具有维护更新简单，用户体验优异以及较好的跨平台特性，是目前主流的移动应用开发模式，可在应用商店内进行下载，以 app 的形式打开。\n\n那么，使用 RN 所开发的应用是属于哪一类呢?\n\n根据官方的介绍，RN 所开发最终产品是一个真正的移动应用，从使用感受上和原生应用相比几乎是无法区分的。\n\n\n\n在 RN 中所使用的基础 UI 组件会映射到原生应用中的对应组件。\n\nREACT NATIVE UI 组件   ANDROID 原生视图   IOS 原生视图   WEB 标签            说明\n                                               A non-scrolling   一个支持使用 flexbox 布局、样式、一些触摸处理和无障碍性控件的容器\n                                                                 显示、样式和嵌套文本字符串，甚至处理触摸事件\n                                                                 显示不同类型的图片\n                                                                 一个通用的滚动容器，可以包含多个组件和视图\n                                                                 使用户可以输入文本\n\n预览速度快#\n\n传统使用 Objective-C 或 Java 编写的原生应用，要预览效果，需要先将整个项目编译一次，而这个编译时间是比较耗时的。\n\nRN 让你可以快速迭代开发应用。比起传统原生应用漫长的编译过程，现在你可以在瞬间剧新你的应用。开启 Hot Reloading\n的话，甚至能在保持应用运行状态的情况下热替换新代码!\n\n\n\n无缝跨平台#\n\n使用 RN 所开发的移动端应用是无缝跨平台的，原生代码和 API 会被封装到 RN 组件中，开发者只需要掌握 React 和 JavaScript\n知识即可进行开发。\n\n\n\n\n谁在使用 RN#\n\nRN 从 2015 年开源至今，已经有非常多的国内外厂商选择使用 RN 来开发移动端应用，因为比起以前开发 Andriod 和 iOS\n应用要各自找一波开发工程师，现在只需要找一个前端工程师即可。\n\n\n\n更多使用厂商参见：https://reactnative.dev/showcase","routePath":"/guide/reactNative/1-快速入门/1-RN 基本介绍","lang":"","toc":[{"text":"RN 基本介绍","id":"rn-基本介绍","depth":2,"charIndex":-1},{"text":"什么是 RN","id":"什么是-rn","depth":3,"charIndex":56},{"text":"RN 特点","id":"rn-特点","depth":3,"charIndex":363},{"text":"使用 React 来创建 Android 和 iOS 的原生应用","id":"使用-react-来创建-android-和-ios-的原生应用","depth":4,"charIndex":447},{"text":"预览速度快","id":"预览速度快","depth":4,"charIndex":1921},{"text":"无缝跨平台","id":"无缝跨平台","depth":4,"charIndex":2090},{"text":"谁在使用 RN","id":"谁在使用-rn","depth":3,"charIndex":2186}],"domain":"","frontmatter":{},"version":""},{"id":125,"title":"","content":"快速搭建 RN 开发环境#\n\n要进行RN的开发，首先第一步 是搭建其开发环境。 官网为我们提供了搭建开发环境的详细步骤: 搭建开发环境\n\n\n\n其中给了我们两个选择：\n\n * 如果是学习阶段，想要快速体验 RN 开发，那么可以直接使用简易沙盒环境\n * 如果是要做完整的上线应用开发，那么可以搭建完整的原生环境\n\n这里我不希望大家一开始就在搭建环境这件事上消耗太多精力，因此我们先使用简易的沙盒环境，以便于能够快速进入到RN的开发学习。\n\n> 沙盒(英语: sandbox，又译为沙箱)，\n> 计算机术语，在计算机安全领域中是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。\n> 沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供用后即回收的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是\n> 严格限制。从这个角度来说，沙盒属于虚拟化的一种。\n> 沙盒中的所有改动对操作系统不会造成任何损失。通常，这种技术被计算机技术人员广泛用于测试可能带海的程序或是其他的恶意代码。\n\n首先第一步，我们需要安装 expo-cli，这是一个脚手架工具，可以帮助我们快速搭建一个 RN 的项目\n\n\n\n安装完毕后可以使用 expo -V 来查看所安装的脚手架版本\n\n> Node 高于16 可能还会报expo不支持17+以上\n\n\n\n接下来我们就可以快速拉取一个项目，使用命令expo init <项目名称>\n\n现在用本地的cli 创建会报如下的错误：\n\n\n\n> 原因参照博文：https://blog.expo.dev/the-new-expo-cli-f4250d8e3421\n\n新的 expo 版本提供了 npx 创建项目的方式，当然Node 版本需要高点比如18\n\n\n\n\n\n建议选择第二种，毕竟第一种官方都警告弃用了。\n\n首先让我们选择项目模板，如果不用 TypeScript 的话，一般选第一个即可。\n\n然后输入项目的名称，随意输入即可\n\n> 注：使用 expo-cli 拉取项目时，很多依赖需要搭建梯子才能安装，请搞定好科学上网\n\n在梯子稳定的环境下，拉取项目很快，如图，出现这个就证明对了，有些时候会下载依赖失败，检查好上网环境即可\n\n\n\n进入目录后，使用npm start运行，出现如下证明运行成功，有错误可以搜索解决\n\n\n\n接下来需要搞定 RN\n项目的预览环境。以前写PC网页的时候，电脑上的浏览器就是我们的预览环境，而现在我们使用RN开发的是移动端应用，因此自然预览环境使用的是我们的手机。\n\n除此之外，我们需要在手机上安装一个 expo-client 应用。\n\n你可以点击这里，然后下滑根据你的手机系统版本下载对应的 Client 的文件。\n\n\n\n当你打开后，可以输入网址或者扫描二维码，安卓expo应用自带扫描功能，ios的话可以使用自己的相机扫码，成功链接后会有个进度条，然后你应该看到如下：\n\n\n\n你的手机上也能看到这句话：Open up App.js to start working on your app!\n\n我们可以改一下这个话，改为 Hello React Native!，保存\n\n然后就会发现手机上的文字也变化了，这就是热更新了\n\n> 常见问题：如果报错如下\n> \n> \n> \n> 这个问题是你的rn目录路径上有空格和别的字符导致，建议放在无空格和全英文目录下\n> \n> 参考Github Issues解决方案","routePath":"/guide/reactNative/1-快速入门/2-快速搭建 RN 开发环境","lang":"","toc":[{"text":"快速搭建 RN 开发环境","id":"快速搭建-rn-开发环境","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":126,"title":"","content":"复习 React 基础知识#\n\n这里简单复习一下React中的几个核心概念：\n\n * components 组件\n * JSX\n * props 属性\n * state 状态\n\n\ncomponents 组件#\n\n在现代前端开发中，离不开组件化开发。将一个页面上的元素拆解成一个个组件， 能够极大程度的复用代码。\n\n在现在流行的三大框架中，无论是Angular、Vue 还是React,都支持组件化开发。其中在React中，支持两种书写组件的方式。\n\n函数式组件#\n\n在函数式组件中，一个函数就是一个组件， 在函数中会返回一段\nJSX。早期的函数式组件又被称之为无状态组件，但是自从Hook出来后，函数式组件也能够维持自身的状态。\n\n\n\nClass 组件#\n\nClass 类组件，一个组件就是一个 Class 类，这个类需要继承 Component 类，并且在该类中需要提供个 render 方法，在 render\n方法中返回一段 JSX\n\n早期的 Class\n类组件被称之为有状态组件，但是随着Hook的推出，函数组件也能维护自身的组件状态，因此现在Class类组件相比函数组件使用的频率有所降低，因为相比类，前端开发人\n员更加熟悉函数，并且避开了烦人的this。\n\n\n\n\nJSX#\n\n上面提到：无论是函数组件还是 Class 类组件，都需要返回一段 JSX\n\nJSX 是 React 中提供的一种特殊的语法， 本质上就是使用 JS 对象来描述 DOM 结构。在 React 中提供了\nReact.createElement 方法来创建虚拟 DOM 对象，从而对 DOM 结构进行描述。\n\n\n\n参数说明：\n\n * type：创建的 React 元素类型(可选的值有:标签名字符串、React 组件)\n * props（可选）：React 元素的属性\n * children（可选）：React 元素的子元素。\n\n例如：\n\n\n\n但是显然如果要开发者通过这种方式来描述页面，会分分钟劝退开发者。因此 JSX 应运而生，JSX 本质上就是 React.createElement\n方法的一种语法糖，通过 JSX，开发者可以通过类似于 HTML 的语法来描述页面。\n\n\n\nJSX具有如下的特点：\n\n * 可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中。\n * 在 JSX 中不能使用语句，只能使用表达式。例如不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。\n * 如果我们在 JSX 中要给标签设置 class，不能够像 HTML 中那样直接书写 class 因为 JSX 实际上是 JS 对象，所以class\n   需要替换为 className。\n * 花括号 {} 中可以是数组，数组的每一项为一段JSX，之后在渲染的时候会自动展开数组中的每一段JSX。\n * JSX 中如果要书写注释，需要写在 {/*注释内容... */}中\n\n当然，上面所列举的 JSX 示例是在开发 PC 网页时的例子。在 RN 中使用 JSX 可没有什么div、p这些标签，使用的都是RN所提供的内置组件\n\n\n\n\nprops 属性#\n\nprops 是组件对外的接口，在组件内部可以通过 props 拿到外部传给组件的参数。\n\n如果是使用的函数的方式来创建的组件，那么使用 props 对象来传递参数显得非常的简单，就像函数传参一样使用即可。\n\n例如:\n\n\n\n如果是 Class 类组件，则需要在 constructor 中将 props 由 super 函数传递给父组件。然后在 JSX 中通过 this.props\n来获取传入的数据。\n\n\n\n\nstate 状态#\n\nstate 为组件自身的数据状态。早期只有Class 类组件能够维护组件状态\n\n后来 React 加入了 Hook，函数式组件也能够维护 state 了。\n\n\n\n当然，上面的内容我们只是列举了一些 React 中的核心知识，以助于帮你快速的回顾一下 React 中的重要知识，这并不意味着你不需要掌握 React\n相关内容。\n\n如果你对 React 还不了解，建议你先暂停这里的学习，然后先学习了 React 相关知识后在回来继续学习 RN。","routePath":"/guide/reactNative/1-快速入门/3-复习 React 基础知识","lang":"","toc":[{"text":"复习 React 基础知识","id":"复习-react-基础知识","depth":2,"charIndex":-1},{"text":"components 组件","id":"components-组件","depth":3,"charIndex":89},{"text":"函数式组件","id":"函数式组件","depth":4,"charIndex":224},{"text":"Class 组件","id":"class-组件","depth":4,"charIndex":317},{"text":"JSX","id":"jsx","depth":3,"charIndex":536},{"text":"props 属性","id":"props-属性","depth":3,"charIndex":1334},{"text":"state 状态","id":"state-状态","depth":3,"charIndex":1550}],"domain":"","frontmatter":{},"version":""},{"id":127,"title":"","content":"RN 基础知识#\n\n我们根据 RN 的官网，来学习最基础的操作，主要包含：\n\n * 样式与布局\n * 图片\n * 文本输入与按钮\n * 使用滚动视图\n * 使用长列表\n * 网络连接\n\n\n样式与布局#\n\n在 RN 中，所有组件都接受名为 style 的属性，属性值为一个对象，用来书写 CSS 样式。\n\n书写样式时需要注意的是要按照 JavaScript 语法来使用驼峰命名法，例如将 background-color 改为 backgroundColor。\n\n还有就是在 RN 中无法使用缩写样式，例如 border: 1px solid 这样的样式是无法使用的，只能分成两条样式来写 borderWidth:1,\nborderStyle: 'solid'\n\n在 RN 中提供了一个 StyleSheet.create 方法来集中定义组件的样式，如下:\n\n\n\n如果要复用 StyleSheet.create\n中所定义的样式，可以传入一个数组，但是要注意在数组中位置居后的样式对象比居前的优先级更高，这样你可以间接实现样式的继承。\n\n\n\n在 RN 中设置样式时，如果涉及到尺寸，默认都是不给单位的，表示的是与设备像素密度无关的逻辑像素点。\n\n\n\n在组件样式中，使用 flex 可以使其在可利用的空间中动态地扩张或收缩。一般而言我们会使用 flex:1 来指定某个组件扩张以撑满所有剩余的空间。\n\n如果有多个并列的子组件使用了flex:1，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的 flex\n值不一样，则谁的值更大，谁占据剩余空间的比例就更大。\n\n> 即占据剩余空间的比等于并列组件间 flex 值的比。\n\n\n\n> 注：组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的 width 和 height，也没有设定\n> flex，则父容器的尺寸为零。其子组件如果使用了 flex，也是无法显示的。\n\n在进行宽高设置时，还可以很方便的使用百分比来进行设置。例如:\n\n\n\n在进行移动端开发时，最推荐的布局方案就是使用 flexbox 弹性盒布局。fiexbox 可以在不同屏幕尺寸上提供一致的布局结构。\n\nRN 中的 flexbox 的工作原理和 Web 上的 CSS 基本一致，当然也存在少许差异。首先是默认值不同：flexDirection 的默认值是\ncolumn 而不是 row，而 flex 也只能指定一个数字值。\n\n下面我们来看一个 RN 中 flexbox 的示例:\n\n\n\n\n图片#\n\n目前，我们的 RN 应用已经有了显示文本的能力，你能够通过弹性盒布局将文本显示到合适的位置。\n\n但是一个应用中不单单只有文字，还会存在图片。在 RN 中，提供了一个名为 Image 的组件来显示图片。例如：\n\n\n\n来看一个具体的例子，通过 Imgae 组件显示图片\n\n\n\nrequire 中的图片名字必须是一个静态字符串，不能使用变量！因为 require 是在编译时期执行，而非运行时期执行！\n\n\n\n本地图片在引入时会包含图片的尺寸(宽度，高度)信息，但是如果是网络图片，则必须手动指定图片的尺寸。\n\n\n\n\n文本输入与按钮#\n\n目前，我们的应用已经能够显示图片和文字，最基本的信息展示已经没问题了。但是一个应用往往还会涉及到用户的文本输入以及最基本的交互——按钮。\n\n文本输入#\n\n我们先来看文本输入。\n\nRN 中提供了一个 TextInput 组件，该组件是一个允许用户输入文本的基础组件。它有一个名为 onChangeText\n的属性，此属性接受一个函数，而此函数会在文本变化时被调用。另外还有一个名为 onSubmitEditing\n的属性，会在文本被提交后(用户按下软键盘上的提交键)调用。\n\n例如:\n\n\n\n按钮#\n\n按钮也是一个应用中最基本的需求，在 RN 中提供了 Button 组件来渲染按钮，这是一个简单的跨平台的按钮组件，会调用原生环境中对应的按钮组件。\n\n在 Android 设备中，Button 组件显示为一个按钮，而在 iOS 设备中，则显示为一行文本。\n\n该组件需要传递两个必须的属性，一个是 onPress，对应点击后的事件，另一个是 title，用来指定按钮内的文本信息。\n\n\n\n\n\n由于 Button 组件是调用原生代码，因此不同的平台显示的外观是不同的，如果想要各个平台显示的外观都相同，则可以使用 Touchable 系列组件。\n\n\n\n> 可以参考官方：TouchableHighlight、TouchableOpacity、TouchableWithoutFeedback、TouchableN\n> ativeFeedback 安卓特有\n\nTouchable 系列组件一共有 4 个，其中跨平台的有 3 个：\n\n * TouchableHighlight Touchable 系列组件中比较常用的一个，它是在 TouchableWithoutFeedback\n   的基础上添加了一些 UI 上的扩展，即当手指按下的时候，该视图的不透明度会降低，同时会看到视图变暗或者变亮，该标签可以添加 style 样式属性。\n\n> 官方现在推荐使用 Pressable，参考Pressable\n\n * TouchableOpacity\n   \n   完全和 TouchabieHighlight 相同，只是不可以修改颜色，只能修改透明度。\n\n * TouchableWithoutFeedback 最基本的一个 Touchable 组件，只响应用户的点击事件，不会做任何 UI 上的改变，所以不用添加\n   style 样式属性，加了也没效果。\n\n另外在 Android 平台上支持一个叫 TouchableNativeFeedback 的组件:\n\n * TouchableNativeFeedback\n   \n   为了支持 Android 5.0 的触控反馈而新增的组件。该组件在 TouchableWithoutFeedback\n   所支持的属性的基础上增加了触摸的水波纹效果。可以通过 background 属性来自定义原生触摸操作反馈的背景。(仅限 Android 平台，iOS\n   平台使用会报错)\n\nTouchableHighlight 示例如下：\n\n\n\n\n使用滚动视图#\n\n到目前为止，我们的应用能显示文字、图片，也能够进行简单的互动。但还有一个很重要的需求，那就是滑屏操作。\n\nRN 中，则直接为我们提供了滚动视图的组件 ScrollView。\n\nScrollView 是一个通用的可滚动的容器，你可以在其中放入多个组件和视图，而且这些组件并不需要是同类型的。ScrollView\n不仅可以垂直滚动，还能水平滚动(通过 horizontol 属性来设置)。\n\n示例如下：\n\n\n\n\n使用长列表#\n\n除了 ScrollView 滚动视图组件外，RN 中还提供了用于长列表组件。常见的长列表有两个：\n\n * FlatList\n * SectionList\n\nFlatList#\n\nFlatList 组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。\n\nFlatList 更适于长列表数据，且元素个数可以增删。和 ScrollView 不同的是，FlatList\n并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。\n\nFlatList 组件必须的两个属性是 data 和 renderItem。dota 是列表的数据源，而 renderItem\n则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。\n\n下面的例子创建了一个简单的 FlatList，并预设了一些模拟数据。首先是初始化 FlatList 所需的 data，其中的每一项(行) 数据之后都在\nrenderItem 中被渲染成了 Text 组件，最后构成整个FlatList 。\n\n\n\nSectionList#\n\n如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么 SectionList 将是个不错的选择。\n\n\n\n在上面的示例中，我们使用到了 SectionList 组件的 4 个属性，分别是\n\n * sections (必填)：用来渲染的数据，类似于 FlatList 中的 data 属性。\n\n * renderItem (必填) ：用来渲染每一个 section 中的每一个列表项的默认渲染器。必须返回一个 react 组件。\n\n * renderSectionHeader：在每个 section 的头部渲染。在 iOS 上，这些 headers 是默认粘接在 ScrollView\n   的顶部的。\n\n * keyExtractor：此函数用于为给定的 item 生成一个不重复的 key。\n   \n   key 的作用是使 react 能区分同类元素的不同个体，以便在刷新时能够确定其变化的位置，减少重新渲染的开销。\n   \n   若不指定此函数，则默认抽取 item.key 作为 key 值。若 item.key 也不存在，则使用数组下标。注意这只设置了每行 (item) 的\n   key，对于每个组 (section) 仍然需要另外设置 key。\n\n\n网络连接#\n\n开发应用时，我们往往还需要从服务器上面获取数据。\n\n在 RN 中，支持 fetchAPI 以及传统的 Ajax 的形式来发送网络请求，但是这里推荐使用最新的 fetch 形式来发送请求。\n\n> 当然基于 XMLHttpRequest 封装的 axios 也可以使用哦，不过不能使用 JQuery，参考官网\n\n注意：默认情况下 iOS 会阻止所有的 http 的请求，以督促开发者使用 https。从 Android9 开始，也会默认阻止 http 请求\n\n下面我们来看一个在 RN 中使用 fetch 发送请求的示例:\n\n\n\n输出结果如下：\n\n\n\n我们试试用 axios，下载一下\n\n\n\n然后改一下\n\n\n\n依旧成功，输出如下\n\n","routePath":"/guide/reactNative/1-快速入门/4-RN 基础知识","lang":"","toc":[{"text":"RN 基础知识","id":"rn-基础知识","depth":2,"charIndex":-1},{"text":"样式与布局","id":"样式与布局","depth":3,"charIndex":93},{"text":"图片","id":"图片","depth":3,"charIndex":1061},{"text":"文本输入与按钮","id":"文本输入与按钮","depth":3,"charIndex":1321},{"text":"文本输入","id":"文本输入","depth":4,"charIndex":1401},{"text":"按钮","id":"按钮","depth":4,"charIndex":1575},{"text":"使用滚动视图","id":"使用滚动视图","depth":3,"charIndex":2618},{"text":"使用长列表","id":"使用长列表","depth":3,"charIndex":2831},{"text":"FlatList","id":"flatlist","depth":4,"charIndex":2917},{"text":"SectionList","id":"sectionlist","depth":4,"charIndex":3275},{"text":"网络连接","id":"网络连接","depth":3,"charIndex":3825}],"domain":"","frontmatter":{},"version":""},{"id":128,"title":"","content":"实战案例-照片分享应用#\n\n经过前面小节的学习，我们已经掌握了 RN 中最基本的知识，接下来做一个简单的实战案例——照片分享应用\n\n效果如下：\n\n\n\n\n\n\n\n\n\n\n\n先写样式，可以直接复制，不需要浪费时间\n\n\n\n最外面包裹一个 View，然后写logo，然后写提示文字，最后写一个按钮\n\n\n\n首先我们下一个第三方库用来调用 API 获取权限\n\n\n\n接下来写回调函数内容\n\n\n\n尝试一下，获取权限会弹出请求\n\n\n\n这里定义了一个状态，用于存放用户选择图片的 uri\n\n\n\n用户选择完了图片，那我们肯定需要展示，判断 localUri 来返回 jsx 就可以了，然后我们来写代码\n\n\n\n这里两个函数，第一个是分享照片，我们需要下一个库\n\n\n\n\n\n第二个是重新选择，那很容易就是把 localUri 设置为空字符就可以回到上一页的 jsx 了\n\n\n\n至此，我们全部完成，下面是 App.js 的完整代码\n\n","routePath":"/guide/reactNative/1-快速入门/5-实战案例-照片分享应用","lang":"","toc":[{"text":"实战案例-照片分享应用","id":"实战案例-照片分享应用","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":129,"title":"","content":"RN 内置基础组件#\n\n在上一章节中，我们已经对 RN 有了一个最基本的了解，接下来我们继续挖掘 RN 的其他内容\n\n打开 RN 的官网，可以看到官方文档中核心分为 4 个部分，分别是：\n\n * Guides（向导）\n * Component（内置组件）\n * API（接口文档）\n * Architecture（架构）\n\n在上一章中，我们相当于把 Guides 的部分内容学完了，本章我们就着重来学习 Component 和 API 。\n\n\n\nRN 的内置组件在不同的宿主环境会被编译为不同的组件\n\n其核心组件又可以根据用途分为以下几大类：\n\n * 基础组件\n * 容器组件\n * 列表组件\n * 功能组件\n\n本小节我们先来看第一类组件——基础组件。基础组件大致如下：\n\n * Image 组件\n * TextInput 组件\n * Button 组件\n * Switch 组件\n\n\nImage 组件#\n\nImage 是一个图片展示组件，其作用类似于 Andriod 的 imageView 或者 iOS 的 UIImageview。Image\n组件支持多种类型的图片显示，包括网络图片、静态资源、base64 图片格式。\n\n要使用 Image 组件加载图片，只需要设置 source 属性即可，如果加载的是网络图片，还需要添加 uri 标识以及手动指定图像的尺寸。\n\n目前，Image 组件支持的图片格式有 PNG、JPG、JPEG、BMP、GIF、WebP 以及 PSD(仅 iOS)。默认情况下 Android 是不支持\nGIF 和 WebP 格式的。你需要在android/app/build.gradle文件中根据需要手动添加以下模块：\n\n\n\nAPI 文档地址：Image\n\n使用 Image 组件时，有一个常用的属性 resizeMode，此属性用于控制当组件和图片尺寸不成比例时以何种方式调整图片的大小，对应的值有 5 种:\n\n * cover：在保持图片宽高比的前提下缩放图片，直到宽度和高度都大于等于容器视图的尺寸。\n * contain：在保持图片宽高比的前提下缩放图片，直到宽度和高度都小于等于容器视图的尺寸。\n * stretch：拉伸图片且不维持图片的宽高比，直到宽度和高度都刚好填满容器。\n * repeat：在维持原始尺寸的前提下，重复平铺图片直到填满容器。\n * center：居中且不拉伸的显示图片。\n\n下面的示例演示了不同属性值之间视觉效果上的区别:\n\n\n\n> 更多属性可以参考官方的文档\n\n\nTextInput 组件#\n\nTextInput 是一个输入框组件，用于将文本内容输入到 TextInput 组件上。作为一个高频使用的组件，TextInput\n支持自动拼写、自动大小写切换、占位默认字符设置以及多种键盘设置功能。\n\n\n\nAPI 文档地址：TextInput\n\n需要注意的是，TextInput在安卓上默认有一个底边框，同时会有一些 padding。如果要想使其看起来和 iOS 上尽量一致，则需要设置padding:\n0。\n\n下面我们来看一个实际开发中使用到 TextInput 的案例——搜索框，如下：\n\n\n\n\nButton 组件#\n\nButton 是一个最基本的按钮组件，可以在跨平台上很好地呈现，支持最低级别的定制。\n\nAPI 文档地址：Button\n\n\n\n\nSwitch 组件#\n\nSwitch 是 RN 提供的一个状态切换的组件，俗称开关组件，主要用来对开和关两个状态进行切换。\n\nSwich 组件的用法比较简单，只需要给组件绑定 value 属性即可，这样它就是一个受控组件。如果需要改变组件的状态，则必须使 onValueChange\n方法来更新 value 的值。\n\nAPI 文档地址：Switch\n\n","routePath":"/guide/reactNative/2-内置组件/1-RN 内置基础组件","lang":"","toc":[{"text":"RN 内置基础组件","id":"rn-内置基础组件","depth":2,"charIndex":-1},{"text":"Image 组件","id":"image-组件","depth":3,"charIndex":392},{"text":"TextInput 组件","id":"textinput-组件","depth":3,"charIndex":1065},{"text":"Button 组件","id":"button-组件","depth":3,"charIndex":1331},{"text":"Switch 组件","id":"switch-组件","depth":3,"charIndex":1407}],"domain":"","frontmatter":{},"version":""},{"id":130,"title":"","content":"容器组件#\n\n本小节我们来学习 RN 内置组件中的容器组件。容器组件大致如下：\n\n * View 组件\n * Text 组件\n * ScrollView 组件\n * Touchable 组件\n\n\nView 组件#\n\n在 RN 中，View 容器组件支持 Flexbox 布局、样式、触摸事件处理和一些无障碍功能，它可以被放到其他容器组件里面，也可以包含任意多个子组件。\n\n无论是 iOS 还是 Andriod，View 组件都会直接对应平台的原生视图，其作用等同于 iOS 的 UIView 或者 Andriod 的\nViewGroup。\n\nAPI 文档地址：View\n\n来看一个简单的示例：\n\n\n\n\nText 组件#\n\n在 RN 中，Text 是一个用来显示文本内容的组件，也是使用频率极高的组件，它支持文本和样式的嵌套以及触摸事件的处理。\n\nAPI 文档地址：Text\n\n\n\n从布局上讲，Text 组件没有类似于 CSS 行内元素这样的概念，所以单个 Text 组件也是独占一行（相当于 p 元素），但它属于 Flex\n布局范畴，可以使用 flexDirection 属性设置行内并列的效果，例如:\n\n\n\nText 的嵌套主要是为了满足文本某些特定场景的需求。例如在一些信息展示类的场景中，通常需要将同一段落的部分文字的字号，颜色另外设置值，以达到视觉上的区分。\n\n以前在 PC 端书写网页时，我们是通过嵌套 span 标签来处理此需求的，而在 RN 中则是使用 Text 的嵌套来实现。\n\n\n\n不过 RN 中的 Text 嵌套写法也存在以下的问题\n\n * 被嵌套组件与位置相关的 style 样式几乎都不生效\n\n\n\n * 内嵌 Text 的 numberOfLines 属性会失效\n\n\n\n\n\n我们可以换成这样试试\n\n\n\n\n\n如果使用不同的 Text 组件设置不同的字号，那么对齐的方式仍然是使用 Flex 布局对齐。\n\n例如垂直居中：\n\n\n\n此时下面的文字靠上\n\n\n\n改一下下面的View，改为alignItems: 'flex-end'，就靠下了\n\n\n\n不过需要注意的是，由于字号大小不一，小字号文字的上边距会略小，例如将上例中 alignltems 值修改为\nflex-start，但是由于不同的字体大小可以明显的看到上边距是不同的。如果想要不同字体大小的文字边距相同，可以利用 padding 进行微调。\n\n\nScrollView 组件#\n\nScrollView 是一个支持横向或竖向的滚动组件，几乎所有页面都会用到。\n\nScrollView 组件类似于 Web 中的 html 或 body 标签，浏览器中的页面决所以能上下滚动，就是 html 和 body 标签默认有一个\noverflow-y: scroll 的属性，如果你把标签的属性设置为overflow-y: hidden，页面就不能滚动了。\n\nReactNative 的 ScrollView 组件在 Android 的底层实现用的是 ScrollView 和\nHorizontalScrollView，在 iOS 的底层实现用的是 UIScrollView 。\n\n使用 ScrollView 组件时，必须要有一个确定的高度才能正常工作。如果不知道容器的准确高度，可以将 ScrollView 组件的样式设置为 flex:\n1，让其自动填充父容器的空余空间。\n\nScrollView 通常包裹在视图的外面，用于控制视图的滚动，并且很多时候我们并不直接给 ScrollView\n设置固定高度或宽度，而是给其父组件设置固定高度或宽度。\n\n其用法我们已经在之前介绍了，后面会使用 ScrollView 组件来封装一个轮播图的自定义组件\n\nAPI 文档地址：ScrollView\n\n\nTouchable 组件#\n\n在 RN 应用开发中，点击和触摸都是比较常见的交互行为，不过并不是所有的组件都支持点击事件。为了给这些不具备点击响应的组件绑定点击事件，RN 提供了\nTouchable 系列组件。\n\n正如前面所述，Touchable 系列组件并不是单指某一个组件，一共有 4个，其中跨平台的有3个：\n\n * TouchableHighlight\n\nTouchable 系列组件中比较常用的一个，它是在 TouchableWithoutFeedback 的基础上添加了一些 UI\n上的扩展，即当手指按下的时候，该视图的不透明度会降低，同时会看到视图变暗或者变亮，该标签可以添加 style 样式属性。\n\n * TouchableOpacity\n\n完全和 TouchabieHighlight 相同，只是不可以修改颜色，只能修改透明度。\n\n * TouchableWithoutFeedback\n\n最基本的一个 Touchable 组件，只响应用户的点击事件，不会做任何 UI 上的改变，所以不用添加 style 样式属性，加了也没效果。\n\n另外在Android平台上支持一个叫 TouchableNativeFeedback 的组件：\n\n * TouchableNativeFeedback：为了支持 Android 5.0 的触控反馈而新增的组件。该组件在\n   TouchableWithoutFeedback 所支持的属性的基础上增加了触摸的水波纹效果。可以通过 background\n   属性来自定义原生触摸操作反馈的背景。(仅限 Android 平台，iOS 平台使用会报错)\n\n","routePath":"/guide/reactNative/2-内置组件/2-容器组件","lang":"","toc":[{"text":"容器组件","id":"容器组件","depth":2,"charIndex":-1},{"text":"View 组件","id":"view-组件","depth":3,"charIndex":97},{"text":"Text 组件","id":"text-组件","depth":3,"charIndex":300},{"text":"ScrollView 组件","id":"scrollview-组件","depth":3,"charIndex":1010},{"text":"Touchable 组件","id":"touchable-组件","depth":3,"charIndex":1575}],"domain":"","frontmatter":{},"version":""},{"id":131,"title":"","content":"Pressable 组件#\n\n通过前面的学习，我们已经知道在 RN 中提供了 Button 和 Touchable 这两个交互组件来处理用户的点击操作。但是到了RN\n0.63版本，官方又提供了新的交互组件: Pressable 。\n\n新的交互组件在未来将替代目前可以进行交互的组件:\nButton，TouchableWithoutFeedback，TouchableHighlight，TouchableOpacity，TouchableNat\niveFeedback。\n\n新核心组件 Pressable，可用于检测各种类型的交互。提供的 API\n可以直接访问当前的交互状态，而不必在父组件中手动维护状态。它还可以使用各平台的所有功能，包括悬停，模糊，聚焦等。RN 希望开发者利用 Pressable\n去设计组件，而不是使用带有默认效果的组件。如: TouchableOpacity。\n\n那么在这里，我们就要对这几代不同的交互组件做一个总结。\n\n首先，开发者在开发时会用到点按组件，那么它的功能越简单开发者用起来就越轻松：但是与其相对的，应用最后开发出来是给用户使用的，对于用户来讲，则是希望功能越丰富就越\n能满足各种场景的需求。\n\n那是让开发者简单易用好，还是用丰富的功能去满足用户，有没有两全其美之计?\n\n实际上，RN\n的点按组件经历了三个版本的迭代，才找到了两全其美的答案。等你了解了这个三个版本的迭代思路后，你就能很好明白优秀通用组件应该如何设计，才能同时在用户体验 UX\n和开发者体验 DX 上找到平衡。\n\n\n第一代 Touchable 组件#\n\n是的，你没有看错，Touchable 系列组件反而是在 RN 中所提供的第一代点按组件。\n\n第一代点按组件想要解决的核心问题是，提过多种反馈风格。\n\n一个体验好的点按组件，需要在用户点按后进行实时地反馈，通过视觉变化等形式，告诉用户点到了什么，现在的点击状态又是什么。\n\n但不同的原生平台，有不同的风格，反馈样式也不同。Android 按钮点击后会有涟漪，iOS 按钮点击后会降低透明度或者加深背景色。RN\n是跨平台的，那它应该如何支持多种平台的多种反馈风格呢?\n\n第一代 Touchable 点按组件的设计思路是，提供多种原生平台的反馈风格给开发者自己选择。所以我们看到整个 Touchable\n是一套组件，让开发者自己选择。\n\n不过，对于开发者来讲，有经验的开发者可能知道如何进行选择，但新手却要花上很长时间，去了解不同组件之间的区别。所以说，Touchable\n点按组件在提供多样性的功能支持的同时，也带来了额外的学习成本。\n\n为了降低学习成本，RN团队又开发了第二代点按组件——Button。\n\n\n第二代 Button 组件#\n\n第二代 Button 组件的实质是对 Touchable 组件的封装。在 Android 上是TouchableNativeFeedback 组件，在 iOS\n上是 TouchableOpacity 组件。\n\nButton 组件的设计思想就是，别让开发者纠结选啥组件了，框架已经选好了，点按反馈的样式就和原生平台的自身风格保持统一就好了。\n\n但是这仍然存在一个问题，那就是要让大多数开发者都选择同一个默认的 UI 样式真是太难了，萝卜白菜各有所爱。\n\n另外，用户的审美也在慢慢地变化，涟漪风格也好，降低透明风格也好，背景高亮风格也好，或许几年后就不会再流行了。甚至连 Button\n这个概念本身，都在慢慢地变化，现在的 App 中几平只要是个图片或者文字都能点按，不再局限干只有四四方方的色块才能点按了。\n\n\n第三代 Pressable 组件#\n\n第三代 Pressable 点按组件，不再是 Touchable 组件的封装，而是一个全新重构的点按组件，它的反馈效果可由开发者自行配置。\n\n下面我们就来看一下 Pressable 组件的相关知识。\n\nPressable 是一个核心组件的封装，它可以检测到任意子组件的不同阶段的按压交互情况。\n\n\n\n在被 Pressable 包装的元素上：\n\n * onPressIn 在按压时被调用\n * onPressOut 在按压动作结束后被调用\n\n在按下 onPressIn 后，将会出现如下两种情况的一种：\n\n * 用户移开手指，依次触发 onPressOut 和 onPress 事件\n * 按压持续 500 毫秒以上，触发 onLongPress 事件。(onPressOut 在移开手后依旧会触发)\n\n\n\n下面一个例子来展示\n\n\n\n在上面的示例中，当我们轻点按钮时，会依次触发 PressIn、Press、PressOut，而如果按住不放，则是先触发 PressIn，500ms后触发\nLongPress，松开之后触发 PressOut。\n\n\n\n关于点按时的样式，也是可以自定义的。来看下面的示例:\n\n\n\n没按下的时候是这样的\n\n\n\n而在按下的时候就是这样的，样式会变化\n\n\n\n> 当然也可以返回不同的 JSX\n\nPressable 组件有一个可触发区域 HitRect，默认情况下，可触发区域 HitRect 就是盒模型中的不透明的可见区域。你可以超过修改 HitRect\n的值，直接扩大可触发区域。\n\n例如：\n\n\n\n在上面的示例中，我们增加了 Pressable\n组件的可点击区域，并且明确指定了4个边各自扩充多少。在老点不中、老勾不中的场景中，你可以在不改变布局的前提下，设置 Pressable 组件的可触发区域\nHitSlop，让可点击区域多个10像素、20 像素，让用户的更容易点中。\n\n另外，在 Pressable 组件中还有一个可保留区域 PressRect 的概念。\n\n点按事件可保留区域的偏移量 (Press Retention Offset) 默认是0，也就是说默认情况下可见区域就是可保留区域。你可以通过设置\npressRetentionOffset 属性，来扩大可保留区域 PressRect。\n\n举一个例子，当你在购物 App\n点击购买按钮时，你已经点到购买按钮了，突然犹豫，开始进行心理博弈，想点又不想点。手指从按钮上挪开了，又挪了进去，然后又挪开了，如此反复。这时还要不要触发点击事件\n呢？要不要触发，其实是根据你手指松开的位置来判断的，如果你松手的位置在可保留区域内那就要触发，如果不是那就不触发。\n\n\n\n最后是官方的示例：\n\n","routePath":"/guide/reactNative/2-内置组件/3-Pressable 组件","lang":"","toc":[{"text":"Pressable 组件","id":"pressable-组件","depth":2,"charIndex":-1},{"text":"第一代 Touchable 组件","id":"第一代-touchable-组件","depth":3,"charIndex":659},{"text":"第二代 Button 组件","id":"第二代-button-组件","depth":3,"charIndex":1131},{"text":"第三代 Pressable 组件","id":"第三代-pressable-组件","depth":3,"charIndex":1502}],"domain":"","frontmatter":{},"version":""},{"id":132,"title":"","content":"列表组件#\n\n本小节我们来看一下 RN 中所提供的列表组件，主要包含：\n\n * FlatList\n * 下拉刷新\n * 上拉加载更多\n * SectionList\n\n\nFlatList#\n\n在 FlatList 组件出现之前，RN 使用 ListView 组件来实现列表功能，不过在列表数据比较多的情况下，ListView\n组件的性能并不是很好，所以在 0.43.0 版本中，RN 引入了 FlatList 组件。相比 ListVview 组件，FlatList\n组件适用于加载长列表数据，而且性能也更佳。\n\n和 ListView 组件类似，FlatList 组件的使用也非常的简单，只需要给 FlatList 组件提供 data 和 renderItem\n两个属性即可，如下所示\n\n\n\n其中 data 表示数据源，一般为数组格式，renderItem 表示每行的绘制方法。除了 data 和 renderItem 两个必须属性外，FlatList\n还支持诸如 ListHeaderComponent、ListFooterComponent 等属性，具体可以参阅官方文档:\nItemSeparatorComponent\n\n下面是一个使用 FlatList 渲染电影列表的示例:\n\n首先定义了一个名为 MovieItemCell 的电影项目组件，用于渲染具体的电影项目，包含电影的标题、上映日期、 评分、海报、导演、主演等信息。组件代码如下:\n\n\n\n然后有个数据和查询函数，数据如下\n\n\n\n查询函数如下：\n\n\n\n然后我们写 APP.js\n\n\n\n最终实现效果：\n\n\n\n\n\n\n下拉刷新#\n\n下拉刷新是一个常见的需求，当用户已经处于列表的最顶端，此时继续往下拉动页面的话，就会有一个数据刷新的操作。\n\n在 FlatList 中，提供了下拉刷新的功能，我们只需要设置 onRefresh 和 refreshing 这两个属性值即可。\n\n * onRefresh：下拉刷新操作触发时要进行的动作，对应是一个函数\n * refreshing：是否显示下拉刷新的等待图标，对应一个布尔值\n\n下面来看一个具体的示例：\n\n\n\n在上面的代码中，当用户下拉刷新时，触发 onRefresh 所对应的 beginHeaderRefresh 函数，此函数对应的操作如下：\n\n\n\n这里用到一个模拟的函数：\n\n\n\n这时候我们下拉后就会多出两个数据插入到我们原有电影的前面\n\n\n上拉加载更多#\n\n上拉加载也是列表中一个常见的操作，上拉加载其实质就是以前 PC\n端的分页效果。因为数据量过多，所以一般我们不会一次性加载所有的数据，此时就会进行一个分页的显示。而在移动端，分页显示变成了上拉加载的形式，当用户到达列表底部时，\n自动获取下一页的数据，并且拼接到原有数据的后面。\n\n这里我们会用到两个属性，分别是：\n\n * onEndReached：上拉加载操作触发时要进行的动作、对应一个函数\n * onEndReachedThreshold：表示距离底部多远时触发 onEndReached\n\n\n\n其中有个Loading在底部我们弄一下\n\n\n\n样式很简单：\n\n\n\n接下来就是 beginFooterRefresh 函数了\n\n\n\n最后给出完整的下拉刷新和上拉加载的App.js代码\n\n\n\n\nSectionList#\n\n和 FlatList 样，SectionList 组件也是由 VirtualizedList 组件扩展来的。不同于 FlatList\n组件，SectionList 组件主要用于开发列表分组、 吸顶悬浮等功能。\n\nSectionList 组件的使用方法也非常简单，只需要提供 renderItem、renderSectionHeader 和 sections\n等必要的属性即可。\n\n\n\n常用的属性如下：\n\n * keyExtractor：和 FlatList 组件一样，表示项目的唯一标识\n * renderSectionHeader：用来渲染每个 section 的头部视图\n * renderItem：用来渲染每一个 section 中的每一个列表项视图\n * sections：用来渲染视图的数据，类似与 FlatList 中 data 属性\n * stickySectionHeadersEnabled：当 section 把它前一个 section 的可视区推离屏幕时，这个 section 的\n   header 是否粘连在屏幕顶端\n\n有关 SectionList 组件更多的属性，可以参考文档：SectionList\n\n我们把之前的改造一下：\n\n\n\n效果如下：\n\n\n\n","routePath":"/guide/reactNative/2-内置组件/4-列表组件","lang":"","toc":[{"text":"列表组件","id":"列表组件","depth":2,"charIndex":-1},{"text":"FlatList","id":"flatlist","depth":3,"charIndex":83},{"text":"下拉刷新","id":"下拉刷新","depth":3,"charIndex":684},{"text":"上拉加载更多","id":"上拉加载更多","depth":3,"charIndex":1021},{"text":"SectionList","id":"sectionlist","depth":3,"charIndex":1374}],"domain":"","frontmatter":{},"version":""},{"id":133,"title":"","content":"功能组件#\n\n最后，我们来看一下 RN 中内置的功能组件，这些组件会在用户浏览页面时给予用户不同程度的反馈，也是开发中不可或缺的重要组件。\n\n主要如下:\n\n * ActivityIndicator\n * KeyboardAvoidingView\n * Modal\n * RefreshControl\n * StatusBar\n\n\nActivityIndicator#\n\nActivityIndicator 组件常用于发送请求时所显示的等待圆圈，两个常见的属性 size 和 color 分别用于设置等待圆圈的尺寸和颜色。\n\n官方文档地址：ActivityIndicator\n\n\n\n\nKeyboardAvoidingView#\n\n我们在开发的时候，经常会遇到手机上弹出的键盘常常会挡住当前的视图，所以该组件的功能就是解决这个常见问题的，它可以自动根据手机上键盘的位置，调整自身的\nposition 或底部的 padding，以避免被遮挡。\n\n官方文档地址：KeyboardAvoidingView\n\n常用属性:\n\n * behavior：该参数的可选值为: height、position、padding，来定义其自适应的方式\n * contentContainerStyle：如果设定 behavior 值为 position，则会生成一个 View\n   作为内容容器。此属性用于指定此内容容器的样式。\n * keyboardVerticalOffset：视图离屏幕顶部有一定距离时，利用这个属性来补偿修正这段距离(键盘在竖直方向上的偏移量)\n\n用法：\n\n\n\n下面我们首先来看一个会遮挡输入框的示例：\n\n\n\n效果如下，会被挡住\n\n\n\n接下来我们需要做的就是使用 KeyboardAvoidingView 替换 View，然后给它加一个 behavior 偏移方式和\nkeyboardVerticalOffset 偏移值。\n\n\n\n在上面的代码中，我们使用 KeyboardAvoidingView 替换了最外层的 View，并设置 behavior 属性的值为\npadding，keyboardVerticalOffset 属性也就是用户屏幕顶部和原生视图之间的距离设置为了 150，从而避免了键盘遮挡输入框。\n\n\nModal#\n\nModal 组件用来显示一个弹出框，弹出框常用于用户点击了某一个按鈕后弹出段提示信息。\n\n官方文档地址：Modal\n\n下面是官方所提供的一个关于Modal组件的基本示例:\n\n\n\n其中 onRequestClose 是点击手机的后退按键的时候调用的，就是这个按键\n\n\n\n\nRefreshControl#\n\n该组件在 ScrollView 或 ListVview 中用于添加拉动刷新功能。当 ScrollView 在 scrollY: 0 时，向下滑动会触发\nonRefresh 事件。\n\n官方文档地址：RefreshControl\n\n下面是官方所提供的一个关于 RefreshControl 组件的基本示例:\n\n\n\n往下滑，会出现一个圆圈加载动画，两秒后结束\n\n> SafeAreaView：目的是在一个“安全”的可视区域内渲染内容。具体来说就是因为目前有 iPhone X\n> 这样的带有“刘海”的全面屏设备，所以需要避免内容渲染到不可见的“刘海”范围内。本组件目前仅支持 iOS 设备以及 iOS 11\n> 或更高版本。参考官方文档：SafeAreaView\n\n\nStatusBar#\n\nStatusBar 是用来控制应用程序状态栏的组件。状态栏是显示当前时间、WIFI 和蜂窝网络信息、电池电量和或其他状态图标的区域，通常位于屏幕顶部。\n\n官方文档地址：StatusBar\n\n下面是官方所提供的一个关于 StatusBar 组件的基本示例:\n\n\n\n点击会修改顶部状态栏的样式、状态栏是否隐藏等等\n\n\n\n\n\n","routePath":"/guide/reactNative/2-内置组件/5-功能组件","lang":"","toc":[{"text":"功能组件","id":"功能组件","depth":2,"charIndex":-1},{"text":"ActivityIndicator","id":"activityindicator","depth":3,"charIndex":164},{"text":"KeyboardAvoidingView","id":"keyboardavoidingview","depth":3,"charIndex":290},{"text":"Modal","id":"modal","depth":3,"charIndex":957},{"text":"RefreshControl","id":"refreshcontrol","depth":3,"charIndex":1100},{"text":"StatusBar","id":"statusbar","depth":3,"charIndex":1448}],"domain":"","frontmatter":{},"version":""},{"id":134,"title":"","content":"第三方组件库#\n\n通过前面的学习，我们已经将RN官方所提供的内置组件大部分过了一遍，\n但是官方所提供的组件往往是比较基础且局限的，此时我们就可以使用一些第三方组件库来提高我们的开发效率。\n\n本小节我们就一起来看一下 RN 常见的第三方组件库有哪些，并且以 NativeBase 为例做一个第三方组件库的使用示例。\n\n本小节包含以下内容:\n\n * RN 常见第三方组件库\n\n * NativeBase 使用示例\n\n\nRN 常见第三方组件库#\n\n1. NativeBase 组件库\n\nNativeBase 是一个广受欢迎的 UI 组件库，为 RN 提供了数十个跨平台组件。在使用 NativeBase\n时，你可以使用任意开箱即用的第三方原生库，而这个项目本身也拥有一个丰富的生态系统，从有用的入门套件到可定制的主题模板。\n\nNativeBase 官网地址：NativeBase\n\n\n\n2.React Native Elements 组件库\n\nReact Native Elements 是一个高度可定制的跨平台 UI 工具包，完全用 Javascript 构建。该库的作者声称 React Native\nElements\n的想法更多的是关于组件结构而不是设计，这意味着在使用某些元素时可以减少样板代码，但可以完全控制它们的设计，这对于开发新手和经验丰富的老手来说都很有吸引力。\n\nReact Native Elements 官网地址：React Native Elements\n\n\n\n3.React Native Paper 组件库\n\nReact Native Paper 是一个跨平台的 UI 组件库，它遵循 Material Design 指南，提供了全局主题支持和可选的 babel\n插件，用以减少捆绑包大小。\n\nReact Native Paper 官网地址: React Native Paper\n\n\n\n4. Ant Design Mobile RN 组件库\n\nAnt Design Mobile RN 是由蚂蚁金服推出的 RN 组件库，如果是 React 的开发者都会对 React 的常用组件库 Ant Design\n有所耳闻，而 Ant Design Mobile RN 则是蚂蚁金服在 RN 方向的延伸。\n\n> 注意：Ant Design React Native 版本从 3.x 版本开始 蚂蚁金服不再维护该项目，由个人维护了\n\n特点如下：\n\n * UI 样式高度可配置，拓展性更强，轻松适应各类产品风格\n * 基于 React Native 的 iOS / Android / Web 多平台支持，组件丰富、能全面覆盖各类场景 (antd-mobile)\n * 提供 \"组件按需加载\" / \"Web 页面高清显示\" / \"SVG Icon\" 等优化方案，一体式开发\n * 使用 TypeScript 开发，提供类型定义文件，支持类型及属性智能提示，方便业务开发\n * 全面兼容 react\n\nAnt Design Mobile RN 官网地址：Ant Design Mobile RN\n\n\n\n5.React Native Material 组件库\n\nReact Native Material UI是一组高度可定制的 UI 组件，实现了谷歌的 Material Design。请注意，这个库使用了一个名为\nuiTheme 的 JS 对象，这个对象在上下文间传递，以实现最大化的定制化能力。\n\nReact Native Material 官网地址：React Native Material\n\n\n\n建议使用前三个，目前 Github 的 stars 数都不错，前两个都有20k，第三个有十几k\n\n\nNativeBase 使用示例#\n\n这里我们以第一个组件库 NativeBase 为示例演示如何使用第三方组件库\n\n第一步进行安装，官方提供了安装指南：Installation\n\n\n\n目前我们还是 Expo，选第一个就可以，然后我们需要选择 Existing Project，因为我们已经有项目了\n\n\n\n然后根据命令下载即可，可以不用指定版本等\n\n> 安装需科学上网，如果有报错一般是依赖树报错等等，可以用 yarn 来下载依赖\n\n然后我们弄一下示例，这里我用的是创建新项目后的代码\n\n\n\n里面有个 NativeBaseIcon 的js代码\n\n\n\n最终效果如下：\n\n\n\n","routePath":"/guide/reactNative/2-内置组件/6-第三方组件库","lang":"","toc":[{"text":"第三方组件库","id":"第三方组件库","depth":2,"charIndex":-1},{"text":"RN 常见第三方组件库","id":"rn-常见第三方组件库","depth":3,"charIndex":206},{"text":"NativeBase 使用示例","id":"nativebase-使用示例","depth":3,"charIndex":1556}],"domain":"","frontmatter":{},"version":""},{"id":135,"title":"","content":"自定义组件#\n\n在使用 RN\n进行跨平台应用开发时，官方提供的组件往往是有限的，并且很多组件并不是多平台通用的，有些只针对特别的平台。此时，要想在应用开发上保持页面样式的一致性，除了直接选择\n第三方开源库以外，另一个有效的手段就是自定义组件。\n\n\n弹框组件#\n\n本小节我们来自定义一个弹框组件。\n\n首先我们简单复习一个 ES6 中导入导出模块的相关知识。\n\n\n\n除了组件外，变量和常量也支持导入和导出\n\n\n\n方法的导入以及导出，和变量、常量的导入导出类似\n\n\n\n另外，我们还会使用到 propTypes。通常，通用组件需要使用自定义属性的方式接收外界传入的值，如果是必须要传入的值，可以使用 isRequired\n关键字。例如:\n\n\n\n需要注意的是，由于 propTypes 在 15.0.0 版本中已经被移除掉了，所以在 15.5.0 以及之后的版本中，需要使用新的方式引入。\n\n\n\n> 当然这里也可以使用 TypeScript，个人感觉 TS 更加方便，如果不熟悉 TS 再使用 propTypes也可以\n\n好了，接下来我们就来封装一个自定义组件——弹框组件。\n\n\n\n上图是封装好之后的效果，可以看到，整个弹框由4个部分组成，分别是图片、标题、内容、确认按钮以及关闭按钮。其中图片、标题、内容、确认按钮内容都是应该在使用组件时传\n递进去的。\n\n完整的封装组件代码如下:\n\n\n\n> 这里我用的验证用的是TypeScript，在 RN 中使用参考官网文档：使用 TypeScript\n\n接下来是 App，很容易\n\n\n\n最终效果：\n\n\n\n\n\n\n单选组件#\n\n在 RN 中，官方并没有提供单选组件，如果应用开发中涉及到单选功能，就需要开发者使用第三方开源库或者自己封装单选组件。\n\n通常，一个正常的单选功能会包含若干个子选项，每个子选项的前面有一个标识勾选状态的圆环，当某个选项被选中时圆环会变成实心，表示选中状态。\n\n要完成自定义单选功能，首先需要自定义一个单选按钮组件。通过分析可以发现，单选按钮的左边是图片，右边是描述文字，按钮的图片有选中和未选中两种状态。\n\nApp如下：\n\n\n\n然后我们定义 RadioGroup\n\n\n\n然后写 RadioButton，其中有我们之前 React 学到的 useImperativeHandle，用来暴露方法\n\n\n\n最终效果：\n\n\n\n","routePath":"/guide/reactNative/2-内置组件/7-自定义组件","lang":"","toc":[{"text":"自定义组件","id":"自定义组件","depth":2,"charIndex":-1},{"text":"弹框组件","id":"弹框组件","depth":3,"charIndex":123},{"text":"单选组件","id":"单选组件","depth":3,"charIndex":670}],"domain":"","frontmatter":{},"version":""},{"id":136,"title":"","content":"基础 API#\n\n从本章开始我们进入 RN 中一些 API 的学习。这里我将整个 RN 的 API 分为了 5 个部分，分别是:\n\n * 基础 API\n * 屏幕 API\n * 动画 API\n * 设备 API\n * 手势 API\n\n本小节我们先来看基础 API，如下：\n\n * Alert\n * StyleSheet\n * Transforms\n * Keyboard\n * AppState\n\n\nAlert#\n\nAlert 主要用于显示个带有指定标题和消息的警报对话框。Alert.alert 方法接收 3\n个参数，一个参数是警报对话框的标题，第二个参数是警报内容，最后一个参数是一个数组， 数组的每一项是按钮对象。\n\n官方文档地址：Alert\n\n\n\n\nStyleSheet#\n\n这个 API 我们已经用到很多了，StyleSheet 是一种类似于 CSS StyleSheets 的抽象\n\n官方文档地址：StyleSheet\n\n需要注意以下几个点：\n\n * 并不是所有的 CSS 属性在 StyleSheet 中都支持\n * 书写样式时要使用驼峰命名法，例如 backgroundColor\n\n属性：\n\n * hairlineWidth：自适应不同设备生成一条线\n\n\n\n * adsoluteFill：是 postion: 'absolute', left: 0, right: 0, top: 0, bottom: 0的缩写形式\n\n\n\n方法：\n\n * create：根据对象创建样式表\n * flatten：可以把样式对象的数组整合成一个样式对象，重复的样式属性以后面一个为准\n\n\n\n\nTransforms#\n\nTransforms 类似于 CSS 中的变形。可以帮助我们使用 2D 或者 3D 变换来修改组件的外观和位置。\n\n但是需要注意的是，一旦应用了变换，变换后的组件周围的布局将保持不变，因此它可能会与附近的组件重叠。\n\n官方文档地址：Transforms\n\n\n\n\nKeyboard#\n\nKeyboard 模块用来控制键盘相关的事件。\n\n利用 Keyboard 模块，可以监听原生键盘事件以做出相应回应，比如收回键盘。\n\n官方文档地址：Keyboard\n\n\n\n\nAppState#\n\n在 RN 开发中，经常会遇到前后台切换的场景。为了监控应用的运行状态，RN 提供了 AppState。通过 AppState\n开发者可以很容易地获取应用当前的状态。\n\n官方文档地址：AppState\n\n在 AppState 中，应用的状态被分为：\n\n * active：应用正在前台运行\n\n * background：应用正在后台运行。用户可能面对以下几种情况:\n   \n   * 在别的应用中\n   * 停留在桌面\n   * 对 Android 来说还可能处在另一个 Activity 中 ( 即便是由你的应用拉起的 )\n\n * [iOS] inactive：此状态表示应用正在前后台的切换过程中，或是处在系统的多任务视图，又或是处在来电状态中。\n\n要获取当前的状态，你可以使用 AppState.currentState，这个变量会一直保持更新。不过在启动的过程中，currentState 可能为\nnull，直到 AppState 从原生代码得到通知为止。\n\n\n\n我们回到桌面，然后再返回应用试试，控制台会打印\n\n","routePath":"/guide/reactNative/3-常用API/1-基础 API","lang":"","toc":[{"text":"基础 API","id":"基础-api","depth":2,"charIndex":-1},{"text":"Alert","id":"alert","depth":3,"charIndex":199},{"text":"StyleSheet","id":"stylesheet","depth":3,"charIndex":328},{"text":"Transforms","id":"transforms","depth":3,"charIndex":696},{"text":"Keyboard","id":"keyboard","depth":3,"charIndex":840},{"text":"AppState","id":"appstate","depth":3,"charIndex":938}],"domain":"","frontmatter":{},"version":""},{"id":137,"title":"","content":"屏幕 API#\n\n这一小节我们来看 RN 中和屏幕信息相关的 API，如下：\n\n * Dimensions\n * PixelRatio\n\n\nDimensions#\n\nDimensions 这个 API 在前面学习组件相关知识的时候，我们已经见到过它了。这里我们来正式介绍该 API。\n\n官方文档地址：Dimensions\n\n该 API 主要用于获取设备屏幕的宽高，Dimensions 的使用比较简单，只需要使用 get 方法即可获取宽高信息，如下：\n\n\n\n当然还有一种方法，利用解构\n\n\n\n> 对于 Android，window 尺寸将不包括 状态栏（如果不透明）和 底部导航栏 占用的大小。\n\n\n\n> 注意：尽管尺寸信息立即就可用，但它可能会在将来被修改（譬如设备的方向改变），所以基于这些常量的渲染逻辑和样式应当每次 render\n> 之后都调用此函数，而不是将对应的值保存下来。（举例来说，你可能需要使用内联的样式而不是在StyleSheet中保存相应的尺寸）。\n\n对于 React 函数组件，官方更推荐使用 useWindowDimensions 这个 Hook API。和 Dimensions\n不同，它会在屏幕尺寸变化时自动更新。参考：useWindowDimensions\n\n\nPixelRatio#\n\nPixelRatio 可以获取到设备的物理像素和 CSS 像素的比例，也就是 DPR。\n\n如果 CSS 像素和设备像素 1:1 关系，那么 DPR 值就为 1。如果 1 个 CSS 像素对应 2 个设备像素，那么 DPR 值就为 2。\n\n说简单点，就是一个 CSS 像素要用多少个设备像素来显示。如果 DPR 值为 1，表示用一个设备像素就够了，如果 DPR 值为 2，则表示一个 CSS 像素要用\n2 个设备像素来表示。\n\n以 iPhone4 为例，设备的物理像素为 640，为 CSS 像素为 320，因此 PixelRatio 值为 2。\n\n在 RN 中，通过PixelRatio.get()方法即可获取 DPR 值。\n\n官方文档地址：PixelRatio\n\n\n\n常见的屏幕像素密度表如下：\n\n设备像素密度   设备\n1        iPhone2G/3G/3GS 以及 mdpi Android 设备\n1.5      hdpi Android 设备\n2        iPhone4/5s/5/5c/5s/6/7/8 以及 xdpi Android 设备\n3        iPhone6Plus/6sPlus/7Plus/X/XS/Max 以及 xxdpi Android 设备\n3.5      Nexus6/PixelXL/2XL Android 设备\n\n我们通过前面的学习已经知道，在 RN 中所有尺寸都是没有单位的，例如: width: 100，这是因为 RN 中尺寸只有一个单位\ndp，这是一种基于屏幕密度的抽象单位，默认省略。\n\n在 RN 中，我们可以通过 PixelRatio 来将真实像素大小和 dp 单位进行一个转换\n\n * static getPixelSizeForLayoutSize(layoutSize: number): number：将 dp 单位转为 真实像素\n   px。返回值是一个四舍五入的整型\n * static roundToNearestPixel(layoutSize)：将真实像素 px 转为 dp 单位\n\n","routePath":"/guide/reactNative/3-常用API/2-屏幕 API","lang":"","toc":[{"text":"屏幕 API","id":"屏幕-api","depth":2,"charIndex":-1},{"text":"Dimensions","id":"dimensions","depth":3,"charIndex":69},{"text":"PixelRatio","id":"pixelratio","depth":3,"charIndex":546}],"domain":"","frontmatter":{},"version":""},{"id":138,"title":"","content":"设备 API#\n\n设备 API 主要用于获取当前用户的设备相关信息，从而根据不同的设备信息来做出可能不同的操作，主要包括：\n\n * Platform\n * PlatformColor\n * Appearance\n\n\nPlatform#\n\nPlatform 主要用于获取设备的相关信息。\n\n官方文档地址：Platform\n\n\n\n\nPlatformColor#\n\n每个平台都有系统定义的颜色，尽管可以通过 Appearance API 或 AccessibilityInfo\n检测并设置其中的某些样式，但是这样的操作不仅开发成本高早，而且还局限。\n\nRN 从 0.63 版本开始提供了一个开箱即用的解决方案来使用这些系统颜色。PlatformColor 是一个新的 API，可以像 RN\n中的其它任何颜色一样使用。\n\n官方文档地址：PlatformColor\n\n例如，在 iOS 上，系统提供一种颜色 labelColor，可以在 RN 中这样使用 PlatformColor：\n\n\n\n另一方面，Android 提供像 colorButtonNormal 这样的颜色，可以在 RN 中这样使用 PlatformColor：\n\n\n\n同时 DynamicColorIOS 是仅限于 iOS 的 API，可以定义在浅色和深色模式下使用的颜色。与 PlatformColor\n相似，可以在任何可以使用颜色的地方使用:\n\n\n\n最后是一个官方的例子：\n\n\n\n\nAppearance#\n\nAppearance 模块主要用于获取用户当前的外观偏好。目前的手机系统一般都可以选择线色模式和深色模式，通过 Appearance 开发者就可以获取此信息。\n\n官方文档地址：Appearance\n\nAppearance 模块提供了个 getColorScheme 的静态方法，该方法可以获取当前用户首选的配色方案， 对应的值有 3 个:\n\n * light：浅色主题\n\n * dark：深色主题\n\n * null：没有选择外观偏好\n\n例如：\n\n\n\n> 用户对颜色方案的偏好将映射到 Android 10（API 级别 29）、iOS 13 及更高版本设备上用户的浅色或深色主题偏好。\n\n尽管颜色方案可以立即使用，但这可能会发生变化（例如，在日出或日落时计划更改颜色方案）。任何依赖于用户首选颜色方案的渲染逻辑或样式都应该在每次渲染时调用此函数，而\n不是缓存值。\n\n可以使用 useColorScheme，因为它提供并订阅了颜色方案更新，或者您可以使用内联样式而不是在 StyleSheet\n中设置值。参考地址：useColorScheme","routePath":"/guide/reactNative/3-常用API/3-设备 API","lang":"","toc":[{"text":"设备 API","id":"设备-api","depth":2,"charIndex":-1},{"text":"Platform","id":"platform","depth":3,"charIndex":107},{"text":"PlatformColor","id":"platformcolor","depth":3,"charIndex":163},{"text":"Appearance","id":"appearance","depth":3,"charIndex":621}],"domain":"","frontmatter":{},"version":""},{"id":139,"title":"","content":"动画 API#\n\n这一小节我们来看一下 RN 中和动画相关的 API，如下：\n\n * LayoutAnimation\n * Animated\n\n\nLayoutAnimation#\n\nLayoutAnimation 是 RN 提供的一套全局布局动画\nAPI，只需要配置好动画的相关属性(例如大小、位置、透明度)，然后调用组件的状态更新方法引起重绘，这些布局变化就会在下一次渲染时以动画的形式呈现。\n\n官方文档地址：LayoutAnimation\n\n在 Andriod 设备上使用 LayoutAnimotion，需要通过 UIManager 手动启用，并且需要放在任何动画代码之前，比如可以放在入口文件\nApp.js 中。\n\n\n\n下面我们来看一个示例：\n\n\n\n在上面的代码中，我们定义了 customAnim 是一个对象， 该对象包含了两种动画方式，一种是 customSpring，另一种是 customLinear，\n\n每一种动画都用对象来描述，包含4个可选值:\n\n * duration：动画的时长\n * create：组件创建时的动画\n * update：组件更新时的动画\n * delete：组件销毁时的动画\n\n以 customSpring 为例，对应的 duration 为 400 毫秒，而 create 和 update 包括 delete\n对应的又是一个对象，其类型定义如下：\n\n\n\n其中 type 定义在 LayoutAnimationType 中，常见的动画类型有：\n\n * spring：弹跳动画\n * linear：线性动画\n * easeInEaseOut：缓入缓出动画\n * easeIn：缓入动画\n * easeOut：缓出动画\n * keyboard：\n\n动画属性 property 定义在 LayoutAnimationProperty 中，支持的动画属性有：\n\n * opacity：透明度\n * scaleX：X轴缩放\n * scaleY：Y轴缩放\n * scaleXY：全部缩放\n\n然后我们运用，如下，每次点击增加的时候都会有个动画效果\n\n\n\n\nAnimated#\n\n前面所学习的 LayoutAnimation\n称为布局动画，这种方法使用起来非常便捷，它会在如透明度渐变、缩放这类变化时触发动画效果，动画会在下一次渲染或布局周期运行。布局动画还有个优点就是无需使用动画化组\n件，如 Animated.View。\n\nAnimated 是 RN 提供的另一种动画方式， 相较于\nLayoutAnimation，它更为精细，可以只作为单个组件的单个属性，也可以根据手势的响应来设定动画 ( 例如通过手势放大图片等行为\n)，甚至可以将多个动画变化组合到一起，并可以根据条件中断或者修改。\n\n官方文档地址：Animated\n\n基本入门#\n\n下面我们先来看一个快速入门示例:\n\n\n\n这样我们就可以让其在显示和隐藏的过程中有着动画的效果了\n\n在事件处理函数中，使用 Animated.timing 方法并设置动画参数，最后调用 start 方法启动动画。\n\ntiming 对应的参数属性如下：\n\n * duration：动画的持续时间，默认为 500\n * easing：缓动动画，默认为 Easing.inOut\n * delay：开始动画前的延迟时间，默认为 0\n * isinteraction：指定本动画是否在 InteractionManager 的队列中注册以影响任务调度，默认值为 true\n * useNativeDriver：是否启用原生动画驱动，默认为 false\n\n除了 timing 动画，Animated 还支持 decay 和 spring。每种动画类型都提供了特定的函数曲线，用于控制动画值从初始值到最终值的变化过程。\n\n * decay：衰减动画，以一个初始速度开始并且逐渐减慢停止\n * spring：弹跳动画，基于阻尼谐振动的弹性动画\n * timing：渐变动画，按照线性函数执行的动画\n\n在 Animated 动画 API 中，decay、spring 和 timing 是动画的核心，其他复杂动画都可以使用这三种动画类型来实现。\n\n除了上面介绍的动画 API 之外，Animated 还支持复杂的组合动画，如常见的串行动画和并行动画。Animated 可以通过以下的方法将多个动画组合起来。\n\n * parallel：并行执行，就是一起执行\n * sequence：串行执行，就是顺序执行\n * stagger：错峰执行，其实就是插入 delay 的 parallel 动画\n\n就像下面这样：\n\n\n\n> 这边在 start 启动里面有个回调函数，指的是在动画结束后执行这个回调函数\n\n插值#\n\n在动画方面，更深入的可以参考官方文档：动画，其中有个插值较为重要\n\n插值是指将一定范围的输入值映射到另一组不同的输出值\n\n例如我这有个需要让其旋转 360 度的需求，怎么解决呢？\n\n\n\n如上，我通过插值将 [0, 1] 映射为 [\"0deg\", \"360deg\"] 就可以实现了\n\n动画化组件#\n\n关于动画化组件，前面我们使用的是 Animated.View ，目前官方提供的动画化组件有6种：\n\n * Animated.Image\n * Animated.ScrollView\n * Animated.Text\n * Animated.View\n * Animated.FlatList\n * Animated.SectionList\n\n它们非常强大，基本可以满足大部分动画需求，在实际应用场景中，可以应用于透明度渐变、位移、缩放、颜色的变化等。\n\n手势控制动画#\n\n除了上面介绍的一些常见的动画场景，Animated 还支持手势控制动画。手势控制动画使用的是\nAnimated.event，它支持将手势或其他事件直接绑定到动态值上。\n\n来看一个示例，下面是使用 Animated.event 实现图片水平滚动时的图片背景渐变效果。\n\n\n\n当 ScrollView 逐渐向左滑动时，左边的图片的透明度会逐渐降为 0。\n\n作为提升用户体验的重要手段，动画对于移动应用程序来说是非常重要的，因此合理地使用动画是必须掌握的一项技能。","routePath":"/guide/reactNative/3-常用API/4-动画 API","lang":"","toc":[{"text":"动画 API","id":"动画-api","depth":2,"charIndex":-1},{"text":"LayoutAnimation","id":"layoutanimation","depth":3,"charIndex":72},{"text":"Animated","id":"animated","depth":3,"charIndex":892},{"text":"基本入门","id":"基本入门","depth":4,"charIndex":1178},{"text":"插值","id":"插值","depth":4,"charIndex":1976},{"text":"动画化组件","id":"动画化组件","depth":4,"charIndex":2122},{"text":"手势控制动画","id":"手势控制动画","depth":4,"charIndex":2357}],"domain":"","frontmatter":{},"version":""},{"id":140,"title":"","content":"Animated 实战案例#\n\n前面的都有点基础，这节我们综合之前学到的知识做一个案例，效果如下：\n\n\n\n滑动几下后\n\n\n\n可以先复制样式，写样式浪费时间不值得\n\n\n\n然后我们先写一个简单的，先出现一个图片，这里可以用本地也可以用网上，自行选择\n\n\n\n如下面的效果：\n\n\n\n然后我们通过循环生成六个图片，我们先用弄一个数组\n\n\n\n然后循环生成\n\n\n\n然后我们为了区分每个图片，我们加一个文字进去\n\n\n\n如下：\n\n\n\n然后我们改一下 ScrollView 的属性，让他水平排列，不显示滚动条以及启用分页\n\n\n\n然后我们写下面的小圆点部分\n\n\n\n但现在小圆点和我们的图片没有关联起来，我们就用 Animated 来做，先一个状态\n\n\n\n然后给 ScrollView 的 onScroll 事件加上 Animated.event 来映射 x 的偏移到我们设置的状态\n\n\n\n然后修改下面的小圆点，给样式部分加上\n\n\n\n这里其实就是如果是当前的选中的索引，就将它的宽度设置大一点，很容易理解\n\n但目前还有问题是，只显示了2个或3个小圆点，其它的没了\n\n\n\n原因很简单，就是在超出我们设定的范围时候，会自动进行增量计算，所以在我们选中之前或之后的第二个小圆点开始就变为0了\n\n> 可以看看官网文档：插值，通过设置 extrapolate、extrapolateLeft 或 extrapolateRight 属性来限制输出区间。默认值是\n> extend（允许超出），不过你可以使用 clamp 选项来阻止输出值超过 outputRange。\n\n\n\n然后这个案例就完成啦，总的代码如下：\n\n","routePath":"/guide/reactNative/3-常用API/5-Animated 实战案例","lang":"","toc":[{"text":"Animated 实战案例","id":"animated-实战案例","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":141,"title":"","content":"手势 API#\n\n这一小节我们来看一下 RN 中和手势相关的 API\n\n官网文档地址：PanResponder\n\n先来看一个示例：\n\n\n\n我们手指先触摸方块然后移动，最后结束触摸，就会打印如下效果：\n\n\n\n在上面的示例中，我们通过 PanResponder 这个 API 的 create\n方法来创建一个手势方法的集合对象。该方法接收一个配置对象，配置对象中能够传递的参数如下：\n\n\n\n可以看到，配置对象对应的每一个配置值都是一个回调函数，每个回调函数都接收两个参数，一个 是原生事件对象，另一个是 gestureState 对象。两者配置如下：\n\n原生事件是指由以下字段组成的合成触摸事件：\n\n * nativeEvent\n   * changedTouches - 在上一次事件之后，所有发生变化的触摸事件的数组集合（即上一次事件后，所有移动过的触摸点）\n   * identifier - 触摸点的 ID\n   * locationX - 触摸点相对于父元素的横坐标\n   * locationY - 触摸点相对于父元素的纵坐标\n   * pageX - 触摸点相对于根元素的横坐标\n   * pageY - 触摸点相对于根元素的纵坐标\n   * target - 触摸点所在的元素 ID\n   * timestamp - 触摸事件的时间戳，可用于移动速度的计算\n   * touches - 当前屏幕上的所有触摸点的集合\n\n一个gestureState对象有如下的字段：\n\n * stateID - 触摸状态的 ID。在屏幕上有至少一个触摸点的情况下，这个 ID 会一直有效。\n * moveX - 最近一次移动时的屏幕横坐标\n * moveY - 最近一次移动时的屏幕纵坐标\n * x0 - 当响应器产生时的屏幕坐标\n * y0 - 当响应器产生时的屏幕坐标\n * dx - 从触摸操作开始时的累计横向路程\n * dy - 从触摸操作开始时的累计纵向路程\n * vx - 当前的横向移动速度\n * vy - 当前的纵向移动速度\n * numberActiveTouches - 当前在屏幕上的有效触摸点的数量\n\n我们根据这个改一点上面移动的代码：\n\n\n\n如下，我们移动的时候就会打印出值了：\n\n\n\n最后，我们把已经学过的 Animated 结合起来，书写一个拖动小方块的示例，这也是官方的示例：\n\n\n\n其中 Animated.ValueXY，其实和 Animated.Value 差不多，参考官网文档：Animated.ValueXY","routePath":"/guide/reactNative/3-常用API/6-手势 API","lang":"","toc":[{"text":"手势 API","id":"手势-api","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":142,"title":"","content":"React Navigation 简介#\n\n从本章起我们开始学习 RN 社区相关的生态库。RN 的社区生态相当丰富，很多东西官方没有提供，但是在社区已经有了很好的解决方案。\n\n这里首当其冲要介绍的就是 React Navigation，这是一个诞生于社区的 RN 导航库。\n\n本小节将介绍如下内容：\n\n * 什么是 React Navigation\n * React Navigation 的安装\n * React Navigation 体验\n\n\n什么是 React Navigation#\n\nReact Navigation 的诞生，源于 RN 社区对基于 Javascript 的可扩展且使用简单的导航解决方案的需求。\n\nReact Navigation 是 Facebook、Expo 和 React 社区的开发者们合作的结果：它取代并改进了 RN\n生态系统中的多个导航库，其中包括 Ex-Navigation、RN 官方的 Navigator 和 NavigationExperimentol 组件。\n\n学习 React Navigation，可以查看官方文档：React Navigation\n\n\n\nReact Navifation 特点\n\n在 React Navigation 中，内置了几种导航器，可以帮助我们实现页面之间的跳转\n\n * StackNavigator：一次只渲染一个页面，并提供页面之间跳转的方法。当打开一个新的页面时，它被放置在堆栈的顶部。简单来说就是普通页面跳，可传递参数\n * TabNavigator：渲染一个选项卡，类似底部导航栏，让用户可以在同一屏中进行几个页面之间切换\n * DrawerNavigator：提供一个从屏幕左侧滑入的抽屉\n\n> 远远不止这些，还有很多如Modal、Deep linking，可以多看官方文档\n\n\nReact Navigation 安装#\n\n接下来，要使用 React Navigation 首先肯定是安装它\n\n关于安装，参考文档：React Navigation 安装\n\n第一步，根据你的包管理器在终端输入如下命令，也可以用 yarn 或者 pnpm\n\n\n\n我们现在还是 Expo，所以还需要安装下面的依赖\n\n\n\n> 安装过程有网络问题，请解决科学上网\n\n\nReact Navigation 体验#\n\n安装完成后，我们就可以来书写一个简单的 demo 来体验下 React Navigation 。\n\n由于新版本的 React Navigation 已经将导航器独立成了一个单独的包，因此我们首先需要安装要用到的导航器，比如我们要用 stack\n\n\n\n我们是Expo项目，还需要安装如下：\n\n\n\n然后在App.js文件顶部添加如下：\n\n\n\n然后我们创建一个新目录 views，两个新文件 DetailScreen.js 、HomeScreen.js\n\n\n\n\n\n这两个类似，主要看App.js\n\n\n\n在上面的代码中，我们首先创建了 HomeScreen 和 DetailScreen 这两个组件，也就是我们的两个屏幕。\n\n接下来调用 createStackNavigator 方法创建了一个 Stack 导航的实例对象，然后通过上面的结构嵌套多个屏幕\n\n可以看到，Stack.Screen 就代表一屏，因为我们现在有两屏，所以一共有两个 Stack.Screen。\n\n在屏幕组件中，会自动传入当前的导航器实例，通过解构拿到这个导航器实例，上面常用的方法有：\n\n * navigate：导航方法，要导航到哪一屏，如果本身已经处于该屏，则不进行操作\n * push：以栈的形式往路由栈里面压入新的一屏，即使当前已处于该屏，也会重复压入新的一屏\n * goBack：返回上一屏，简单来讲就是栈顶那一屏出栈，回到栈顶的倒数第二屏\n\n最终效果如下：\n\n\n\n","routePath":"/guide/reactNative/4-社区生态/1-React Navigation 简介","lang":"","toc":[{"text":"React Navigation 简介","id":"react-navigation-简介","depth":2,"charIndex":-1},{"text":"什么是 React Navigation","id":"什么是-react-navigation","depth":3,"charIndex":223},{"text":"React Navigation 安装","id":"react-navigation-安装","depth":3,"charIndex":785},{"text":"React Navigation 体验","id":"react-navigation-体验","depth":3,"charIndex":966}],"domain":"","frontmatter":{},"version":""},{"id":143,"title":"","content":"参数传递和标题栏信息配置#\n\n本小节我们来看两个内容：\n\n * 参数传递\n * 标题栏信息配置\n\n参考官方文档：Passing parameters to routes、Configuring the header bar、Header buttons\n\n\n参数传递#\n\n参数传递在导航中是一个非常重要的内容，例如点击电影进入到这一部电影的电影详情， 那么我们就需要传递一个 id 过去\n\n参数传递整体分为两步：\n\n * 传递参数：通过将参数放在对象中作为 navigation.navigate 函数的第二个参数，将参数传递给路由\n\n\n\n * 接收参数：获取上一屏组件传递过来的参数\n\n\n\n来看一个示例：\n\n\n\n我们先传递参数，然后第二屏接收它\n\n\n\n第二屏不仅可以接收第一屏传递过来的参数，还可以手动修改这个参数，例如：\n\n\n\n在上面的代码中，我们在 DetailScreen 这一屏所返回的 JSX 中，添加了一个 Button 组件，点击之后通过\nnavigation.setParams 重新设置接收到的 otherParam 参数。\n\n可以在 Stack.Screen 中通过 initialParams 属性设置参数的默认值，例如:\n\n\n\n设置之后，我们在 Home 这一屏中，跳转到 DetailScreen 时，即使不传递 itemId 参数，DetailScreen 这一屏也能接收到一个名为\nitemId 的参数\n\n有些时候，我们并不是只会将第一屏的数据传递给第二屏，可能刚好相反要将第二屏的数据反向传递给第一屏，使用 navigate\n方法的时候，也可以很轻松的向上一屏传递数据。例如：\n\n\n\n效果如下：\n\n\n\n\n\n\n\n\n标题栏信息配置#\n\nScreen 组件接受 options 属性，它可以是对象，也可以是返回对象的函数，其中包含各种配置选项。例如上面我们所写的：\n\n\n\n有些时候标题栏并不是一开始就固定的，而是通过上一屏跳转过来时传递的参数过来而决定的。例如：\n\n\n\n在标题栏内容已经确定的当前屏幕下，想要修改当前屏的标题，可以使用 navigation.setOptions\n\n\n\n我们可以自定义标题的样式。自定义标题样式时要使用三个关键属性: headerStyle、headerTintColor 和 headerTitleStyle。\n\n * headerStyle：一个样式对象，将应用于包装标题的 View，如果你在它上面设置了 backgroundColor，那将是你的标题的颜色。\n * headerTintColor：后退按钮和标题都使用这个属性作为它们的颜色，在下面的示例中，我们将色调颜色设置为白色（#fff），因此后退按钮和标题都将为\n   白色\n * headerTitleStyle：如果我们想自定义标题的 fontFamily、fontWeight 等 Text 样式属性，可以用这个来做\n\n\n\n效果如下：\n\n\n\n还有一个很常见的需求，就是将整个应用的标题栏样式统一成一个样式。 可以通过配置 screenOptions 来实现这个功能，如下：\n\n\n\n有时，我们需要的不仅仅是更改标题的文本和样式，还需要更多的控制。\n\n例如，我们可能想要渲染图像来代替标题，或者将标题变成一个按钮。在这些情况下，可以完全覆盖用于标题的组件并提供我们自己的组件，例如:\n\n","routePath":"/guide/reactNative/4-社区生态/2-参数传递和标题栏信息配置","lang":"","toc":[{"text":"参数传递和标题栏信息配置","id":"参数传递和标题栏信息配置","depth":2,"charIndex":-1},{"text":"参数传递","id":"参数传递","depth":3,"charIndex":128},{"text":"标题栏信息配置","id":"标题栏信息配置","depth":3,"charIndex":722}],"domain":"","frontmatter":{},"version":""},{"id":144,"title":"","content":"嵌套路由与生命周期#\n\n本小节主要介绍 React Navigation 中的嵌套路由与路由的生命周期\n\n\n嵌套路由#\n\n\n\n在上面的示例中，Home 组件是一个选项卡路由，但同时 Home 组件还用于 App 组件内 Stack\n导航的主屏幕。所以在这里，选项卡路由嵌套在一个堆栈导航器中，类似于如下的结构：\n\n * Stack.Navigator\n   * Home(Screen)\n     * Feed(Screen)\n     * Message(Screen)\n   * Profile(Screen)\n   * Settings(Screen)\n\n下面是一个比较常见的嵌套路由：\n\n\n\n其中 SettingScreen 和 ProfileScreen 和 Home 差不多，就是一个普通的文字\n\n\n\n当使用嵌套路由时，有些注意细节，参考官方文档：How nesting navigators affects the behaviour\n\n嵌套路由的最佳实践\n\n一般来讲，我们应该尽可能的减少嵌套的层数，因为这多的嵌套层数可能会导致如下的问题：\n\n * 过深的嵌套层数可能导致低端设备出现内存和性能问题\n * 嵌套相同类型的导航器(例如选项卡内的选项卡，抽屉内的抽屉等)可能会导致混乱的用户体验\n * 由于嵌套过多，在导航到嵌套屏幕、配置深层链接等时，代码变得难以调试和阅读\n\n下面是一个关于登录注册的嵌套路由的最佳实践示例：\n\n\n\n\n生命周期#\n\n在 React 的类组件中，存在生命周期这一特性。\n\n考虑具有屏幕 A 和 B 的 Stack 类型路由。导航到 A 后，调用其 componentDidMount。在压入 B 时，它的\ncomponentDidMount 也会被调用，但 A 仍然挂载在堆栈上，因此不会调用它的 componentWillUnmount。\n\n从 B 回到 A 时，调用了 B 的 componentWillUnmount，但 A 的 componentDidMount 没有被调用，因为 A\n一直处于挂载状态，这就是在 React 中类组件的生命周期钩子函数特性。这些React生命周期方法在 React Navigation 中仍然有效。\n\n不过自从 React 推出了 Hook 后，更多的使用函数式组件，类组件中的生命周期钩子函数自然也被一些 Hook 替代。\n\n我们可以通过监听 focus 和 blur 事件来分别了解屏幕何时聚焦或失焦，\n\n\n\n在我们一进入 ProfileScreen 页面和退出页面的时候就会打印\n\n\n\n另外，我们还可以使用 useFocusEffect 挂钩来执行副作用来替代上面手动添加事件侦听器的方式。它类似于 React 的 useEffect\n钩子，但它与导航生命周期相关联。\n\n下面是一个使用示例:\n\n\n\n效果如下：\n\n\n\n","routePath":"/guide/reactNative/4-社区生态/3-嵌套路由与生命周期","lang":"","toc":[{"text":"嵌套路由与生命周期","id":"嵌套路由与生命周期","depth":2,"charIndex":-1},{"text":"嵌套路由","id":"嵌套路由","depth":3,"charIndex":53},{"text":"生命周期","id":"生命周期","depth":3,"charIndex":623}],"domain":"","frontmatter":{},"version":""},{"id":145,"title":"","content":"其他类型的导航#\n\n除了上面我们所介绍的 Stack 类型导航以外，React Navigation\n中提供了常用的其他类型的导航。本小节我们就一起来看一下这些常用导航类型，主要包括：\n\n * Tab navigation\n * Drawer navigation\n * Material Top Tabs Navigator\n\n\nTab navigation#\n\n移动应用程序中最常见的导航样式可能是基于选项卡的导航。这可以是屏幕底部的选项卡，也可以是标题下方顶部的选项卡(甚至可以代替标题)。\n\n首先安装 @react-navigation/bottom-tabs\n\n\n\n至于基本示例，我们在上一节课已经有了，就不过多展示了\n\n我们同样可以自定义外观，这类似于之前所介绍的 Stack 路由的方式，在初始化选项卡导航器时会设置一些属性，而其他属性可以在选项中按屏幕自定义\n\n我们先安装一个 icons 库\n\n\n\n然后可以对 Tab 下面的图标做改变\n\n\n\n效果如下：\n\n\n\n\n\n在上面的示例中，我们用到了 tabBarIcon 属性，该属性是底部选项卡导航器中支持的选项，需要将它放在 Tab.Navigator 的\nscreenOptions 属性中是为了方便集中图标配置。tabBarIcon\n是一个函数，它被赋予了焦点状态、颜色和大小参数。另外，tabBarActiveTintColor 和 tabBarInactiveTintColor\n表示活动以及非活动的颜色值。\n\n有时我们想给一些图标添加徽章。可以使用 tabBarBadge 选项来执行此操作：\n\n\n\n效果如下：\n\n\n\n当我们处于某一屏中，想要通过屏幕中的按钮进行 Tab 跳转可以使用 navigation.navigate，需要指明是哪一个标签页的，如下我在 Home 页跳到\nSetting 页面\n\n\n\n\nDrawer navigation#\n\nDrawer navigation 翻译成中文叫做抽屉导航，其实就是导航中常见的使用左侧(有时是右侧)的抽展在屏幕之间导航。\n\n首先第一步还是需要安装该类型的导航\n\n\n\n除了安装它之外，还需要额外安装 react-native-gesture-handler 和 react-native-reanimated，我们是\nExpo，安装需要这样安装：\n\n\n\n然后将下面的放在入口文件的最上面\n\n\n\n最后配置 babel.config.js，添加 plugins，如下：\n\n\n\n详细的安装步骤见：drawer-navigator Installation\n\n注意：在添加 Babel 插件后，重新启动开发服务器，并通过 --clear 来清除捆绑程序缓存\n\n简单的示例：\n\n\n\n效果如下：\n\n\n\n\n\n\n\n我们可以通过 open 和 close 方法来打开或者关闭抽屉，通过 toggleDrawer 来切换抽屉\n\n\n\n更多参考：API Definition\n\n\nMaterial Top Tabs Navigator#\n\nMaterial Top Tabs Navigator 翻译成中文叫做\"顶部滑动选项卡导航\"。要使用这种导航，首先还是需要先安装依赖，命令如下：\n\n\n\n然后还需要安装 react-native-pager-view，我们是 Expo，所以安装如下：\n\n\n\n下面是这个导航的简单示例：\n\n\n\n也可以嵌套：\n\n\n\n效果如下：\n\n\n\n\n\n还有一个，但和 Tabs navigation 非常类似，只是多了一个颜色的变化，可以参考：Material Bottom Tabs Navigator","routePath":"/guide/reactNative/4-社区生态/4-其他类型的导航","lang":"","toc":[{"text":"其他类型的导航","id":"其他类型的导航","depth":2,"charIndex":-1},{"text":"Tab navigation","id":"tab-navigation","depth":3,"charIndex":165},{"text":"Drawer navigation","id":"drawer-navigation","depth":3,"charIndex":791},{"text":"Material Top Tabs Navigator","id":"material-top-tabs-navigator","depth":3,"charIndex":1240}],"domain":"","frontmatter":{},"version":""},{"id":146,"title":"","content":"状态管理介绍#\n\n在目前前端的组件化开发风潮中，无论是 PC 端还是移动端，对于组件化来讲有一个非常重要的就是状态管理。要理解什么状态管理，首先就要理解什么是状态。\n\n实际上，状态的概念非常简单，就是每个组件自身可以维护一些数据。而由于组件与组件之间存在一些关系(例如父子关系、兄弟关系)，这就避免不了组件之间要进行数据的传递，\n这也就是所谓的组件状态管理出现的背景。\n\n如果使用传统的 porps\n或者自定义事件的形式来传递组件的数据，就会显得非常的繁琐，一个组件状态更新，需要一层一层传递到根组件，再由根组件一层一层往下传递。这样一个应用的组件层数嵌套得越\n深，工作量就会变得越大。\n\n在这样的背景下，专门用于状态管理的库就出现了。\n\n状态管理库的核心思想很简单，专门拿一个store的仓库来管理所有组件的状态，假如一个组件状态更新后，同步更新仓库中的状态，这样另一个组件再获取最新的状态时，也不\n用向之前那样层层传递，直接从仓库获取最近的状态即可。\n\n目前，市面上比较流行的状态管理库有:\n\n * Flux\n * Vuex\n * Redux\n * Mobx\n * Zustand\n * Jotai\n * Pinia\n\n\nFlux#\n\n2013年，Facebook 亮出 React 的时候，也跟着带出了 Flux。Facebook 认为两者相辅相成，结合在一起才能构建大型的\nJavaScript 应用。\n\nFlux 的组成：\n\n * View：视图层\n * Action：动作，即数据改变的消息对象(可通过事件触发、测试用例触发等)\n   * Store 的改变只能通过 Action\n   * 具体 Action 的处理逻辑一般放在 Store 里\n   * Action 对象包含 type (类型)与 payload (传递参数)\n   * Action 仅仅是改变 Store 的一个动作，一般包含该动作的类型、传递的数据\n * Dispatcher：派发器，接收Actions，发给所有的 Store\n * Store：数据层，存放应用状态与更新状态的方法，一旦发生变动，就提醒Views更新页面\n\n\n\nFlux 的特点：\n\n * 单向数据流。视图事件或者外部测试用例发出 Action，经由 Dispatcher 派发给 Store， Store 会触发相应的方法更新数据、更新视图\n * Store 可以有多个\n * Store 不仅存放数据，还封装了处理数据的方法\n\n\nVuex#\n\nVuex是Vue官方推出的状态管理库。\n\nVuex的核心概念：\n\n * Store: Vuex采用单一状态树，每个应用仅有一个 Store 实例，在该实例下包含了\n   state、actions、mutations、getters、modules。\n * State：Vuex为单一数据源。可以通过 mapStoate 辅助函数将 state 作为计算属性访问，或者将通过 Store 将 state\n   注入全局之后使用this.$store.state访问。State 更新视图是通过vue的双向绑定机制实现的。\n * Getter：Getter的作用与 filters 有一些相似，可以将 State 进行过滤后输出。\n * Mution：Mutaion 是 vuex 中改变 State\n   的唯一途径(严格模式下)，并且只能是同步操作。Vuex中通过store.commit()调用Mutation.\n * Action：一些对 State 的异步操作可以放在 Action 中，并通过在 Action 提交 Mutaion 变更状态。Action\n   通过store.dispatch()方法触发。可以通过 mapActions 辅助函数将 vue 组件的 methods\n   映射成store.dispatch调用(需要先在根节点注入store)\n * Module：当Store 对象过于庞大时，可根据具体的业务需求分为多个Module，每个Module都具有自己的state、mutotion、\n   action、getter。\n\n\n\nVuex的特点:\n\n * 单向数据流。View通过 store.dispatch()调用 Action，在 Action\n   执行完异步操作之后通过store.commit()调用Mutation 更新State，通过vue的响应式机制进行视图更新。\n * 单一数据源，和Redux一样全局只有一个Store实例。\n * 可直接对Store进行修改。\n\n\nRedux#\n\n作为一款针对 JavaScript 应用的可预测状态管理容器库，由 Dan Abramov 在 2015 年创建的 Redux 在创建之初曾受到 Flux\n架构以及函数式 Elm 的启发。后来，随着 Dan Abramov 加盟Facebook，Redux 最终成为Facebook旗下的一个子项目。Redux\n之所以被广泛接受，是因为Redux融合了各家技术于一身，不但简化了Flux 的流程与开发方式，还引入了一些优秀的设计理念。\n\n作为一个应用状态管理库，Redux 和Flux有很多相似的地方。不同之处在于，Flux\n可以有很多个改变应用状态的Store，并可以通过事件来触发状态的变化，组件可以通过订阅这些事件来和当前状态保持同步。\n\n在Redux中，则并没有 Dispatcher (分发器)的概念，Redux\n使用一个单独的常量状态树来保存整个应用的状态，并且这个对象是不能直接被改变的。如果某些数据发生改变，那么就会创建出一个新的对象。\n\n由于Redux是在Flux的基础上扩展出的一种单向数据流的实现，所以数据的流向、变化都能得到清晰的控制，并且能很好地划分业务逻辑和视图逻辑。\n\nRedux的组成：\n\n * Store：存储应用state以及用于触发state更新的dispatch方法等，整个应用仅有单一的Store\n * Store 中提供了几个 API：\n   * store.getState()：获取当前stote\n   * store.dispatch(action)：用于 View 发出 Action\n   * store.subscribe(listener)：设置监听函数，一旦 state 变化则执行该函数(若把视图更新函数作为listener\n     传入，则可触发视图自动渲染)\n * Action：同 Flux，Action 是用于更新state的消息对象，由View发出。有专门生成Action的Action Creator\n * Reducer：是一个用于改变state的纯函数(对于相同的参数返回相同的返回结果，不修改参数。不依赖外部变量)，即通过应用状态与Action推导出新的s\n   tate: (previousState, action) => newState。Reducer 返回个新的state\n\n\n\nRedux 的特点：\n\n * 单向数据流。View 发出 Action(store.dispatch(action))，Store 调用Reducer\n   计算出新的state，若state产生变化，则调用监听函数重新渲染View (store.subscribe(render))\n * 单一数据源，只有一个Store。\n * state是只读的，每次状态更新之后只能返回一个新的state\n * 没有Dispatcher，而是在Store中集成了dispatch 方法，store.dispatch()是View发出Action的唯一途径。\n\n\nMobx#\n\n作为一个应用状态管理库，Redux\n被广泛用于复杂的大型应用中，在很多大型Web前端应用中都可以看到它的身影。不过除了Redux,社区里近年来还有另一产品呼声很高那就是Mobx。\n\nMobX是由 Mendix、Coinbase 和 Facebook 开源的状态管理框架。MobX背后的哲学是:\n\n> 任何源自应用状态的东西都应该自动地获得。\n\n意思就是，当状态改变时，所有应用到状态的地方都会自动更新。它通过响应式函数编程来实现状态的存储和管理。受到面向对象编程和响应式编程的影响，Mobx\n可以将状态包装成可观察对象，通过观察和修改对象的状态进而实现视图的更新。\n\n这样一个功能强大，上手非常容易的状态管理工具。就连Redux的作者也曾经向大家推荐过它，在不少情况下你的确可以使用Mobx来替代掉Redux。\n\nMobx 的核心概念：\n\n * State：驱动应用的数据\n * Computed values：计算值，如果你想创建一个基于当前状态的值时，请使用 computed\n * Reactions：反应，当状态改变时自动发生\n * Actions：动作，用于改变 State\n * 依赖收集（autoRun）：Mobx 中的数据依赖基于观察者模式，通过 autoRun 方法添加观察者\n\n\n\nMobx 特点：\n\n * 数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新(细粒度控制)\n * 没有时间回溯能力，因为数据只有一份引用\n * 基于面向对象\n * 往往是多个Store\n * 代码侵入性小\n * 简单可扩展\n * 大型项目使用Mobx会使得代码难以维护\n\n\nZustand#\n\nZustand是一个用于管理状态的现代React状态库。它提供了简洁、可扩展和高效的状态管理解决方案，使得在React应用中处理复杂的状态逻辑变得更加容易和直观\n。\n\nZustand 特点：\n\n * 更少的样板代码\n\n * Zustand 只在 state 的值改变时渲染组件, 通常可以处理状态的改变而无需渲染代码\n\n * 状态管理通过简单定义的操作进行集中和更新, 在这方面和 Redux 类似, 但是又和 Redux 不太类似, Redux 开发必须创建\n   reducer、action、dispatch来处理状态, Zustand 让它变得更加容易\n\n * 使用 hooks 来管理 states, Hooks 在 react 中很流行, 因此是一个很受欢迎的状态管理库\n\n * Zustand 使用简单使用和简单实现的代码\n\n * 通过消除使用 Context Provides 从而使代码更短、更易读\n\n\n\n\nJotai#\n\nJotai 是一个轻量级的状态管理库，专为 React\n应用程序设计。它基于原子（atoms）的概念，提供了一种简单而强大的方式来管理应用程序的状态。与传统的状态管理解决方案相比，Jotai\n的设计理念更加简洁、灵活和直观。\n\nJotai 的特点和功能\n\n * **原子（Atoms）：**Jotai\n   的核心概念是原子，它代表了应用程序中的一个独立的状态单元。原子可以存储任何类型的数据，并且可以通过读取和更新原子来管理状态。\n * **响应性（Reactivity）：**Jotai 使用了 React\n   的上下文（Context）和钩子（Hooks）机制，实现了高效的响应性。当原子的状态发生变化时，相关的组件将自动重新渲染，确保应用程序保持同步。\n * **状态组合（State Composition）：**Jotai\n   允许开发人员将多个原子组合成一个更大的状态单元。这种状态组合的能力使得管理复杂的状态变得更加简单和可维护。\n * **优雅的 API：**Jotai 提供了一组简洁而直观的 API，使开发人员能够轻松地定义和使用原子。通过使用这些\n   API，可以避免冗长的状态管理代码和繁琐的生命周期方法。\n\nJotai 的优势\n\n * **简化的状态管理：**Jotai\n   提供了一种简洁而直观的方式来管理复杂的应用程序状态。开发人员可以通过定义原子和组合状态来轻松地管理应用程序的状态，减少了状态管理的复杂性。\n * **响应式和高性能：**Jotai 利用 React\n   的响应性机制，确保状态变化时组件的高效重新渲染。这种响应性的设计使得应用程序能够快速响应用户操作，并保持良好的性能。\n * **轻量级和灵活性：**Jotai\n   是一个轻量级的库，没有过多的依赖和复杂性。它的设计理念注重简洁和灵活性，使开发人员能够根据自己的需求自由地定义和组织状态。\n * **社区支持和生态系统：**Jotai 拥有一个活跃的开发者社区，提供了大量的文档、示例和支持。此外，Jotai 还与其他流行的 React\n   生态系统工具和库无缝集成，为开发人员提供更多的选择和灵活性。\n\n\n\n\nPinia#\n\nPinia 是一个用于 Vue.js 应用程序的状态管理库。这个库提供了一个简单且直观的 API 来管理 Vue.js 应用程序的状态。Pinia 是作为\nVue.js 官方状态管理库 Vuex 的一种轻量级替代方案而创建的。它的目标是提供一个更加简单和灵活的 API，同时还保留 Vuex\n的主要功能，如状态管理、动作和获取器。\n\nPinia 的一些关键特性包括：\n\n 1. 简单易用的 API：Pinia 的 API 设计简洁明了，易于理解和使用。这使得状态管理变得更加直观，让开发者可以更快速地上手和使用。\n 2. 开箱即用的开发工具：Pinia 集成了 Vuex 的开发者工具，使得开发者可以轻松地跟踪状态变化和调试代码。\n 3. 灵活的状态组织方式：与 Vuex 中的模块不同，Pinia 允许开发者自由地组织和管理状态。这使得在大型应用中管理状态变得更加灵活和方便。\n 4. 与 Vue 3 的组合式 API 无缝集成：Pinia 能够与 Vue 3 的组合式 API 无缝集成，使得状态管理代码更加的清晰和模块化。\n 5. 更好的 TypeScript 支持：Pinia 提供了出色的 TypeScript\n    支持，允许开发者在编写代码时获得类型提示和自动补全，提高代码的质量和可维护性。\n\n总的来说，Pinia 是一个强大而灵活的状态管理库，它的设计目标是让开发者可以更加轻松和高效地管理 Vue.js 应用程序的状态。\n\n","routePath":"/guide/reactNative/4-社区生态/5-状态管理介绍","lang":"","toc":[{"text":"状态管理介绍","id":"状态管理介绍","depth":2,"charIndex":-1},{"text":"Flux","id":"flux","depth":3,"charIndex":512},{"text":"Vuex","id":"vuex","depth":3,"charIndex":1046},{"text":"Redux","id":"redux","depth":3,"charIndex":1915},{"text":"Mobx","id":"mobx","depth":3,"charIndex":3186},{"text":"Zustand","id":"zustand","depth":3,"charIndex":3885},{"text":"Jotai","id":"jotai","depth":3,"charIndex":4308},{"text":"Pinia","id":"pinia","depth":3,"charIndex":5232}],"domain":"","frontmatter":{},"version":""},{"id":147,"title":"","content":"Redux的使用#\n\n本小节，我们结合 React Native 来回顾一下 Redux 的使用\n\n打开 Redux 的官方，这里有个快速入门的示例：入门 Redux\n\n\n@reduxjs/toolkit 基本使用#\n\n首先第一步，我们需要安装两个依赖，分别是 @reduxjs/toolkit 和 react-redux\n\n\n\n接下来，创建一个新的目录 redux，用于存放和 redux 操作相关的文件，在 redux 目录下，我们创建一个 store 和一个 reducers\n文件，如下：\n\n\n\n在 store 文件中，我们从 @reduxjs/toolkit 中解构导出一个名为 configureStore 的函数，该函数可以生成一个 store\n仓库，导出这个仓库。\n\n在创建该仓库时，接收一个配置选项，其中有一项就是要配置的 reducer\n\n\n\n可以看到，reducer 是从当前目录下的另一个文件 reducers 中引入的，该文件代码如下：\n\n\n\n然后我们新增加一个 Counter.js 文件，就是一个简单的计数器，代码如下：\n\n\n\n在 App.js 中，用 Provider 包裹，然后放入 Counter，代码如下：\n\n\n\n然后这个简单的计数器示例就完成，具体效果就不展示了，很简单。\n\n\nTODO示例#\n\n接下来我们举一反三，来书写一个待办事项的示例。\n\n在 src 目录下，新建三个子组件，分别是 Input、List、ToDoList，如下：\n\n\n\n在 App.js 中，引入 ToDoList 组件：\n\n\n\n其中 store 如下：\n\n\n\nreducer 如下：\n\n\n\n其中 ToDoList 是 Input 和 List 组成的，如下\n\n\n\n其中 Input 如下：\n\n\n\nList 如下：\n\n\n\n最终效果如下：\n\n\n\n\n\n","routePath":"/guide/reactNative/4-社区生态/6-Redux的使用","lang":"","toc":[{"text":"Redux的使用","id":"redux的使用","depth":2,"charIndex":-1},{"text":"@reduxjs/toolkit 基本使用","id":"reduxjstoolkit-基本使用","depth":3,"charIndex":85},{"text":"TODO示例","id":"todo示例","depth":3,"charIndex":558}],"domain":"","frontmatter":{},"version":""},{"id":148,"title":"","content":"Zustand 的使用#\n\nZustand 是一个没有 Redux 那么大心智负担的状态管理库，具体可看前面小节，这里讲一下他的基本用法\n\n首先先下载：\n\n\n\n\n计数器#\n\n我们来写之前 Redux 的计数器，看看 Zustand 是怎么管理呢？\n\nApp.js 如下，是的，不需要 Provider！！\n\n\n\n然后我们来使用 Zustand 来创建状态管理，新建一个目录 zustand，然后创建一个 CounterStore.ts\n\n\n\n其中 set 就是更新的方法，而且我们发现 zustand 不需要扩展运算符 ...state在前面了，因为 zustand\n自动帮我们把第一层的合并了，当然如果你有更深的还是需要扩展运算符的\n\n然后我们来写 Count.js\n\n\n\n我们只需要通过使用我们刚刚创建的示例 Store 就可以解构出所有方法了，但注意这里是需要所有方法才这样，如果是单个单个取就如下：\n\n\n\n> 这里如果你取单个也可以解构, 但结果是会导致重渲染, 后续会出相关状态管理课程,这里只是了解为主\n\n至此计数器就完成了，是不是发现要简单一点，因为不需要包裹 Provider ，不需要 dispatch\n\n\nTodoList 示例#\n\n我们再用 Zustand 来写一下上一节的 ToDoList\n\n先写 ToDoListStore.ts\n\n\n\n然后 Input、List 将方法改成 Zustand 获取即可，类似如下：\n\n\n\n效果就不展示了，和之前一样","routePath":"/guide/reactNative/4-社区生态/7-Zustand的使用","lang":"","toc":[{"text":"Zustand 的使用","id":"zustand-的使用","depth":2,"charIndex":-1},{"text":"计数器","id":"计数器","depth":3,"charIndex":80},{"text":"TodoList 示例","id":"todolist-示例","depth":3,"charIndex":512}],"domain":"","frontmatter":{},"version":""},{"id":149,"title":"","content":"其他第三方库#\n\n除了前面我们所介绍的 React Navigation、Redux、Zustand 以外，在 RN 开发中我们还会涉及到与需求相对应的其他第三方库。\n\n下面的地址罗列了目前在 RN 中支持的第三方库：React Native Directory\n\n\n\n里面罗列各个第三方库，点击可以进入对应的 Github 页面\n\n至于例子等等不再赘述，这里只是让你学会如何查找第三方库和查阅文档","routePath":"/guide/reactNative/4-社区生态/8-其他第三方库","lang":"","toc":[{"text":"其他第三方库","id":"其他第三方库","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":150,"title":"","content":"ExpoSDK#\n\n除了上一小节介绍的第三方库以外，expo 本身也为我们提供了丰富的 Expo SDK 供我们便用，例如前面在快速入门章节我们所接触到的 expo image\npicker，就是其中的一员。\n\n你可以在 https://docs.expo.dev/versions/latest/ 中 查看到 expo 中提供的所有 SDK\n\n例如我们要播放视频，就可以使用 Expo SDK 中所提供的 Video 用于播放视频，使用之前需要安装 expo-av 依赖。\n\n\n\n文档地址：Video，示例如下：\n\n\n\n其他的可以多看文档，基本上都提供了","routePath":"/guide/reactNative/4-社区生态/9-ExpoSDK","lang":"","toc":[{"text":"ExpoSDK","id":"exposdk","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":151,"title":"","content":"React Native 学习#\n\n我们即将学习 React 的跨端解决方案: React Native","routePath":"/guide/reactNative/","lang":"","toc":[{"text":"React Native 学习","id":"react-native-学习","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":152,"title":"你不知道的 CSS 之包含块","content":"This is text in the first paragraph...\n\nThis is text in the second paragraph.","routePath":"/guide/studyBase/css/CSS包含块","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":153,"title":"CSS 属性计算过程","content":"这是一个h1标题","routePath":"/guide/studyBase/css/CSS属性计算过程","lang":"","toc":[{"text":"确定声明值","id":"确定声明值","depth":2,"charIndex":-1},{"text":"层叠冲突","id":"层叠冲突","depth":2,"charIndex":-1},{"text":"比较源的重要性","id":"比较源的重要性","depth":3,"charIndex":-1},{"text":"比较优先级","id":"比较优先级","depth":3,"charIndex":-1},{"text":"比较次序","id":"比较次序","depth":3,"charIndex":-1},{"text":"使用继承","id":"使用继承","depth":2,"charIndex":-1},{"text":"使用默认值","id":"使用默认值","depth":2,"charIndex":-1},{"text":"一道面试题","id":"一道面试题","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":154,"title":"","content":"表格标签#\n\n * 表格主要作用：用于显示数据，展示数据\n\n * 相关定义和用法\n   \n   * 标签用于定义表格\n   * 标签用于定义表格中的行,必须嵌套在标签中\n   * 标签用于定义表格中的单元格,必须嵌套在标签中\n   * 标签用于表示表格中的表头部分,加粗居中显示\n\n * 表格属性\n   \n   属性名           属性值                 描述\n   align         left、center、right   规定表格相对周围元素的对齐方式\n   border        1 或\"\"               规定表格单元格是否拥有边框，默认为\"\",表示没有边框\n   cellpadding   像素值                 规定单元边沿与其内容之间的空白，默认 1 像素\n   cellspacing   像素值                 规定单元格之间的空白，默认 2 像素\n   width         像素值或百分比             规定表格的宽度\n\n * 表格结构标签\n   \n   * 标签表示表格的头部区域\n   * 标签表示表格的主体区域\n   \n   \n\n * 合并单元格\n   \n   * 跨行合并：rowspan=\"合并单元格的个数\" 最上侧单元格为目标单元格，写合并代码\n   * 跨列合并：colspan=\"合并单元格的个数\" 最左侧单元格为目标单元格，写合并代码\n\n\n列表标签#\n\n * 三类：无序列表，有序列表，自定义列表\n\n * 无序列表\n   \n   \n   \n   > 无序列表的各个列表项之间没有顺序级别之分，是并列的，中只能嵌套,在其中输入其他标签或文字是不允许的(规范) 可以放任何元素\n   > \n   > 无序列表自带属性，在 css 中改变\n\n * 有序列表\n   \n   \n   \n   > 列表排序以数字来显示\n\n * 自定义列表\n   \n   \n   \n   > 里面只能包含\n   > \n   > 个数没有限制，经常是一个对应多个\n\n\n表单标签#\n\n为了收集用户信息 一个完整的表单由表单域，表单控件(表单元素)，提示信息三部分组成\n\n * 表单域\n   \n   标签用于定义表单域，会将范围内的表单元素提交给服务器\n   \n   属性       属性值        作用\n   action   url 地址     用于指定接受并处理表单数据的服务器程序的 url 地址\n   method   get/post   用于设置表单数据的提交方式，取值为 get/post\n   name     名称         用于指定表单的名称，以区分同一个页面中的多个表单域\n\n * 表单控件\n   \n   * 输入，用于收集用户信息\n     \n     TYPE 属性值   描述\n     button     定义可点击按钮(多数情况下，用于通过 JavaScript 启动脚本)\n     checkbox   定义复选框\n     file       定义输入字段和\"浏览\"按钮，供文件上传\n     hidden     定义隐藏的输入字段\n     image      定义图像形式的提交按钮\n     password   定义密码字段。该字段中的字符被掩码\n     radio      定义单选按钮\n     reset      定义重置按钮。重置按钮会清除表单中的所有数据\n     submit     定义提交按钮。提交按钮会把表单数据发送到服务器\n     text       定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符\n   \n   * input 属性\n     \n     属性          属性值       描述\n     name        用户自定义     定义 input 元素的名称\n     value       用户自定义     规定 input 元素的值\n     checked     checked   规定此 input 元素首次加载时应该被选中\n     maxlength   正整数       规定输入字段中的字符的最大长度\n     \n     > name 和 value 主要给后台人员使用 name 表单名字要求复选框和单选框要有相同的 name 值\n   \n   * 为 input 标签定义标注(标签)\n     \n     \n     \n     > lable 的 for 属性要与相关元素的 id 属性相同\n   \n   * 下拉菜单 元素\n     \n     \n     \n     > 在中定义selected= \"selected\"时即默认选中项\n   \n   * 用于定义多行文本输入的控件\n     \n     ","routePath":"/guide/studyBase/html/html_down","lang":"","toc":[{"text":"表格标签","id":"表格标签","depth":2,"charIndex":-1},{"text":"列表标签","id":"列表标签","depth":2,"charIndex":640},{"text":"表单标签","id":"表单标签","depth":2,"charIndex":888}],"domain":"","frontmatter":{},"version":""},{"id":155,"title":"","content":"","routePath":"/guide/studyBase/html/html_up","lang":"","toc":[{"text":"1 HTML语法规范","id":"1-html语法规范","depth":3,"charIndex":-1},{"text":"1.1 基本语法概述","id":"11-基本语法概述","depth":4,"charIndex":-1},{"text":"1.2 标签关系","id":"12-标签关系","depth":4,"charIndex":-1},{"text":"2 HTML基本结构标签","id":"2-html基本结构标签","depth":3,"charIndex":-1},{"text":"骨架标签","id":"骨架标签","depth":4,"charIndex":-1},{"text":"3 网页开发","id":"3-网页开发","depth":3,"charIndex":-1},{"text":"3.1 文档类型声明标签","id":"31-文档类型声明标签","depth":4,"charIndex":-1},{"text":"3.2 lang语言种类","id":"32-lang语言种类","depth":4,"charIndex":-1},{"text":"3.3 字符集","id":"33-字符集","depth":4,"charIndex":-1},{"text":"4 HTML常用标签","id":"4-html常用标签","depth":3,"charIndex":-1},{"text":"4.1 标题标签`<h1>`-`<h6>`","id":"41-标题标签h1-h6","depth":4,"charIndex":-1},{"text":"4.2 段落标签和换行标签","id":"42-段落标签和换行标签","depth":4,"charIndex":-1},{"text":"4.3 文本格式化标签","id":"43-文本格式化标签","depth":4,"charIndex":-1},{"text":"4.4 `<div>`和`<span>`标签","id":"44-div和span标签","depth":4,"charIndex":-1},{"text":"4.5 图像标签和路径","id":"45-图像标签和路径","depth":4,"charIndex":-1},{"text":"4.6 超链接标签","id":"46-超链接标签","depth":4,"charIndex":-1},{"text":"5 HTML中的注释和特殊字符","id":"5-html中的注释和特殊字符","depth":3,"charIndex":-1},{"text":"音频标签","id":"音频标签","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":156,"title":"","content":"基础学习#\n\n本章你将学习 HTML,CSS,JS 的内容。","routePath":"/guide/studyBase/","lang":"","toc":[{"text":"基础学习","id":"基础学习","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":157,"title":"","content":"interface 和 type 的区别#\n\n比如下面这段代码\n\n\n\n从上面我们看到了 interface 缺失了索引签名, 那我们加上, 发现不报错了\n\n\n\n所以解决方案是加上索引签名\n\n那么产生的原因是什么呢\n\n把 interface 赋值 Record 的时候需要明确 interface 的属性,那我们明确了呀,为什么还会报错, 因为 interface\n会进行声明合并,如下,同名的 interface 都可以合并\n\n\n\n所以我们需要明确索引签名才能保证 Record 的正确性,但使用 type 就没有这个问题了,因为 type 不会进行声明合并,重名的会报错","routePath":"/guide/tips/1-interface和type的区别","lang":"","toc":[{"text":"interface 和 type 的区别","id":"interface-和-type-的区别","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":158,"title":"","content":"小知识#","routePath":"/guide/tips/","lang":"","toc":[{"text":"小知识","id":"小知识","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":159,"title":"","content":"V8 引擎#\n\n本章你将学习到 V8 引擎的原理","routePath":"/guide/v8/0-V8引擎前言","lang":"","toc":[{"text":"V8 引擎","id":"v8-引擎","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":160,"title":"","content":"V8引擎编译原理#\n\n\n什么是V8#\n\nV8是谷歌的开源高性能JavaScript和WebAssembly引擎，用C++编写。它被用于Chrome和Node.js等。它实现ECMAScript和Web\nAssembly，并在Windows 7或更高版本、macOS\n10.12+以及使用x64、IA-32、ARM或MIPS处理器的Linux系统上运行。V8可以独立运行，也可以嵌入到任何C++应用程序中。\n\nV8官网 v8.dev/\n\n\n宏观图#\n\n\n\n\n扫描器Scanner#\n\n\n\nBlink（谷歌浏览器的渲染引擎，基于webkit分支开发）主要负责HTML DOM CSS\n渲染，嵌入V8引擎，执行js，计算样式和布局，嵌入合成器，绘制图形。\n\nBlink 拿到html代码分析，找到script代码交给V8引擎解析，注意Blink是通过流的形式传给V8的。\n\n> 通过以流的形式传输数据，Blink可以逐步接收和处理来自网络的字节流，并在需要时将相应的数据传递给V8引擎执行。这种流式处理方式使得浏览器可以在数据到达的同\n> 时并行处理不同的任务，提高了页面的加载速度和用户体验\n\nScanner（扫描器）首先会进行词法分析\n\n摘抄自V8部分源码 Scanner\n\n> 位于V8/src/parsing/scanner-inl.h文件第347行开始\n\n\n\n 1. 首先获取当前字符c0_的值，并设置token为初始值。\n 2. 判断c0_是否是ASCII字符，如果是，则根据c0_的值来确定token的类型，并返回相应的Token。\n 3. 对于一些特殊情况，如条件运算符、字符串、小于号、大于号、等号、逻辑非、加号、减号、乘号、取模、除号、按位与、按位或等，根据当前字符和后续字符的组合来确定\n    token的类型，并返回相应的Token。\n 4. 如果c0_不是ASCII字符，或者不满足以上条件，则判断c0_是否是标识符的起始字符，如果是，则调用ScanIdentifierOrKeyword()函\n    数来获取标识符或关键字的Token。\n 5. 如果c0_是HTML注释的结束符'-'，则调用SkipSingleHTMLComment()函数来跳过整个HTML注释。\n 6. 如果扫描到文件末尾，则返回Token::EOS。\n 7. 否则，如果遇到空白字符，则调用SkipWhiteSpace()函数来跳过连续的空白字符，并继续扫描下一个Token。\n 8. 最后，返回扫描到的Token。\n\n举个例子 词法分析 解析为如下格式\n\n\n\n 1. Token::VAR：表示关键字\"var\"。\n 2. Token::WHITESPACE：表示空格字符。\n 3. Token::IDENTIFIER：表示标识符\"suzhenghui\"。\n 4. Token::WHITESPACE：表示空格字符。\n 5. Token::ASSIGN：表示赋值符号\"=\"。\n 6. Token::WHITESPACE：表示空格字符。\n 7. Token::STRING：表示字符串\"'szh'\"。\n\n词法分析结束后我们的js代码就会变成tokens 接下来进行语法分析\n\n\n解析器parser#\n\nparser 的作用就是将 tokens 转化为 AST 抽象语法树\n\n\n\n\n预解析PreParser#\n\nPreParser是预解析器，它的作用是在 JavaScript 代码执行之前对代码进行可选的预处理。预解析器的存在是为了提高代码的执行效率。\n\nV8 引擎采用了延迟解析（Lazy\nParsing）的策略，它的原理是只解析当前需要的内容，而把其他内容推迟到函数被调用时再进行解析。这样可以减少不必要的解析工作，提高网页的运行效率。\n\n例如，在一个函数 outer 内部定义了另一个函数 inner，那么 inner 函数就会进行预解析。这意味着在函数 outer 被调用之前，只会对 outer\n函数的内容进行解析，而对于 inner 函数的解析会在 outer 函数调用到 inner 函数时才进行。\n\n通过延迟解析的方式，V8 引擎可以避免解析和编译未被执行的函数，节省了不必要的时间和资源开销，提高了 JavaScript\n代码的执行效率。这种优化策略在大型复杂的 JavaScript 应用程序中尤为重要，可以帮助提升整体性能和用户体验。\n\n\n解释器Ignition#\n\n解释器的作用主要就是将AST 抽象语法树 转化成 字节码(bytecode)\n\n问？为什么要转成字节码而不是直接转成机器码\n\n 1. 跨平台执行：不同的硬件架构和操作系统有不同的机器码格式。通过将代码转换为字节码，可以使得同一份字节码在不同的平台上都能执行，实现跨平台的能力。\n 2. 快速启动和解析：将代码转换为字节码可以比直接生成机器码更快速地进行启动和解析。字节码通常具有更简单的格式和结构，可以更快地被引擎加载和解释执行。\n 3. 动态优化：现代的JavaScript引擎通常具有即时编译（JIT）功能，可以将热点代码编译成高效的机器码。通过首先将代码转换为字节码，引擎可以更好地进行\n    动态优化和编译，根据实际执行情况生成最优的机器码。这种方式可以在运行时根据代码的实际执行情况进行优化，而不需要提前生成固定的机器码。\n 4. 代码安全性：字节码作为中间表示形式，可以提供一定的代码安全性。字节码相对于源代码或机器码来说更难以理解和修改，可以提供一定程度的代码保护。\n\n示例 以下代码会被转成 字节码\n\n\n\n转化之后\n\n\n\n * PushString \"'szh'\"：将字符串字面量 \"'szh' \"推入堆栈（栈帧）。在这个例子中，它将字符串 \"'szh' \"推入堆栈。\n * StoreVar \"suzhenghui\"：将栈顶的值存储到变量 \"suzhenghui\" 中。在这个例子中，它将栈顶的字符串值存储到变量\n   \"suzhenghui\"\n\n\n编译器TurboFan#\n\n编译器就是将字节码也可以叫中间代码 最后 转换成 机器码 能让我们的CPU识别\n\n但是我们的CPU有不同的架构 ARM X86\n\n示例 我们的 字节码 转换成机器码例如 X86\n\n\n\nX86机器码\n\n\n\nARM机器码\n\n","routePath":"/guide/v8/1-V8引擎编译原理","lang":"","toc":[{"text":"V8引擎编译原理","id":"v8引擎编译原理","depth":2,"charIndex":-1},{"text":"什么是V8","id":"什么是v8","depth":3,"charIndex":11},{"text":"宏观图","id":"宏观图","depth":3,"charIndex":218},{"text":"扫描器Scanner","id":"扫描器scanner","depth":3,"charIndex":227},{"text":"解析器parser","id":"解析器parser","depth":3,"charIndex":1337},{"text":"预解析PreParser","id":"预解析preparser","depth":3,"charIndex":1388},{"text":"解释器Ignition","id":"解释器ignition","depth":3,"charIndex":1829},{"text":"编译器TurboFan","id":"编译器turbofan","depth":3,"charIndex":2478}],"domain":"","frontmatter":{},"version":""},{"id":161,"title":"","content":"V8引擎如何存储对象#\n\n\n在V8中对象的结构#\n\n主要分为三个指针构成的，分别是隐藏类，properties(常规属性)，elements（排序属性）\n\n我们先了解 常规属性 和 排序属性\n\n\n\n输出如下\n\n\n\n由此我们发现了一个神奇的现象，数字从小到大排列，但字符串还是按原顺序排列\n\n事实上，这是为了满足ECMA规范要求所进行的设计。按照规范中的描述，可索引的属性应该按照索引值大小升序排列，而命名属性根据创建的顺序升序排列。\n\n这里我们把对象中的数字属性称之为排列属性，在V8中被称为 elements，字符串属性就 被称为常规属性，在 V8 中被称为 properties。\n\n\n\n打开浏览器，控制台选择内存，堆快照，然后找到foo，可以发现 elements 但是没有看到 properties\n\n\n\n\n快属性和慢属性#\n\nV8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，我们把这称为对象内属性 (in-object properties)\n\n快属性\n\n对象内属性就是直接把属性挂到该对象上，查找的只需要一次 foo.A foo.B\n因此被称为快属性，但是注意，快属性容量是10个，超出之后就会添加到properties里面，称为慢属性。因此V8 采取了两种存储策略\n\n如图\n\n\n\n慢属性\n\n比如执行 Foo.property10这个语句来查找 property10 的属性值， 那么在 V8 会先查找出 properties 属性所指向的对象\nproperties，然后再在 properties 对象中查找 property10\n属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率,这就是慢属性。\n\n","routePath":"/guide/v8/2-V8引擎如何存储对象","lang":"","toc":[{"text":"V8引擎如何存储对象","id":"v8引擎如何存储对象","depth":2,"charIndex":-1},{"text":"在V8中对象的结构","id":"在v8中对象的结构","depth":3,"charIndex":13},{"text":"快属性和慢属性","id":"快属性和慢属性","depth":3,"charIndex":357}],"domain":"","frontmatter":{},"version":""},{"id":162,"title":"","content":"V8引擎隐藏类#\n\n上一章我们讲了V8如何存储的对象，其中提到了隐藏类，这一章我们来看看隐藏类到底做了什么\n\n隐藏类是V8引擎在运行时自动生成和管理的数据结构，用于跟踪对象的属性和方法，隐藏类的思想借鉴了静态语言的结构\n\n\n\nC++\n\n\n\n首先在JavaScript运行时，例如su.age 去查询 age 上节课我们讲过他会通过快慢属性 去找而且整个过程非常耗时。\n\n而C++就不同了，C++在声明一个对象之前需要定义该对象的结构，c++ 代码在执行之前是需要被编译的，编译的时候对象都是固定的，也就是代码执行的时候\n对象的形状是无法被改变的。\n\n所以V8就引入了 隐藏类的概念\n\n\n隐藏类 (Hiden Class)#\n\n隐藏类就是把JavaScript的对象也进行静态化，我们假设这个对象不会删除和新增，这样形状就固定了\n\n满足条件之后V8就会创建隐藏类，在这个隐藏类会创建对象的基础属性\n\n在V8引擎中，每个隐藏类都有一个编号（map id），用于唯一标识该隐藏类\n\n举个例子，假设我们有以下两个对象：\n\n\n\n这两个对象具有相同的形状，即都有属性name和age，但obj2还额外有一个属性address。V8会为它们生成两个不同的隐藏类\n\n\n\n可以看到，隐藏类1包含属性name和age，没有过渡表；而隐藏类2包含属性name、age和address，其中属性name和age的过渡表指向隐藏类1，属性a\nddress没有过渡表，表示该属性是新添加的\n\n\n如果两个对象属性一样呢？#\n\n如果两个对象具有相同的属性，它们将共享同一个隐藏类。具体来说，当两个对象的属性顺序和类型都相同时，V8会为它们生成一个共享的隐藏类。\n\n举个例子，假设我们有以下两个对象：\n\n\n\n这两个对象具有相同的形状，即都有属性name和age，且属性的顺序和类型完全一致。V8会为它们生成一个共享的隐藏类，如下所示：\n\n\n\n可以看到，隐藏类1包含属性name和age，没有过渡表，而且两个对象都共享这个隐藏类。\n\n> 这种共享隐藏类的机制可以节省内存空间，因为不同的对象可以共享相同的隐藏类结构。","routePath":"/guide/v8/3-V8引擎隐藏类","lang":"","toc":[{"text":"V8引擎隐藏类","id":"v8引擎隐藏类","depth":2,"charIndex":-1},{"text":"隐藏类 (Hiden Class)","id":"隐藏类-hiden-class","depth":3,"charIndex":292},{"text":"如果两个对象属性一样呢？","id":"如果两个对象属性一样呢","depth":3,"charIndex":632}],"domain":"","frontmatter":{},"version":""},{"id":163,"title":"","content":"准备工作#\n\n\n安装#\n\n * 运用 script 标签导入本地下载的 vue.js 或者 CDN 导入\n   \n   * 分为开发版本和生产版本，开发包含警告和调试，生产版本则压缩并将其警告等删除\n   * 利用下方代码可引入 CDN 的 vue.js，版本为 Vue2\n\n\n\n * 利用 npm 命令安装\n\n\n\n> 下面所有例子在 html 中进行编写，默认引入了vue\n\n\n安装 Vue Devtools#\n\n点击下方进入 github 官网，去谷歌应用商店安装，可以利用魔法或者查询别人发布的压缩包\n\nhttps://github.com/vuejs/devtools#vue-devtools\n\n\n消除生成提示#\n\n在开始前可以将 Vue 的 productionTip 设置为 false 来阻止 Vue 在启动时生成生产提示\n\n","routePath":"/guide/vue/1-vue2基础/1-准备工作","lang":"","toc":[{"text":"准备工作","id":"准备工作","depth":2,"charIndex":-1},{"text":"安装","id":"安装","depth":3,"charIndex":7},{"text":"安装 Vue Devtools","id":"安装-vue-devtools","depth":3,"charIndex":189},{"text":"消除生成提示","id":"消除生成提示","depth":3,"charIndex":303}],"domain":"","frontmatter":{},"version":""},{"id":164,"title":"","content":"条件渲染#\n\n使用v-show做条件渲染,如下 v-show通过改变 css 的display属性来决定是否显示\n\n\n\n使用v-if做条件渲染,如下v-if如果为 false 会直接让该 DOM 元素移除\n\n> 一般变化很频繁的话使用 v-show，如果不是很多一般用 v-if\n\n\n\n小案例：n 为不同值时显示不同标签 n 同为 1 时显示多个标签\n\n\n\n总结\n\n * v-if\n   * 写法：\n     * v-if=\"表达式\"\n     * v-else-if=\"表达式\"\n     * v-else=\"表达式\"\n   * 适用于：切换频率较低的场景\n   * 特点：不展示的 DOM 元素直接被移除\n   * 注意：v-if可以和v-else-if、v-else一起使用，但要求结构不能断掉\n * v-show\n   * 写法：v-show=\"表达式\"\n   * 适用于：切换频率较高的场景\n   * 特点：不展示的 DOM 元素未被移除，仅仅是使用样式隐藏掉\n * 备注：使用v-if时，元素可能无法获取到，而使用v-show一定可以获取到","routePath":"/guide/vue/1-vue2基础/10-条件渲染","lang":"","toc":[{"text":"条件渲染","id":"条件渲染","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":165,"title":"","content":"列表渲染#\n\n\nv-for 指令#\n\n * 用于展示列表数据\n\n * 语法：v-for=\"(item, index) in xxx\" :key=\"yyy\" (key 很重要需要写)\n\n * 可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）\n\n\n\n\nkey 的原理与作用#\n\n如果用索引 index 作为 key，如果每个后面的 input 框都输入值，将新数据添加到前面的时候 diff 算法只会根据不同改变，导致错误\n\n\n\n但如果用 id 作为 key 值的话，就不会出现错误\n\n\n\n> 如果不写 key，会默认用索引作为 key\n\n\n\n总结：\n\nReact 和 Vue 中的 key 有什么作用？（key 的内部原理）\n\n * 虚拟 DOM 中 key 的作用：\n   \n   * key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据【新数据】生成【新的虚拟 DOM】, 随后 Vue 进行【新虚拟\n     DOM】与【旧虚拟 DOM】的差异比较，比较规则如下：\n\n * 对比规则：\n   \n   * 旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：\n     \n     * 若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM\n     \n     * 若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM\n   \n   * 旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key\n     \n     * 创建新的真实 DOM，随后渲染到到页面。\n\n * 用 index 作为 key 可能会引发的问题：\n   \n   * 若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实 DOM 更新 ==> 界面效果没问题, 但效率低\n   \n   * 如果结构中还包含输入类的 DOM： 会产生错误 DOM 更新 ==> 界面有问题\n\n * 开发中如何选择 key:\n   \n   * 最好使用每条数据的唯一标识作为 key, 比如 id、手机号、身份证号、学号等唯一值\n   * 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的。\n\n\n列表过滤#\n\n\n\n\n列表排序#\n\n\n\n\n更新时的一个问题#\n\n需求：我们需要点击之后改变马冬梅的信息，但如果是用this.persons[0] = {id: '001', name: '马老师', age: 69,\nsex: '男'}就会发现页面并没有改变信息，但如果通过浏览器控制台输出会发现其实已经是改变的。\n\n原因：Vue 没有监测到数据的改变，具体在下面一小节解释\n\n\n\n\nVue 监测数据的原理_对象#\n\nVue 是通过 setter 和 getter 来监测数据的\n\n以下是一个简单的源码复现\n\n\n\n\nVue.set()方法#\n\n我想以后在 Student 里添加性别的属性，可以在浏览器控制台输入如下来添加响应式数据\n\nVue.set(vm._data.student,'sex','男')\n\n当然 vm 的一个方法和上面的方法一样\n\nvm.$set(vm._data.student,'sex','男')\n\n自然可以简化数据 因为vm._data.student === vm.student为 true 这是数据代理\n\nvm.$set(vm.student,'sex','男')\n\n在代码中通过 button 实现\n\n> 缺点：向响应式对象中添加属性，但该对象不能是 Vue 实例或 Vue 实例的根数据对象\n> \n> 即 vm.$set(vm._data,'leader','校长') 是错误的\n\n\n\n\nVue 监测数据的原理_数组#\n\n浏览器控制台如果输入vm._data会发现 hobby 是数组，但没有 getter 和 setter，但如果 hobby 是对象就会有\n\n所以如果是通过索引如vm._data.student.hobby[0] = '学习'可以修改但页面无法响应\n\n但通过数组的方法如push、shift等方法就可以改变并让页面的数据一块响应\n\n但这些方法不是 Array 原型对象上的方法，在浏览器控制台输入如下会输出false\n\nvm_data.student.hobby.push === Array.prototype.push\n\n> Vue 官方解释：Vue 将被侦听的数组的变更方法进行了包装，它们将会触发视图更新\n> \n> 当然 set 方法也可以改变，不过不建议这样使用\n\n\n\n\n总结 Vue 监视数据#\n\n把之前的都练习一遍，总结要点在下面\n\n\n\nVue 监视数据的原理：\n\n * Vue 会监视 data 中所有层次的数据\n * 如何监测对象中的数据\n   * 通过 setter 实现监视，且要在 new Vue 时就传入要监测的数据\n   * 对象中后追加的属性，Vue 默认不做响应式处理\n   * 如需给后添加的属性做响应式，需要使用如下 API\n     * Vue.set(target, propertyName/index, value)\n     * vm.$set(target, propertyName/index, value)\n * 如何监测数组中的数据\n   * 通过包裹数组更新元素的方法实现，本质就是做了两件事\n     * 调用原生对应的方法对数组进行更新\n     * 重新解析模板，进而更新页面\n * 在 Vue 修改数组中的某个元素一定要用如下方法\n   * 使用 API：push()、pop()、shift()、unshift()、splice()、sort()、reverse()\n   * 使用Vue.set()或vm.$set()\n   * 如果需要使用过滤filter()等方法则需要将数组替换\n * 特别注意：Vue.set()和vm.$set()不能给 vm 或 vm 的根数据对象添加属性","routePath":"/guide/vue/1-vue2基础/11-列表渲染","lang":"","toc":[{"text":"列表渲染","id":"列表渲染","depth":2,"charIndex":-1},{"text":"v-for 指令","id":"v-for-指令","depth":3,"charIndex":7},{"text":"key 的原理与作用","id":"key-的原理与作用","depth":3,"charIndex":129},{"text":"列表过滤","id":"列表过滤","depth":3,"charIndex":956},{"text":"列表排序","id":"列表排序","depth":3,"charIndex":966},{"text":"更新时的一个问题","id":"更新时的一个问题","depth":3,"charIndex":976},{"text":"Vue 监测数据的原理_对象","id":"vue-监测数据的原理_对象","depth":3,"charIndex":1147},{"text":"Vue.set()方法","id":"vueset方法","depth":3,"charIndex":1213},{"text":"Vue 监测数据的原理_数组","id":"vue-监测数据的原理_数组","depth":3,"charIndex":1568},{"text":"总结 Vue 监视数据","id":"总结-vue-监视数据","depth":3,"charIndex":1925}],"domain":"","frontmatter":{},"version":""},{"id":166,"title":"","content":"账号：\n\n密码：\n\n年龄：\n\n性别： 男 女\n\n爱好： 学习 打游戏 吃饭\n\n所属校区 请选择校区 北京 上海 深圳 武汉\n\n其他信息：\n\n阅读并接受《用户协议》 提交","routePath":"/guide/vue/1-vue2基础/12-收集表单数据(v-model)","lang":"","toc":[{"text":"收集表单数据(v-model)","id":"收集表单数据v-model","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":167,"title":"","content":"显示格式化后的时间\n\n\n现在是：{{fmtTime}}\n\n\n现在是：{{getFmtTime()}}\n\n\n现在是：{{time | timeFormater}}\n\n\n现在是：{{time | timeFormater('YYYY_MM_DD') | mySlice}}\n\n\nVue\n\n\n{{msg | mySlice}}","routePath":"/guide/vue/1-vue2基础/13-过滤器","lang":"","toc":[{"text":"过滤器","id":"过滤器","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":168,"title":"","content":"内置指令#\n\n我们学过的指令\n\n * v-bind : 单向绑定解析表达式, 可简写为 :xxx\n\n * v-model : 双向数据绑定\n\n * v-for : 遍历数组/对象/字符串\n\n * v-on : 绑定事件监听, 可简写为@\n\n * v-if : 条件渲染（动态控制节点是否存存在）\n\n * v-else : 条件渲染（动态控制节点是否存存在）\n\n * v-show : 条件渲染 (动态控制节点是否展示)\n\n\nv-text 指令#\n\n * 作用：向其所在的节点中渲染文本内容。\n * 与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。\n\n\n\n\nv-html 指令#\n\n * 作用：向指定节点中渲染包含 html 结构的内容\n * 与插值语法的区别：\n   * v-html会替换掉节点中所有的内容，{{xx}}则不会。\n   * v-html可以识别 html 结构。\n * 严重注意：v-html有安全性问题\n   * 在网站上动态渲染任意 HTML 是非常危险的，容易导致XSS攻击。\n   * 一定要在可信的内容上使用v-html，永远不要用在用户提交的内容上\n\n\n\n\nv-cloak 指令#\n\n * 本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉v-cloak属性\n * 使用 css 配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题\n\n\n\n\nv-once 指令#\n\n * v-once所在节点在初次动态渲染后，就视为静态内容了\n * 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能\n\n\n\n\nv-pre 指令#\n\n * 跳过其所在节点的编译过程\n * 可利用它跳过没有使用指令语法、没有使用插值语法的节点，会加快编译\n\n","routePath":"/guide/vue/1-vue2基础/14-内置指令","lang":"","toc":[{"text":"内置指令","id":"内置指令","depth":2,"charIndex":-1},{"text":"v-text 指令","id":"v-text-指令","depth":3,"charIndex":211},{"text":"v-html 指令","id":"v-html-指令","depth":3,"charIndex":289},{"text":"v-cloak 指令","id":"v-cloak-指令","depth":3,"charIndex":505},{"text":"v-once 指令","id":"v-once-指令","depth":3,"charIndex":608},{"text":"v-pre 指令","id":"v-pre-指令","depth":3,"charIndex":692}],"domain":"","frontmatter":{},"version":""},{"id":169,"title":"","content":"自定义指令#\n\n\n自定义指令_函数式#\n\n需求1：定义v-big指令，和v-text类似，但会把绑定数据放大10倍\n\n\n\n\n自定义指令_对象式#\n\n需求2：定义v-fbind指令，和v-bind类似，但可以让其所绑定的input元素默认获取焦点\n\n\n\n> 定义全局指令\n\n\n自定义指令总结#\n\n * 定义语法\n   \n   * 局部指令\n     \n     \n   \n   * 全局指令\n     \n     Vue.directive(指令名,配置对象)或Vue.directive(指令名,回调函数)\n\n * 配置对象中常用的3个回调\n   \n   * bind：指令与元素成功绑定时调用\n   * inserted：指令所在元素被插入页面时调用\n   * update：指令所在模板结构被重新解析时调用\n\n * 备注\n   \n   * 指令定义时不加v-，但使用时要加v-\n   * 指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名","routePath":"/guide/vue/1-vue2基础/15-自定义指令","lang":"","toc":[{"text":"自定义指令","id":"自定义指令","depth":2,"charIndex":-1},{"text":"自定义指令_函数式","id":"自定义指令_函数式","depth":3,"charIndex":8},{"text":"自定义指令_对象式","id":"自定义指令_对象式","depth":3,"charIndex":61},{"text":"自定义指令总结","id":"自定义指令总结","depth":3,"charIndex":136}],"domain":"","frontmatter":{},"version":""},{"id":170,"title":"","content":"生命周期#\n\n\n引出生命周期#\n\n生命周期：\n\n * 又名：生命周期回调函数、生命周期函数、生命周期钩子。\n\n * 是什么：Vue 在关键时刻帮我们调用的一些特殊名称的函数。\n\n * 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\n\n * 生命周期函数中的 this 指向是 vm 或 组件实例对象。\n\n\n\n\n生命周期图示#\n\n\n\n\n生命周期_挂载流程#\n\n根据图示，在第一步初始化的时候无法通过 vm 访问data和method，我们可以通过beforeCreate()来查看\n\n打开控制台查看 vm 会发现 vm 中没有data数据和method方法\n\n> 开控制台然后刷新可以进入断点\n\n\n\n接下来我们查看第二步，在beforeCreate()后添加created()，此时就会发现 vm 中有data和method了\n\n\n\n第三步将解析模板，生成虚拟 DOM，进入beforeMount()，在这里任何 DOM 最终不会生效\n\n第四步将内存中的虚拟 DOM 转为真实 DOM，然后进入mounted()，页面中呈现的是经过 Vue 编译的 DOM，对 DOM\n的操作均有效，至此初始化过程结束，一般在这进行：开启网络请求，开启定时器等初始化操作\n\n一个 Vue 属性template，使用它可以把root里的标签放入其中，但是需要所有标签只有一个根节点标签，即用一个div包裹一下，但现在我们是 html\n结构，所以后面使用\n\n\n\n\n生命周期_更新流程#\n\n在点击 n+1 后，进入更新流程，先到beforeUpdate()，此时数据更新了但页面没有更新\n\n随后根据新数据，生成新的虚拟 DOM，随后与旧的虚拟 DOM 比较，最终完成页面更新\n\n即完成了 Model➡View 的更新，进入到updated()此时数据更新了页面也更新了\n\n\n\n\n生命周期_销毁流程#\n\n当调用vm.$destroy()时进入销毁流程，触发后续钩子\n\n先进入beforeDestroy()，此时vm中所有的data、methods、指令等都处于可用状态，马上要执行销毁过程，一般在此阶段关闭定时器、取消订阅消息等\n收尾操作\n\n> 虽然在这可以调用 methods，如add()，但无法触发更新\n\n最后进入destroy()表示销毁结束\n\n\n\n\n总流程代码#\n\n\n\n\n总结生命周期#\n\n * 常用的生命周期钩子：\n   \n   * mounted: 发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等初始化操作\n   \n   * beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等收尾工作\n\n * 关于销毁 Vue 实例\n   \n   * 销毁后借助 Vue 开发者工具看不到任何信息\n   \n   * 销毁后自定义事件会失效，但原生 DOM 事件依然有效\n   \n   * 一般不会在beforeDestroy操作数据，即便操作数据，也不会再触发更新流程了\n\n上面的透明度变化例子\n\n","routePath":"/guide/vue/1-vue2基础/16-生命周期","lang":"","toc":[{"text":"生命周期","id":"生命周期","depth":2,"charIndex":-1},{"text":"引出生命周期","id":"引出生命周期","depth":3,"charIndex":7},{"text":"生命周期图示","id":"生命周期图示","depth":3,"charIndex":165},{"text":"生命周期_挂载流程","id":"生命周期_挂载流程","depth":3,"charIndex":177},{"text":"生命周期_更新流程","id":"生命周期_更新流程","depth":3,"charIndex":631},{"text":"生命周期_销毁流程","id":"生命周期_销毁流程","depth":3,"charIndex":787},{"text":"总流程代码","id":"总流程代码","depth":3,"charIndex":977},{"text":"总结生命周期","id":"总结生命周期","depth":3,"charIndex":988}],"domain":"","frontmatter":{},"version":""},{"id":171,"title":"","content":"组件#\n\n * 组件：实现应用中局部功能代码和资源的集合\n\n * 作用：复用编码，简化项目编码，提高运行效率\n\n * 非单文件组件：一个文件中包含有 n 个组件\n\n * 单文件组件：一个文件只包含有 1 个组件\n\n\n非单文件组件#\n\n基本使用#\n\nVue 中使用组件的三大步骤：定义、注册、编写\n\n * 如何定义一个组件？\n   \n   * 使用Vue.extend(options)创建，其中options和new\n     Vue(options)时传入的options几乎一样，但也有区别，区别如下：\n     \n     * el不写，因为最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器\n     \n     * data必须写成函数，为了避免组件被复用时，数据存在引用关系\n   \n   * 备注：使用template可以配置组件结构。\n\n * 如何注册组件？\n   \n   * 局部注册：靠new Vue的时候传入components选项\n   \n   * 全局注册：靠Vue.component('组件名',组件)\n\n * 编写组件标签：\n\n代码示例\n\n\n\n注意点#\n\n * 关于组件名:\n   \n   * 一个单词组成：\n     \n     * 第一种写法(首字母小写)：school\n     \n     * 第二种写法(首字母大写)：School\n   \n   * 多个单词组成：\n     \n     * 第一种写法(kebab-case 命名)：my-school\n     \n     * 第二种写法(CamelCase 命名)：MySchool (需要 Vue 脚手架支持)\n\n * 备注：\n   \n   * 组件名尽可能回避 HTML 中已有的元素名称，例如：h2、H2都不行\n   \n   * 可以使用 name 配置项指定组件在开发者工具中呈现的名字\n\n * 关于组件标签:\n   \n   * 第一种写法：\n   \n   * 第二种写法：\n   \n   * 备注：不用使用脚手架时，会导致后续组件不能渲染\n\n * 一个简写方式：\n   \n   const school = Vue.extend(options)可简写为：const school = options\n\n组件嵌套#\n\n需求：在school里包含student，school和hello外面包裹app\n\n\n\n关于 VueComponent#\n\n * 组件本质是一个名为VueComponent的构造函数，是Vue.extend生成的。\n\n * 我们只需写或，Vue 解析时会帮我们创建school组件的实例对象，Vue 帮我们执行的：new VueComponent(options)\n\n * 特别注意：每次调用Vue.extend，返回的都是一个全新的 VueComponent\n\n * 关于 this 指向：\n   \n   * 组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this 均是VueComponent\n     实例对象\n   \n   * new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this\n     均是Vue 实例对象\n\n * VueComponent 的实例对象，简称 vc（另称：组件实例对象）\n\n * Vue 的实例对象，简称 vm\n\n重要内置关系#\n\n前置知识：原型，简单例子\n\n\n\n重要的关系：\n\nVueComponent.prototype.__proto__ === Vue.prototype\n\n让组件实例化对象（vc）可以访问到 Vue 原型上的属性、方法\n\n\n\n\n\n\n单文件组件#\n\n创建xxx.vue文件，该组件有如下标签\n\n\n\n所以上面的 school 组件的例子就可以改为下面，student 可以自己试试\n\n\n\n创建App.vue组件汇总所有的组件\n\n\n\n创建main.js文件，创建 Vue 实例\n\n\n\n最终在 html 中引入main.js即可练习使用单文件组件\n\n\n\n> 后续我们会用到脚手架来创建 vue 项目，就无需通过script引入vue.js等文件","routePath":"/guide/vue/1-vue2基础/17-组件","lang":"","toc":[{"text":"组件","id":"组件","depth":2,"charIndex":-1},{"text":"非单文件组件","id":"非单文件组件","depth":3,"charIndex":107},{"text":"基本使用","id":"基本使用","depth":4,"charIndex":116},{"text":"注意点","id":"注意点","depth":4,"charIndex":496},{"text":"组件嵌套","id":"组件嵌套","depth":4,"charIndex":963},{"text":"关于 VueComponent","id":"关于-vuecomponent","depth":4,"charIndex":1014},{"text":"重要内置关系","id":"重要内置关系","depth":4,"charIndex":1465},{"text":"单文件组件","id":"单文件组件","depth":3,"charIndex":1588}],"domain":"","frontmatter":{},"version":""},{"id":172,"title":"","content":"初识 Vue#\n\n\nHello 小案例#\n\n 1. 想让 Vue 工作，就必须创建一个 Vue 实例，且要传入一个配置对象\n 2. root 容器里的代码依然符合 html 规范，不过混入了一些特殊的 Vue 语法\n 3. root 容器里的代码被称为 Vue 模版\n\nhtml 代码如下\n\n\n\n\n分析 Hello 小案例#\n\n * 如果有两个容器 root 绑定，一个 Vue 实例只会解析一个\n\n\n\n * 如果有两个 Vue 实例解析一个容器，第一个实例接管了 root，第二个实例没有作用\n\n\n\n * 容器和实例的关系为一对一，不能一对多或者多对一\n\n> 在{{}}里面写的是 JS 表达式\n> \n> 注意区分：JS 表达式和 JS 代码(语句)\n> \n>  1. 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：\n>     \n>     (1). a\n>     \n>     (2). a+b\n>     \n>     (3). demo(1)\n>     \n>     (4). x === y ? 'a' : 'b'\n> \n>  2. JS 代码(语句)\n>     \n>     (1). if(){}\n>     \n>     (2). for(){}\n\n 1. 真实开发中只有一个 Vue 实例，并且会配合着组件一起使用\n 2. 在{{xxx}}中 xxx 可以自动读取到 data 中的所有属性\n 3. 一旦 data 中的数据发生改变，那么页面中用到该数据的地方也会自动更新","routePath":"/guide/vue/1-vue2基础/2-初识Vue","lang":"","toc":[{"text":"初识 Vue","id":"初识-vue","depth":2,"charIndex":-1},{"text":"Hello 小案例","id":"hello-小案例","depth":3,"charIndex":9},{"text":"分析 Hello 小案例","id":"分析-hello-小案例","depth":3,"charIndex":148}],"domain":"","frontmatter":{},"version":""},{"id":173,"title":"","content":"模板语法#\n\n\n插值语法#\n\n\n\n\n\n\n指令语法#\n\n * 功能：用于解析标签（包括：标签属性，标签体内容，绑定事件...）\n * 备注：Vue 有很多的指令，且形式都是：v-??? ,此处仅以v-bind举例\n\n> v-bind:href=\"xxx\" 可以简写为 :href=\"xxx\" 可以动态绑定 data 里面的 xxx\n> \n> xxx 同样要写 js 表达式\n\n","routePath":"/guide/vue/1-vue2基础/3-模板语法","lang":"","toc":[{"text":"模板语法","id":"模板语法","depth":2,"charIndex":-1},{"text":"插值语法","id":"插值语法","depth":3,"charIndex":7},{"text":"指令语法","id":"指令语法","depth":3,"charIndex":19}],"domain":"","frontmatter":{},"version":""},{"id":174,"title":"","content":"数据绑定#\n\n\n单向数据绑定#\n\n> 单向绑定（v-bind）：数据只能从 data 流向页面\n\n\n\n\n双向数据绑定#\n\n> 双向绑定（v-model）：数据不仅能从 data 流向页面，还可以从页面流向 data\n> \n> 备注：\n> \n> 1.双向绑定一般都使用在表单类元素（如：input，select 等）\n> \n> 2.v-model：value 可以简写为 v-model，因为 v-model 默认收集的就是 value 值\n\n\n\n\nel 和 data 的两种写法#\n\n * el 另一种写法为\n\n\n\n * data 的另一种写法 ✔ 组件中必须使用函数式\n\n\n\n> Vue 管理的函数不用箭头函数，使用后 this 将不指向 Vue 实例","routePath":"/guide/vue/1-vue2基础/4-数据绑定","lang":"","toc":[{"text":"数据绑定","id":"数据绑定","depth":2,"charIndex":-1},{"text":"单向数据绑定","id":"单向数据绑定","depth":3,"charIndex":7},{"text":"双向数据绑定","id":"双向数据绑定","depth":3,"charIndex":51},{"text":"el 和 data 的两种写法","id":"el-和-data-的两种写法","depth":3,"charIndex":223}],"domain":"","frontmatter":{},"version":""},{"id":175,"title":"","content":"MVVM 模型#\n\n> M : 模型（Model）：对应 data 中的数据\n> \n> V：视图（View）：模板\n> \n> VM：视图模型（ViewModel）：Vue 实例对象\n\nVue 的设计借鉴了 MVVM 模型\n\n\n\n>  1. data 中所有的属性，最后都出现在了 vm 身上\n>  2. vm 身上所有的属性及 Vue 原型上的所有属性，在 Vue 模板中都可以直接使用","routePath":"/guide/vue/1-vue2基础/5-MVVM模型","lang":"","toc":[{"text":"MVVM 模型","id":"mvvm-模型","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":176,"title":"","content":"数据代理#\n\n> 通过一个对象代理对另一个对象中属性的操作即数据代理\n\n\nObject.defineProperty 方法#\n\n> 在 Vue 中数据代理类似这个方法\n\n在 js 中输入如下代码\n\n\n\n> 利用该方法生成的属性是不被枚举的(即不能被遍历)\n\n\nVue 中的数据代理#\n\n * Vue 中的数据代理：\n   \n   * 通过 vm 对象来代理 data 对象中属性的操作（读/写）\n\n * Vue 中数据代理的好处：\n   \n   * 更加方便的操作 data 中的数据\n\n * 基本原理：\n   \n   * 通过Object.defineProperty()把 data 对象中所有属性添加到 vm 上\n   * 为每一个添加到 vm 上的属性，都指定一个getter/setter\n   * 在getter/setter内部去操作（读/写）data 中对应的属性\n\n","routePath":"/guide/vue/1-vue2基础/6-数据代理","lang":"","toc":[{"text":"数据代理","id":"数据代理","depth":2,"charIndex":-1},{"text":"Object.defineProperty 方法","id":"objectdefineproperty-方法","depth":3,"charIndex":36},{"text":"Vue 中的数据代理","id":"vue-中的数据代理","depth":3,"charIndex":129}],"domain":"","frontmatter":{},"version":""},{"id":177,"title":"","content":"事件#\n\n\n事件处理#\n\n * 事件的基本使用\n   * 使用v-on:xxx 或 @xxx 绑定事件，其中 xxx 是事件名\n   * 事件的回调需要配置在 methods 对象中，最终会在 vm 上\n   * methods中配置的函数，不要用箭头函数，否则 this 指向就不将是 vm\n   * methods中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或组件实例对象\n   * @click=\"demo\"和@click=\"demo($event)\"效果一致，但后者可以传参\n\n> v-on:click 指令：当点击 button 时会找到 showInfo 的函数执行\n\n\n\n\n事件修饰符#\n\n * Vue 中的事件修饰符\n   \n   * prevent：阻止默认事件（常用）\n   \n   * stop：阻止事件冒泡（常用）\n   \n   * once：事件只触发一次（常用）\n   \n   * capture：使用事件的捕获模式\n     \n     \n     \n     > 当 div1 使用了 capture，表示 div1 在捕获阶段就处理了事件，即使我们点击的是 div2，但还是先输出了 1 然后才是 2\n   \n   * self：只有event.target是当前操作的元素时才会触发事件\n   \n   * passive：事件的默认行为立即执行，无需等待事件回调执行完毕\n     \n     > 修饰符可以连着写：@click.prevent.stop 即阻止默认事件和事件冒泡\n\n下面对 prevent 和 stop 说明，其他可以自己根据代码尝试\n\n以 prevent 举例，原本点击 a 后会弹出对话框然后会跳转到百度，但因为 prevent 阻止了默认事件，所以对话框结束后不会跳转\n\n以 stop 举例，原本点击 button 后应该只弹出一次对话框，但由于事件冒泡会多弹出一次，加了 stop 之后就发现多出的一次消失了，阻止了事件冒泡\n\n\n\n\n键盘事件#\n\n * Vue 中常用的按键别名\n   \n   > enter 也可以写为 Enter 其余同理，不过为了方便就全小写了\n\n按键操作   别名\n回车     enter\n删除     delete(捕获“删除”和“退格”键)\n退出     esc\n空格     space\n换行     tab(特殊：tab 自带切换焦点，必须配合 keydown 使用)\n上      up\n下      down\n左      left\n右      right\n\n * Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case(短横线命名)\n   \n   > 如@keyup.caps-lock 原本为 CapsLock 但要改为如上形式\n\n * 系统修饰键(用法特殊)：Ctrl 键，Alt 键，Shift 键，Meta 键(Windows 即 Win 键)\n   \n   * 配合 keyup 使用：按下修饰键的同时再按下其他键，随后释放其他键，事件才被触发\n   \n   * 配合 keydown 使用：正常触发事件\n     \n     > 可以通过连续写法来指定快捷键：@keyup.ctrl.y 只有用 Ctrl 键+Y 键才能触发\n\n * 可以使用 keyCode 去指定具体的按键（不推荐）\n\n * Vue.config.keyCodes.自定义键名 = 键码，可以定制按键别名\n\n","routePath":"/guide/vue/1-vue2基础/7-事件","lang":"","toc":[{"text":"事件","id":"事件","depth":2,"charIndex":-1},{"text":"事件处理","id":"事件处理","depth":3,"charIndex":5},{"text":"事件修饰符","id":"事件修饰符","depth":3,"charIndex":306},{"text":"键盘事件","id":"键盘事件","depth":3,"charIndex":860}],"domain":"","frontmatter":{},"version":""},{"id":178,"title":"","content":"计算属性与监视(侦听)属性#\n\n\n姓名案例-引出计算属性-computed#\n\n效果：两个输入框，一个输入姓，一个输入名，最后一个 span 显示全名，需要实时更改\n\n * 使用插值语法实现\n\n\n\n * 使用 methods 实现\n\n\n\n * 计算属性 computed✔\n   * 定义：要用的属性不存在，需要通过已有属性计算得来\n   * 原理：底层借助Object.defineproperty方法提供的 getter 和 setter\n   * get 函数什么时候执行\n     * 初次读取时会执行一次\n     * 当依赖的数据发生改变时会再次执行\n   * 优势：与 methods 相比，内部有缓存机制（复用），效率高且调试方便\n   * 备注：\n     * 计算属性最终会出现在绑定的 Vue 实例 vm 上，直接读取使用即可\n     * 如果计算属性要被修改，必须写 set 函数去响应修改，且 set 中要引起依赖数据发生变化\n\n\n\n💬 如果只需读取不修改，可以简写为下面形式(即直接一个函数)\n\n\n\n\n天气案例-引出监视属性-watch#\n\n效果：页面一个按钮，点击切换页面中的天气(文字)，今天天气很凉爽(炎热)\n\n * 以之前的学的知识的写法\n\n\n\n * 监视属性 watch✔(侦听属性)\n   * 当监视属性变化时，回调函数自动调用，进行相关操作\n   * 监视的属性必须存在才能进行监视\n   * 监视的两种写法\n     * new Vue时传入 watch 配置\n     * 通过vm.$watch监视\n   * 深度监视-deep\n     * Vue 中的 watch 默认不监测对象内部值的改变(一层)\n     * 配置deep:true可以监测对象内部值改变(多层)\n     * 备注：\n       * Vue 自身可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以\n       * 使用 watch 时根据数据的具体结构，决定是否采用深度监视\n\n\n\n💬 如果无需immediate:true和deep:true就可以简写为如下\n\n\n\n\ncomputed 和 watch 的区别#\n\n * computed 能完成的功能，watch 都可以完成\n * watch 能完成的功能，computed 却不一定能，如 watch 可以在数据变化时执行异步的操作时\n * 小原则\n   * 所有被 Vue 管理的函数，写成普通函数，这样 this 指向为 Vue 组件实例对象\n   * 所有不被 Vue 管理的函数，如定时器的回调函数，Ajax 的回调函数等，写成箭头函数，这样 this 指向不会被干扰，最终指向为 Vue\n     组件实例对象","routePath":"/guide/vue/1-vue2基础/8-计算属性与监视(侦听)属性","lang":"","toc":[{"text":"计算属性与监视(侦听)属性","id":"计算属性与监视侦听属性","depth":2,"charIndex":-1},{"text":"姓名案例-引出计算属性-computed","id":"姓名案例-引出计算属性-computed","depth":3,"charIndex":16},{"text":"天气案例-引出监视属性-watch","id":"天气案例-引出监视属性-watch","depth":3,"charIndex":466},{"text":"computed 和 watch 的区别","id":"computed-和-watch-的区别","depth":3,"charIndex":910}],"domain":"","frontmatter":{},"version":""},{"id":179,"title":"","content":"{{name}}\n\n\n{{name}}\n\n\n{{name}}\n\n\n{{name}}\n\n\n{{name}}","routePath":"/guide/vue/1-vue2基础/9-Class与Style绑定","lang":"","toc":[{"text":"Class 与 Style 绑定","id":"class-与-style-绑定","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":180,"title":"","content":"创建 Vue 脚手架#\n\n安装 vue 脚手架Vue CLI\n\n> 现在官方推荐使用 create-vue 来创建基于 Vite 的新项目，本文档使用 Vue CLI，该脚手架是基于 webpack 的\n\n\n\n创建一个项目，选择 Vue2 项目\n\n\n\n等到安装完后，切换启动\n\n","routePath":"/guide/vue/2-vue2进阶/1-创建Vue脚手架","lang":"","toc":[{"text":"创建 Vue 脚手架","id":"创建-vue-脚手架","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":181,"title":"","content":"浏览器本地存储#\n\n> 如果对这块内容熟悉可以跳过\n\n\nlocalStorage#\n\n一些网站在搜索过后会有搜索历史，那么这是如何存储的呢？一般就是通过localStorage来存储的，打开控制台，点击应用可以看到本地存储空间\n\n\n\n新建一个 HTML 文件，如下\n\n\n\n\nsessionStorage#\n\nsessionStorage特点：浏览器一关闭就没有了\n\n新建 HTML 文件，代码几乎和上面一样\n\n\n\n\n总结 WebStorage#\n\n 1. 存储内容大小一般支持 5MB 左右（不同浏览器可能还不一样）\n\n 2. 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制\n\n 3. 相关 API：\n    \n    * xxxxxStorage.setItem('key', 'value');\n      该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值\n    \n    * xxxxxStorage.getItem('person');\n    \n    该方法接受一个键名作为参数，返回键名对应的值\n    \n    * xxxxxStorage.removeItem('key');\n    \n    该方法接受一个键名作为参数，并把该键名从存储中删除\n    \n    * xxxxxStorage.clear()\n    \n    该方法会清空存储中的所有数据\n\n 4. 备注：\n    \n    * SessionStorage 存储的内容会随着浏览器窗口关闭而消失。\n    \n    * LocalStorage 存储的内容，需要手动清除才会消失。\n    \n    * xxxxxStorage.getItem(xxx)如果 xxx 对应的 value 获取不到，那么 getItem 的返回值是 null。\n    \n    * JSON.parse(null)的结果依然是 null。\n\n\nTodoList_本地存储#\n\n我们之前的数据是写死的，刷新后新添加的就没了，所以将数据放入localStorage来持久化\n\n在App.vue中添加watch来监视，此处只改变script，这里要开启深度监视，因为如果不开启，改变对象里面的值，watch是不监视的\n\n","routePath":"/guide/vue/2-vue2进阶/10-浏览器本地存储","lang":"","toc":[{"text":"浏览器本地存储","id":"浏览器本地存储","depth":2,"charIndex":-1},{"text":"localStorage","id":"localstorage","depth":3,"charIndex":27},{"text":"sessionStorage","id":"sessionstorage","depth":3,"charIndex":136},{"text":"总结 WebStorage","id":"总结-webstorage","depth":3,"charIndex":207},{"text":"TodoList_本地存储","id":"todolist_本地存储","depth":3,"charIndex":866}],"domain":"","frontmatter":{},"version":""},{"id":182,"title":"","content":"We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly\nwithout JavaScript enabled. Please enable it to continue.\n","routePath":"/guide/vue/2-vue2进阶/2-分析脚手架结构","lang":"","toc":[{"text":"分析脚手架结构","id":"分析脚手架结构","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":183,"title":"","content":"render 函数#\n\n之前我们在main.js中出现了一个我们不认识的render函数，这地方我们不认识，如果我们使用之前的方法\n\n\n\n会发现出现报错，因为该处引入的是 Vue 是一个残缺的，它缺少了模板解析器，具体到vue/dist/vue.runtime.esm.js，在 dist 目录下的\nvue.js 才是无缺的，其他都是为了精简产生的\n\n想要解决该报错，第一个解决方法是引入无缺的vue.js\n\n\n\n第二个解决方法就是使用render函数\n\n\n\n但由于没有用到 this，且只有一行，然后我们创建的是App组件，就可以简化为下面\n\n\n\n\n关于不同版本的 Vue#\n\n * vue.js与vue.runtime.xxx.js的区别：\n   \n   * vue.js是完整版的 Vue，包含核心功能和模板解析器\n   \n   * vue.runtime.xxx.js是运行版的 Vue，只包含核心功能，没有模板解析器\n\n * 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数\n   去指定具体内容\n\n\n配置文件#\n\n如果需要自定义脚手架的配置，则需要在根目录下创建vue.config.js文件\n\n\n\n 1. 在终端输入vue inspect > output.js查看 Vue 脚手架的默认配置\n 2. 使用vue.config.js对脚手架进行个性化定制\n\n> 详情见：https://cli.vuejs.org/zh","routePath":"/guide/vue/2-vue2进阶/3-render函数","lang":"","toc":[{"text":"render 函数","id":"render-函数","depth":2,"charIndex":-1},{"text":"**关于不同版本的 Vue**","id":"关于不同版本的-vue","depth":3,"charIndex":-1},{"text":"配置文件","id":"配置文件","depth":3,"charIndex":508}],"domain":"","frontmatter":{},"version":""},{"id":184,"title":"","content":"ref 属性#\n\n想要获取 dom 元素，可以采用ref属性\n\n * 被用来给元素或子组件注册引用信息（id 的替代者）\n\n * 应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象（vc）\n\n * 使用方式：\n   \n   * 打标识：\n     \n     \n     .....\n     \n     或\n   \n   * 获取：this.$refs.xxx\n\n","routePath":"/guide/vue/2-vue2进阶/4-ref属性","lang":"","toc":[{"text":"ref 属性","id":"ref-属性","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":185,"title":"","content":"props 配置项#\n\n * 功能：让组件接收外部传过来的数据\n\n * 传递数据：\n\n * 接收数据：\n   \n   * 第一种方式（只接收）：props:['name']\n   \n   * 第二种方式（限制类型）：props:{name:String}\n   \n   * 第三种方式（限制类型、限制必要性、指定默认值）：\n     \n     \n\n> 备注：props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props\n> 的内容到 data 中一份，然后去修改 data 中的数据。\n\nApp.vue文件，传入学生信息\n\n\n\nStudent.vue接收参数\n\n","routePath":"/guide/vue/2-vue2进阶/5-props配置项","lang":"","toc":[{"text":"props 配置项","id":"props-配置项","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":186,"title":"","content":"mixin(混入)#\n\n * 功能：可以把多个组件共用的配置提取成一个混入对象\n\n * 使用方式：\n   \n   * 第一步定义混合：\n   \n   \n   \n   * 第二步使用混入：\n     \n     全局混入：Vue.mixin(xxx) 局部混入：mixins:['xxx']\n\n需求：需要将共用的配置提取出来\n\nSchool.vue文件\n\n\n\nStudent.vue文件\n\n\n\n创建mixin.js文件，在main.js文件的同级目录下\n\n\n\n上面我将局部引入给注释，下面在main.js中可以进行全局引入\n\n","routePath":"/guide/vue/2-vue2进阶/6-mixin(混入)","lang":"","toc":[{"text":"mixin(混入)","id":"mixin混入","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":187,"title":"","content":"插件#\n\n * 功能：用于增强 Vue\n * 本质：包含install方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据\n * 定义插件，如下\n\n在 src 文件夹下创建plugins.js文件\n\n\n\n * 使用插件：Vue.use()\n   \n   在main.js文件使用插件，可以自己在 Student 组件和 School 组件尝试插件\n\n","routePath":"/guide/vue/2-vue2进阶/7-插件","lang":"","toc":[{"text":"插件","id":"插件","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":188,"title":"","content":"scoped 样式#\n\n * 作用：让样式在局部生效，防止冲突\n * 写法：\n   \n   在Student组件写样式，中间 script 部分省略，这里加上了lang=\"less\"表示使用 less\n   \n   > 此时会报错，需要下载less-loader，在终端输入如下代码安装\n   \n   这里两个类名一样冲突了，School 的背景色变为粉色，因为在 App 中我们后引入 Student\n   \n   但是如果我们在 style 中加上scoped，因为scoped让样式在局部生效，就会发现不冲突了\n   \n   \n   \n   在App组件中写样式，中间 script 部分省略\n   \n   ","routePath":"/guide/vue/2-vue2进阶/8-scoped样式","lang":"","toc":[{"text":"scoped 样式","id":"scoped-样式","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":189,"title":"","content":" * xxxxx 删除\n * yyyy 删除\n\n已完成0 / 全部2 清除已完成任务","routePath":"/guide/vue/2-vue2进阶/9-Todo-list案例","lang":"","toc":[{"text":"Todo-list 案例","id":"todo-list-案例","depth":2,"charIndex":-1},{"text":"拆分组件和功能描述","id":"拆分组件和功能描述","depth":3,"charIndex":-1},{"text":"静态组件撰写","id":"静态组件撰写","depth":3,"charIndex":-1},{"text":"初始化列表","id":"初始化列表","depth":3,"charIndex":-1},{"text":"添加","id":"添加","depth":3,"charIndex":-1},{"text":"勾选","id":"勾选","depth":3,"charIndex":-1},{"text":"删除","id":"删除","depth":3,"charIndex":-1},{"text":"底部统计","id":"底部统计","depth":3,"charIndex":-1},{"text":"底部交互","id":"底部交互","depth":3,"charIndex":-1},{"text":"总结案例","id":"总结案例","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":190,"title":"","content":"学习结构#\n\n本章你将学习到如下知识\n\n","routePath":"/guide/vue/","lang":"","toc":[{"text":"学习结构","id":"学习结构","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":191,"title":"","content":"从零手写 create-react-app#\n\n前置知识：\n\n * yarn包管理\n * workspace工作区知识概念\n * Monorepo知识概念\n\n\n初始化#\n\n一些知识科普讲解\n\n * Lerna 是一个用于管理具有多个包（packages）的 JavaScript 项目的工具。在一个大型 JavaScript\n   项目中，通常会有多个独立的模块或包，这些包可能相互依赖，或者需要一起发布。\n\n * 工作区（Workspace）通常是指在一个项目中，可以同时处理多个相关联的子项目（packages，modules等），而不需要将它们分别作为独立的项目来\n   处理。在软件开发领域，工作区通常是指一个包含了多个子项目的项目容器，这些子项目可以共享一些配置、依赖关系和构建流程。\n\n * Monorepo是\n   \"单一代码仓库\"（Monorepository）的缩写，它是一种软件开发的组织结构模式，其中所有项目或者库的代码都放在一个单一的版本控制仓库中。通常，这种\n   仓库包含了多个相关的项目、库或者组件，这些项目可能共享某些代码、依赖关系或者配置。\n\n全局安装 lerna\n\n\n\n输入如下检测是否安装成功\n\n\n\n在要创建的文件夹，打开终端，输入如下初始化\n\n\n\n打开后，这里我用 yarn管理，终端输入\n\n\n\n两个作用：安装lerna和它的依赖，在根目录的node_modules里面创建软链接，链向各个packages中的各个包\n\n> yarn 支持workspace npm只有在7版本以上支持\n> \n> yarn workspace VS lerna\n> \n> yarn重点在于包管理、处理依赖和软链\n> \n> lerna重点在于多个项目管理和发布\n\n然后创建 packages 文件夹（workspace），最终形成的初始文件目录如下\n\n\n\n\n创建 package#\n\n创建 create-react-app#\n\n在终端输入,然后在协议(license)改为 MIT，入口(main)改为index.js其它不变\n\n\n\n然后进入，把一些无用的删除，最终形成如下\n\n\n\n创建react-scripts#\n\n终端输入\n\n\n\n创建cra-template#\n\n终端输入\n\n\n\n查看工作包#\n\n终端输入\n\n\n\n\n\n最终形成的结构图如下\n\n\n\n\n添加依赖#\n\n在添加之前记得要设置为淘宝源，不然可能会安装很慢\n\n安装如下依赖\n\n\n\n>  * chalk: chalk 是一个用于在终端中添加颜色和样式的库。它允许你在命令行界面中使用不同的颜色和样式来输出文本，使得输出更加清晰和易读。\n>  * cross-spawn: cross-spawn 是一个用于跨平台（Windows、Linux、Mac\n>    等）运行子进程的库。它解决了在不同操作系统下创建子进程的差异性，使得在 Node.js 环境中能够一致地运行子进程。\n>  * fs-extra: fs-extra 是 Node.js 的文件系统模块（fs\n>    模块）的扩展，提供了更多的功能和便捷的方法，使得文件和目录的操作更加容易和灵活。\n>  * --ignore-workspace-root-check:这是 yarn add 命令的一个选项。当你在一个使用 Yarn\n>    工作区（Workspace）的项目中执行 yarn add 命令时，默认情况下 Yarn\n>    会检查你是否在工作区的根目录（root）中运行该命令。如果你使用了 --ignore-workspace-root-check 选项，Yarn\n>    将忽略这个检查，允许你在工作区的任意位置执行 yarn add 命令。\n\n在lerna里面，packages里面的各个会在node_modules里面形成符号链接即软链，这样可以在别的package中访问另一个package\n\n\n\n然后可以根据工作空间安装如下依赖\n\n\n\n> commander 是一个用于构建命令行界面（CLI）的 Node.js\n> 框架。它可以帮助开发者轻松地构建复杂和易用的命令行工具，提供了处理命令行参数、解析用户输入、显示帮助信息等功能\n\n\ncreateReactApp.js文件#\n\n在根目录package.json添加脚本命令\n\n\n\n在packages中的create-react-app文件夹的index.js文件更改\n\n\n\n在create-react-app文件夹中新建createReactApp.js文件\n\n> 由于接下来我们需要用到刚刚安装的依赖，我们可以快速学习一下\n\n\n\ninit函数#\n\n然后我们开始写createReactApp.js文件\n\n\n\n如果报错等，可以修改package.json文件的chalk，高版本可能有错\n\n\n\n在终端运行如下测试是否成功\n\n> -- 后面代码传参\n\n\n\n此处我们传入项目名，最终终端会输出 myApp\n\n\n\ncreateApp函数#\n\n然后在createReactApp.js中创建createApp函数，在init中添加，并修改init为async\n\n\n\n> 这里用到了path模块和fs-extra模块\n\n\n\n在终端执行,就会生成一个文件夹myApp并有一个package.json文件了\n\n\n\n\n\n> 扩展 JSON.stringify\n> \n> 如下代码\n> \n> \n> \n> 打印结果如下\n\nrun函数#\n\n在createApp函数最后加上执行run函数\n\n\n\n创建run函数\n\n\n\ninstall函数#\n\n> 这里用到了cross-spawn模块，记得导入\n\n创建install函数\n\n\n\n> cross-spawn 是一个用于跨平台（Windows、Linux 和 macOS）的 Node.js 包，用于跨平台地启动子进程。\n> \n> \n> \n> 换成这个就熟悉了吧\n\nexecuteNodeScript函数#\n\n> 拷贝模板的文件\n\n在run函数中补充\n\n\n\n创建executeNodeScript函数\n\n\n\n> 上述简化的意思是通过node执行脚本\n> \n> 即把data里面的数据放到了node后面\n> \n> 如下，执行出来就是输出aaa\n> \n> \n> \n> process.argv是一个包含命令行参数的数组\n> \n> \n> \n> 如下输出 就会发现上面abc也带入了\n\n此时基本完成，我们在终端输入\n\n\n\n安装上述的四个模块\n\n\n\n拷贝模板文件到bbb文件夹下\n\n\n\n然后会删除cra-template模块因为拷贝完了\n\n\n\n最终安装成功，cd bbb切换到bbb文件夹，输入yarn start查看是否启动成功\n\n\n\n查看bbb文件目录，发现和我们平时用cra创建的一样\n\n\n\n至此手写create-react-app已完成\n\n\n手写react-scripts编译#\n\n> create-react-app流程\n> \n>  * 执行命令\n>  * 创建了一个React项目\n>  * 安装依赖包\n>  * 初始化git，拷贝模板，安装模板依赖\n>  * 移除模板，成功\n\n\n\nreact-scripts.js#\n\n初始化#\n\n在package.json中配置\n\n\n\n在根目录的package.json配置\n\n\n\n在react-scripts文件夹创建bin文件夹，并创建react-scripts.js文件\n\n\n\n终端执行npm run build，输出done证明成功\n\n书写#\n\n在react-scripts文件夹下新建scripts文件夹，并创建build.js文件\n\n\n\n书写react-scripts.js文件\n\n\n\n根目录终端输入npm run build，输出build.js证明成功\n\nbuild.js#\n\n在react-scripts文件夹下新建config文件夹，并创建webpack.config.js文件和path.js文件\n\n> 在根目录下缺少什么依赖就安装什么依赖，如@babel/preset-react\n\n\n\n\n\n书写build.js文件\n\n\n\n在react-scripts目录随意创建public和src，public创建index.html并添加id为root的div，src创建index.js并输入\n如下\n\n\n\n在react-scripts中修改package.json,并安装\n\n\n\n随后终端输入npm run build，成功打包，生成build目录里面有所创建的压缩文件\n\nstart命令#\n\n根目录package.json配置,与build一样\n\n\n\n在在react-scripts的config里新建webpackDevServer.config.js\n\n\n\n在react-scripts的scripts里新建start.js\n\n\n\n在终端输入npm run start就会看到我们上面创建index.js所要显示的Hello World\n\n至此build和start命令我们都完成了，下面有源码讲解，如果上面有点吃力，建议再加深知识后来查看。\n\n\n源码解析#\n\n\nreact-scripts.js源码#\n\n\n\n\nbuild.js#\n\n\n\n\nenv.js#\n\n\n\n\nwebpack.config.js#\n\n展现部分代码，源代码配置等过多\n\n","routePath":"/handwriting/create-react-app/","lang":"","toc":[{"text":"从零手写 create-react-app","id":"从零手写-create-react-app","depth":2,"charIndex":-1},{"text":"初始化","id":"初始化","depth":3,"charIndex":79},{"text":"创建 package","id":"创建-package","depth":3,"charIndex":788},{"text":"添加依赖","id":"添加依赖","depth":3,"charIndex":984},{"text":"createReactApp.js文件","id":"createreactappjs文件","depth":3,"charIndex":1751},{"text":"init函数","id":"init函数","depth":4,"charIndex":1925},{"text":"createApp函数","id":"createapp函数","depth":4,"charIndex":2063},{"text":"run函数","id":"run函数","depth":4,"charIndex":2260},{"text":"install函数","id":"install函数","depth":4,"charIndex":2306},{"text":"executeNodeScript函数","id":"executenodescript函数","depth":4,"charIndex":2452},{"text":"手写react-scripts编译","id":"手写react-scripts编译","depth":3,"charIndex":2839},{"text":"react-scripts.js","id":"react-scriptsjs","depth":4,"charIndex":2962},{"text":"build.js","id":"buildjs","depth":4,"charIndex":3225},{"text":"start命令","id":"start命令","depth":4,"charIndex":3534},{"text":"源码解析","id":"源码解析","depth":2,"charIndex":3774},{"text":"react-scripts.js源码","id":"react-scriptsjs源码","depth":3,"charIndex":3782},{"text":"build.js","id":"buildjs-1","depth":3,"charIndex":3806},{"text":"env.js","id":"envjs","depth":3,"charIndex":3820},{"text":"webpack.config.js","id":"webpackconfigjs","depth":3,"charIndex":3832}],"domain":"","frontmatter":{},"version":""},{"id":192,"title":"","content":"学习结构#\n\n","routePath":"/handwriting/","lang":"","toc":[{"text":"学习结构","id":"学习结构","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":194,"title":"学习路线","content":"#\n\n\n基础阶段#\n\n * HTML：HTML4到HTML5，一些新特性要了解，比如contenteditable属性\n * CSS：CSS方面比较关键，分几个节点\n   * 第一个阶段：熟悉基本语法到CSS3\n   * 第二个阶段：学会运用预处理器如Less，Sass，学会CSS Module（普通实习够了）\n   * 第三个阶段：学会原子化 CSS 如TailwindCSS，UnoCSS（进阶）\n   * 第四个阶段：学会运用后处理器PostCSS，运用各个插件（进阶）\n * JavaScript：JavaScript主要为如下\n   * 基本语法，操作 DOM，BOM 等\n   * ES6+后的语法\n   * 正则表达式\n   * 设计模式（发布订阅模式建议学好，很常用，其他如单例模式了解即可）\n   * TypeScript：JS 的超集，我的建议是在学完 js 后就先了解好 ts 的基本语法，对以后有帮助\n   * Canvas（可选，有 2D 和 3D）\n * 数据结构和算法：学好这个对后面的源码部分有帮助\n   * 数组：队列，链表，哈希表等等\n   * 排序：双指针，二分（比较重要）等等\n * 数据交互：这块就是和后端交流最多的地方了，也分阶段\n   * （基本）Ajax：学好最基础的交互方法\n   * （基本）Axios：Ajax 的封装常用库，分几个小阶段\n     * 掌握基本用法\n     * 进阶就是你用 Ajax 自己封装出一个简单的 Axios\n     * 更进一步就是二次封装 axios，这点在项目中很多\n   * （基本）Fetch：建议掌握\n   * （进阶）WebSocket，SSE\n   * （必备）网络模式，HTTP 协议，TCP 三次握手四次挥手等，就是计算机网络部分，部分大公司很看重\n\n\n提升阶段#\n\n * 包管理工具，目前较多，基本只需了解命令，进阶的话需要了解工作区等概念\n   * npm（node 官方）\n   * cnpm（不推荐了现在）\n   * yarn（一般）\n   * pnpm（推荐，在速度方面很快且在后续的 Monorepo 项目中运用多）\n * 工程化：即构建工具一类，目前来说你想学深必须学好这里，如果很急的话暂时可以跳过，但不急的话建议先学懂这块再去学框架会更好\n   * Webpack：老牌常用的工具，进阶就是会定制插件\n   * Vite：新生代，构建很快，进阶就是会定制插件\n   * Gulp：不推荐了\n   * EsBuild：可选\n   * SWC：可选\n   * Babel：让我们使用新语法和 api，babel 会在编译中转为目标环境的支持的语法（进阶必学）\n * 项目管理：Git，学会多提交 github 代码，这里不多表述\n * 框架：主要分几个\n   * React：生态丰富，主要学好hooks，函数式编程已成主流，基本的库如下\n     * React-Router：路由\n     * Redux：状态管理，也有其替代如Zustand也用的多\n     * Antd：UI 库，我的建议是学的时候可以自己尝试用原生写一个类似的组件，因为企业中的需求很多不一样，需要自己定制一些 UI 组件库（后面 UI\n       库单独列一下）\n     * 进阶的一些如动画库 react-transition-group，可以根据需求寻找\n   * Vue：生态丰富，现在 Vue2 版本虽然停止维护，但还是建议学，很多面试会问 Vue2 和 Vue3 的区别\n     * Vue-Router：路由\n     * Vuex：状态管理，有Pinia替换\n   * Angular：老牌，但国内用的少，需要掌握 Rxjs\n   * Solid：新生，国内用的少\n * UI 组件库单独：\n   * PC 端\n     * Element UI\n     * Ant Design\n     * IView\n   * H5 端\n     * Vant（用的最多）\n     * Muse UI\n   * 小程序：（一般来说大前端包括小程序）\n     * Vant 和 iview\n\n\n进阶阶段#\n\n一般来说你学会前面的时候，运用好框架做好项目就可以实习了，这时候只要基础好基本没问题\n\n下面的内容就是进阶部分了，一般来说在实习不会问，源码方面大公司问的多，普通实习的同学了解即可\n\n * SSR服务器渲染：有利于 SEO 搜索引擎优化，一般是进阶学习\n   \n   * NuxtJS（运用在 Vue 框架）\n   * NextJS（运用在 React 框架）\n\n * 小程序：大部分公司都是前端写小程序，所以有必要还是学一下，实习的话一般不需要\n   \n   * 原生小程序（不推荐）\n   * Uniapp\n   * Taro\n\n * 跨端：如安卓，iOS\n   \n   * Uniapp：用的挺多\n   * Flutter：这个可选，因为需要学习一门新的语言 dart，所以难度较高\n   * HTML5 Plus：挺常用的\n   * Hybrid：很常用，可以嵌入到原生安卓和 ios 开发\n   * ReactNative：React 的跨端，学过 react 的话上手难度很低，很不错\n\n * 源码：这块很多问的大多都是框架的底层，很多大公司会问，建议多看网上八股和看源代码\n   \n   * Vue：如 v2 和 v3 底层实现，diff 算法等等\n   * React：如 fiber 架构，hooks 的区别等\n\n * 可视化：可选，一些公司用，技术如 Echarts，DataV，Ucharts 等\n\n * 微前端：可选，进阶学，大公司一般有用\n   \n   * 乾坤（阿里）\n   * macro APP（京东）\n   * 无界（腾讯）\n\n * 服务器：想要进阶的必备\n   \n   * Linux 的基础\n   * Nginx 基础，Nginx 的插件，lua 语言\n   * Pm2: 很常用的服务器库，进阶必备\n\n * 技术方案：各个需求的整合\n   \n   * 主题切换：如白天黑夜\n   \n   * 数据埋点和服务监控：大公司非常常用！\n   \n   * 性能监控和指标分析：作为高级工程师必须考虑好性能问题\n   \n   * monorepo：该项目想要用到另一个项目的东西，就需要这个技术了，目前 pnpm 方案很不错\n     \n     > 很大一部分你所熟知的项目都是该架构，如 React 框架\n   \n   * 国际化：如果需要发布在外国，就需要该技术的支持了\n\n * NodeJS：它是贯穿整个项目的基石，各个包各个库都是通过 node 来运作，作为 JavaScript 的运行时，它的重要性无可置疑\n   \n   * 包管理工具，上面已有概述\n   \n   * 核心模块：如 process，child_process，net，os，util 等\n   \n   * Express：前端变全栈的基石\n     \n     * Koa：集成框架，流行度高\n     * Egg：不推荐，毕竟该项目业务团队都没了\n     * Nest：很流行的框架，尤其在国外用的很多\n   \n   * Mysql：学会数据库才知道后端，所用技术为mysql2\n   \n   * ORM：调用数据库的集成框架\n     \n     * Knex：新手上手\n     * Prisma：最常用的框架，集成了多种数据库\n   \n   * Redis：内存数据结构存储系统，很常用，使用技术为ioredis\n   \n   * lua：一种轻量级、高效、可嵌入的脚本语言，在自动化方面很常用\n   \n   * serverLess：无服务器架构模式，建议学\n   \n   * 爬虫：没想到吧，node 也可以做爬虫相关的，所用技术为puppeteer\n   \n   * 学无止境，node 还有定制脚手架，定制命令行交互，甚至可以做嵌入式！\n\n\n学无止境阶段#\n\n这个阶段一般来说就是选择自己感兴趣的了，学习的路线远不止这些，各类技术层不出穷\n\n我只介绍一部分仅供扩展视野\n\n * SSG 技术：静态站点生成\n   \n   * VitePress：很常用的 SSG 技术框架\n   * Next：支持 SSG\n   * Rspress：字节开源的基于 rust 的 ssg 框架\n\n * 桌面开发：\n   \n   * Electron：常用的跨桌面端开发框架\n   * NW.js：以前常用的框架\n   * Tarui + Rust：新生代构建\n\n * Web系列：目前来说很多地方都有用，但只有用到的时候才学\n   \n   * WebGL：专门做图形绘制和渲染的\n     \n     * three.js框架：3D 渲染\n     * openGL：需要学着色器语言，学习图形学\n     * 数学：做图形绘制需要用到数学的向量、矩阵、三角函数等等\n   \n   * WebRTC：该技术主要用于音视频通话，浏览器录屏等\n   \n   * Web Socket：主要用于聊天室等等\n   \n   * Web Worker：允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js\n     操作多线程的能力。\n   \n   * Web SQL、IndexDB：存储大量客户端数据，推荐 IndexDB\n   \n   * Web Components：用于构建可复用用户组件的技术\n   \n   * Web Assembly：简称 wasm，一种通用字节码技术，它可以将其他编程语言（如 Go、Rust、C/C++\n     等）的程序代码编译为可在浏览器环境直接执行的字节码程序。\n     \n     > 想不到吧，浏览器也可以跑 C 和 C++这种代码\n   \n   * Web GPU：用于在 Web 应用程序中访问 GPU 的功能，js 也能调硬件！\n   \n   * Web View：跨端中为什么 h5 可以做呢，就是运用它，可以在原生中通过网络引入 h5 从而嵌入\n   \n   * Web AR：通过传感器等实现智能交互等\n   \n   * Web Serial：允许网站从串行设备通过脚本读取和写入的方式微控制器、3D 打印机和其他串行设备等设备进行通信的一套\n     API，通过它我们就可以和单片机通信了！神奇不！\n   \n   * Web Containers：基于 wasm 的系统，可在浏览器端启动nodejs环境！\n\n * JavaScript 运行时：新生代有bun包子技术\n\n * 区块链：Web3JS 技术\n\n * 游戏开发：Cocos，虚幻五\n\n * 嵌入式开发：Ruff js\n\n * 人工智能：TensorFlow 和 face-api\n\n学习的路线永无止境，加油吧同志们！","routePath":"/study","lang":"","toc":[{"text":"基础阶段","id":"基础阶段","depth":2,"charIndex":3},{"text":"提升阶段","id":"提升阶段","depth":2,"charIndex":780},{"text":"进阶阶段","id":"进阶阶段","depth":2,"charIndex":1755},{"text":"学无止境阶段","id":"学无止境阶段","depth":2,"charIndex":3348}],"domain":"","frontmatter":{},"version":""}]