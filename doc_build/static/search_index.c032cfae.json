[{"id":0,"title":"","content":"工程化#","routePath":"/guide/engineering/","lang":"","toc":[{"text":"工程化","id":"工程化","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"","content":"学习结构#\n\n","routePath":"/guide/","lang":"","toc":[{"text":"学习结构","id":"学习结构","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"","content":"文档声明#\n\n\n经典真题#\n\n * 什么是？是否需要在 HTML5 中使用？\n * 什么是严格模式与混杂模式？\n * 列举几条怪异模式中的怪癖行为？\n\n\n文档声明概念#\n\nHTML 文档通常以文档声明开始，该声明的作用是帮助浏览器确定其尝试解析和显示的 HTML 文档类型。\n\n\n\n文档声明必须是 HTML 文档的第一行、且顶格显示，对大小写不敏感。因为任何放在 DOCTYPE 前面的东西，比如批注或 XML 声明，会令 IE9\n或更早期的浏览器触发怪异模式(后面的渲染模式会介绍)\n\n文档声明并非一个 HTML 标签。它是一条\"信息\"，告知浏览器期望的文档类型。\n\n那么说到文档类型，我们首先有必要先了解一下 HTML 的发展历史。如下图所示:\n\n版本          年份\nHTML        1991\nHTML+       1993\nHTML 2.0    1995\nHTML 3.2    1996\nHTML 4.01   1999\nXHTML 1.0   2000\nHTML 5      2014\n\n> 其中还有很多，就不细分了\n\n可以看到，HTML 版本从最开始诞生到最新的 HTML5，中间经历了很多版本。 那不同的版本有啥区别么?当然有区别，比如一个最显著的区别就是支持的 HTML\n元素不同。例如下面的举例，还有很多区别\n\n标签       HTML 5   HTML 4   XHTML\na        Yes      Yes      Yes\napplet   No       Yes      No\naside    Yes      No       No\naudio    Yes      No       No\narea     Yes      Yes      No\n\n> 更多可以参考：https://www.w3school.com.cn/tags/html_ref_dtd.asp\n\n所以，你现在就知道为什么要书写文档声明了。原因是不同版本所支持的 HTML 元素类型是不同的，我需要告诉浏览器以哪一种文档类型方式来解析当前的这个 HTML\n文件。\n\n那么，最新的 HTML5 的文档类型倒是很简单，前面我们已经看到了\n\n\n\n那么稍微老一点的版本，例如 HTML4 或者 XHTML 的文档类型声明长啥样呢？\n\n这里我们看两个\n\nHTML 4.01 Strict\n\n该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素(比如 font)。不允许框架集（Framesets）。\n\n\n\nHTML 4.01 Transitional\n\n该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素(比如 font)。不允许框架集（Framesets）。\n\n\n\n> 更多参考：https://www.w3school.com.cn/tags/tag_doctype.asp\n\n首先，给我们的第一直观感受， 就是声明写得很长。\n\n那么为什么会这么长呢?\n\n原因很简单，HTML5 不需要引入DTD文件，而其他类型的文档声明是需要引入DTD的。\n\n很好，一个新的名词出现了，DTD.\n\n在早期的 HTML 版本，例如 HTML 4.01 中， 声明之所以要引用DTD，是因为 HTML 4.01\n基于SGML。而DTD规定的是标记语言的规则，这样浏览器才能正确地呈现内容。\n\n但是最新的 HTML 5 不基于 SGML,所以不需要引用 DTD。\n\n到这里估计有的小伙伴要懵圈了，怎么又冒出来一个SGML ? ?\n\n是的，你没有看错，我们有: SGML、HTML、XML、XHTML、HTML5\n\n从这五者的名字中，我们都可以看到\"ML\"这两个字母，所以我们先从ML说起。\n\n\"ML\"即\"Markup language(置标语言)\"。\n\n根据维基百科对其的解释，\"Markup\nlanguage\"是用标准的标记来解释纯文本文档的内容，从而提供关于文档结构或文档该如何渲染的信息。置标语言的发展可以用下面来表示:\n\n\n\nGML 是第一代置标语言，使文档能明确将标示和内容分开，所有文件使用同样的标示方法。\n\nSGML 在 GML 的基础上进行整理，形成了一套非常严谨的文件描述方法。它的组成包括语法定义，DTD,文件实例三部分。SGML 因太严谨规范达 500\n多页，故而不易学、不易用、难以实现，所以在它的基础上又发展出了其他的更易用的置标语言。\n\nHTML 抛弃了 SGML 复杂庞大的缺点，继承了 SGML 的很多优点。HTML 最大的特点是简单性和跨平台性。它只使用了 SGML 中很少的一部分标记，例如\nHTML 4.0 中只定义了 70 余种标记。为了便于在计算机上实现，HTML 规定的标记是固定的，即 HTML 语法是不可扩展的。\n\n随着 Web 应用的不断发展，HTML 的局限性也越来越明显地显现了出来，如 HTML 无法描述数据、可读性差、搜索时间长等。人们又把目光转向\nSGML，再次改造 SGML 使之适应现在的网络需求。1998 年 2 月 10 日，W3C(World Wide Web\nConsortium，万维网联盟)公布 XML 1.0 标准，XML 诞生了。很长一段时间，XML 都作为网络传输的标准数据格式。\n\nXHTML 的出现是因为当时的 HTML\n语法要求比较松散，这样对网页编写者来说，比较方便，但对于机器来说，语言的语法越松散，处理起来就越困难，对于传统的计算机来说，还有能力兼容松散语法，但对于许多其他\n设备，比如手机，难度就比较大。因此产生了由 DTD 定义规则，语法要求更加严格的 XHTML。\n\n> DTD 教程可以参考：https://www.w3school.com.cn/dtd/index.asp\n\n最终，HTML5 是 HTML 的第五个修订版，该版本不在基于 SGML 了，所以也就不用再引入 DTD 声明了。\n\nHTML5 的出现，其主要的目标是将互联网语义化，以便更好地被人类和机器阅读，并同时提供更好地支持各种媒体的嵌入。\n\n现在国内通常所说的 H5 开发，实际上是 HTML5 与 CSS3 及 ES6 的一个组合，大概可以用以下公式说明: HTML5 ≈ HTML5 + CSS3\n+ ES6\n\n\n渲染模式#\n\n明白了文档类型声明的作用之后，接下来我们还需要看一个东西，那就是渲染模式。\n\n浏览器渲染模式分为 3 种：\n\n * 怪癖模式（混杂模式）[Quirks mode]\n * 严格模式（标准模式）[Standars mode]\n * 几乎标准模式 [Almost standars mode]\n\n之所以出现不同的渲染模式，是由于历史原因造成的。\n\n当年 Netscape4 (网景公司早期的浏览器)和 IE4 (微软公司早期的浏览器)实现 CSS 机制时，没有遵循 W3C 提出的标准。Netscape4\n提供了糟糕的支持，而 1E4 虽然接近标准，但依旧未能完全正确的支持标准。\n\n所以，在 W3C 标准推出以前，浏览器在对页面的渲染上没有统一规范，产生了差异(Quirks mode 或者称为 Compatibility Mode)\n\n为了保障自己的网站在各个浏览器上显示正确，网页开发者们不得不依据各个浏览器自身的规范来使用 CSS，因此大部分网站的 CSS 实现并不符合 W3C 规范的标准。\n\nW3C 标准推出后，浏览器渲染页面有了统一的标准(Strict mode 也有叫做 Standars\nmode)浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致\n页面显示异常。\n\n为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法(如:微软的 IE) 。这样浏览器渲染上就产生了 Quircks mode 和\nStandars mode, 两种渲染方法共存在一个浏览器上。混杂模式服务于旧式规则，而严格模式服务于标准规则。\n\n> 对于 HTML 文档来说，浏览器使用文档开头的 DOCTYPE 来决定用怪异模式处理或标准模式处理。如果文档中没有 DOCTYPE\n> 将触发文档的怪异模式。怪异模式最明显的影响是会触发怪异盒模型。\n> \n> 在 DOCTYPE 声明中，没有使用 DTD 声明或者使用 HTML4 以下的 DTD 声明时，基本所有的浏览器都是使用 Quirks mode\n> 呈现，其他的则使用 Standars mode 解析。\n\n严格模式和怪异模式的部分渲染区别#\n\n 1. 盒模型的高宽包含内边距 padding 和 边框 border\n\n在 W3C 标准中，如果设置一个元素的宽度和高度， 指的是元素内容的宽度和高度，而在 IE5.5 及以下的浏览器及其他版本的怪异模式下，IE\n的宽度和高度还包含了 padding 和 border\n\n 2. 可以设置行内元素的高宽\n\n在严格模式下，给 span 等行内元素设置 width 和 height 都不会生效，而在怪异模式下，则会生效。\n\n 3. 可设置百分比的高度\n\n在严格模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。\n\n 4. 用margin:0 auto设置水平居中在 IE 下会失效\n\n使用margin:0 auto在严格模式下可以使元素水平居中，但在怪异模式下却会失效，怪异模式下的解决办法，用 text-align 属性:\nbody{text-align:center};#content{text-aligin:left}\n\n 5. 怪异模式下设置图片的 padding 会失效\n 6. 怪异模式下 Table 中的字体属性不能继承上层的设置\n 7. 怪异模式下white-space:pre会失效\n\n> 更多参考\n> MDN：https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standard\n> s_Mode\n> \n> MDN 还给出了不同模式下在不同浏览器的渲染区别(英文)：https://hsivonen.fi/doctype/\n\n\n真题解答#\n\n * 什么是？是否需要在 HTML5 中使用？\n\n> 它是 HTML 的文档声明，通过它告诉浏览器，使用哪一个 HTML 版本标准解析文档。\n> \n> 在浏览器发展的历史中，HTML\n> 出现过很多个版本，不同版本在元素、属性等书写格式上略有差异，如果不预先告诉浏览器，浏览器就不知道我们的文档标准是什么，在这种情况下，大部分浏览器将开启最大兼\n> 容模式来解析网页，我们称之为怪异模式。这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的 bug,所以文档声明是必须的。\n> \n> 而文档声明有多种书写格式，对应不同的 HTML 版本，这种书写是告诉浏览器，整个文档使用 HTML5 的标准进行解析。\n\n * 什么是严格模式与混杂模式？\n\n> 严格模式:又称标准模式，是指浏览器按照 W3C 标准解析代码。\n> \n> 混杂模式:又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。\n> \n> 如何区分:浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。\n> \n>  1. 如果文档包含严格的 DOCTYPE,那么它一般以严格模式呈现。(严格 DTD——严格模式)\n> \n>  2. 包含过渡 DTD 和 URI 的 DOCTYPE，也以严格模式呈现，但有过渡 DTD 而没有 URI\n>     (统一资源标识符，就是声明最后的地址)会导致页面以混杂模式呈现。(有 URI 的过渡 DTD——严格模式；没有 URI 的过渡 DTD——混杂模式)\n> \n>  3. DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。 (DTD 不存在或者格式不正确——混杂模式)\n> \n>  4. HTML5 没有 DTD,因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。( HTML5\n>     没有严格和混杂之分)\n> \n> 意义：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，\n> 每个浏览器都有自己的解析模式。\n\n * 列举几条怪异模式中的怪癖行为？\n\n>  1. 宽高的算法与 W3C 盒模型不同\n>  2. 在表格中的字体样式不会继承\n>  3. 怪异模式下可以设置行内元素宽高\n>  4. 怪异模式下 white-space:pre 会失效","routePath":"/guide/interview/html/1-文档声明","lang":"","toc":[{"text":"文档声明","id":"文档声明","depth":2,"charIndex":-1},{"text":"经典真题","id":"经典真题","depth":3,"charIndex":7},{"text":"文档声明概念","id":"文档声明概念","depth":3,"charIndex":76},{"text":"渲染模式","id":"渲染模式","depth":3,"charIndex":2624},{"text":"严格模式和怪异模式的部分渲染区别","id":"严格模式和怪异模式的部分渲染区别","depth":4,"charIndex":3569},{"text":"真题解答","id":"真题解答","depth":3,"charIndex":4282}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"","content":"语义化#\n\n\n经典真题#\n\n * 说说对HTML 语义化的理解\n\n\n什么是语义元素？#\n\n语义是指对一个词或者句子含义的正确解释。很多HTML标签也具有语义的意义，也就是说元素本身传达了关于标签所包含内容类型的一些信息。例如，当浏览器解析到\n\n\n\n\n标签时，它将该标签解释为包含这一块内容的最重要的标题。h1标签的语义就是用它来标识特定网页或部分最重要的标题。\n\n\n为什么要语义化？#\n\n * 代码结构：使页面没有css的情况下，也能够呈现出很好的内容结构\n * 有利于SEO：爬虫依赖标签来确定关键字的权重，因此可以和搜索引擎建立良好的沟通，帮助爬虫抓取更多的有效信息\n * 提升用户体验：例如title、alt可以用于解释名称或者解释图片信息，以及label标签的灵活运用。\n * 便于团队开发和维护：语义化使得代码更具有可读性，让其他开发人员更加理解你的htm/结构，减少差异化\n * 方便其他设备解析：如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染网页。\n\n\nHTML5 常用的语义元素#\n\nHTML5提供了新的语义元素来定义网页的不同部分，它们被称为“切片元素\"，如图所示:\n\n\n\n * header：用于定义页面的头部区域，通常包括网站logo、主导航、全站链接以及搜索框。\n * nav：定义页面的导航链接部分区域。\n * main：定义文档的主要内容，该内容在文档中应当是独一无二的\n * article：定义页面独立的内容，它可以有自己的header、footer、sections等，专注于单个主题的博客文章，报纸文章或网页文章。\n * section：表示文档中的一个区域（或节），比如，内容中的一个专题组\n * aside：表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的部分 且可以被单独的拆分出来而不会影响整体。通常表现为侧边栏或嵌入内容。\n * footer：定义最近一个章节内容或者根节点元素的页脚。-个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。\n\n> 有很多100多个html语义元素可以选择，更多参考：https://developer.mozilla.org/en-US/docs/Web/HTML/El\n> ement\n\n\n无障碍网页#\n\nW3C在1997年发起了一项WAI (Web Acessibility\nInitiative)的计划，该计划的目标是提升网站的易用性(acssibiliy)，而其中有一个很重要的指标，那就是能够被残障人士使用的网站才能称得上一个易用\n的(易访问的)网站。\n\nHTML5在无障碍方面进行了加强，加入了无障碍属性。\n\n所谓HTML5无障碍属性，主要针对的是视觉缺陷，失聪，行动不便的残疾人以及假装残疾的测试人员。尤其像盲人，眼睛看不到，其浏览网页则需要借助辅助设备，如屏幕阅读器\n，屏幕阅读机可以大声朗读或者输出盲文。\n\n而HTML5无障碍属性就是可以让屏幕阅读器准确识别网页中的内容，变化，状态的技术规范，可以让盲人这类用户也能无障碍阅读!\n\n> 关于更多说明，参考MDN：https://developer.mozilla.org/zh-CN/docs/Web/Accessibility\n\n常见的无障碍属性\n\nWAI-ARIA是W3C编写的规范，定义了一组可用于其他元素的HTML 特性，用手提供额外的语义化以及改善缺乏的可访问性。以下是规范中三个主要的特性:\n\n * 角色：这定义了元素是干什么的。许多「标志性的角色」，其实重复了HTML5的结构元素的语义价值。例如 role= \"navigation\"\n   (nav)或者role=\"complementary\" (aside)。\n * 属性：我们能通过定义一些属性给元素，让他们具备更多的语义。例如: aria-required=\"true\"\n   意味着元素在表单上是必填的。然而aril-labelledby=\n   \"label\"允许在元素上设置一个ID，用于labelledby引用作为屏幕阅读器指定的label内容，多个也可以。\n * 状态：用于表达元素当前的条件的特殊属性，例如aria\n   disabled=\"true\",屏幕阅读器就会这个表单禁止输入。状态和属性的差异之处就是:属性在应用的生命周期中不会改变，而状态可以，通常我们用编程的方法\n   改变它，例如Javascript\n\n关于WAI-ARIA属性重要的一点是它不会对Web页面有任何影响，除了让更多的信息从浏览器暴露给acessibilitAPIs (无障碍API),\n这也是屏幕阅读器这一类软件的信息源。WAI-ARIA不会影响网页的结构，以及DOM等等，尽管这些属性可用于作为CSS选择器。\n\n> 更多参阅：[https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility/WAI-ARIA_ba\n> sics]*https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility/WAI-ARIA_ba\n> sics\n\n\n真题解答#\n\n * 说说对html语义化的理解\n\n语义化的目的主要有以下几点：\n\n 1. 去掉或者丢失样式的时候能够让页面呈现出清晰的结构\n\n 2. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息:爬虫依赖于标签来确定上下和各个关键字的权重\n\n 3. 方便其他设备解析(如屏幕阅读器、盲人阅读器、移动设备)以意义的方式来渲染网页\n\n 4. 便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。HTML5 中新增加的很多标签，例如:\n    article、 nav, header 和footer等，就是基于语义化设计原则","routePath":"/guide/interview/html/2-语义化","lang":"","toc":[{"text":"语义化","id":"语义化","depth":2,"charIndex":-1},{"text":"经典真题","id":"经典真题","depth":3,"charIndex":6},{"text":"什么是语义元素？","id":"什么是语义元素","depth":3,"charIndex":33},{"text":"为什么要语义化？","id":"为什么要语义化","depth":3,"charIndex":182},{"text":"HTML5 常用的语义元素","id":"html5-常用的语义元素","depth":3,"charIndex":439},{"text":"无障碍网页","id":"无障碍网页","depth":3,"charIndex":952},{"text":"真题解答","id":"真题解答","depth":3,"charIndex":2151}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"","content":"W3C#","routePath":"/guide/interview/html/3-W3C","lang":"","toc":[{"text":"W3C","id":"w3c","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"","content":"SEO#","routePath":"/guide/interview/html/4-SEO","lang":"","toc":[{"text":"SEO","id":"seo","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"","content":"iframe#","routePath":"/guide/interview/html/5-iframe","lang":"","toc":[{"text":"iframe","id":"iframe","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"","content":"微格式#","routePath":"/guide/interview/html/6-微格式","lang":"","toc":[{"text":"微格式","id":"微格式","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"","content":"替换元素#","routePath":"/guide/interview/html/7-替换元素","lang":"","toc":[{"text":"替换元素","id":"替换元素","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"","content":"页面可见性#","routePath":"/guide/interview/html/8-页面可见性","lang":"","toc":[{"text":"页面可见性","id":"页面可见性","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"","content":"html 章节总结#","routePath":"/guide/interview/html/","lang":"","toc":[{"text":"html 章节总结","id":"html-章节总结","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"","content":"各章总结#","routePath":"/guide/interview/","lang":"","toc":[{"text":"各章总结","id":"各章总结","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"","content":"JS 高级#","routePath":"/guide/js/","lang":"","toc":[{"text":"JS 高级","id":"js-高级","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"","content":"OSI七层参考模型 & TCP/IP 四层/五层模型图#\n\n\n\n\n物理层#\n\n物理层是直接和物理介质打交道的。\n\n物理层的设备网卡，网线，集线器，中继器，调制解调器\n\n物理层信道：\n\n * 有线信道\n   * 明线：即高空架设暴露在外的线路\n   * 对称电缆：由多对双绞线组成的线缆\n   * 同轴电缆：由中心导体、绝缘层、外层导体、外皮组成(应用极为广泛)\n   * 光纤：由玻璃或塑料制成的纤维，利用光在纤维中以全反射原理传输\n * 无限信道：\n   * 无线电波：如WiFi\n\n在这一层通过(电，光，无线电波)，会获取他们对应的传送信号，电压，转换成010101010101但是数据还未组织，它们的单位为bit，所以在这一层主要就是传输比\n特流\n\n本层重点：比特流\n\n\n数据链路层#\n\n将比特流传入，建立逻辑连接、进行硬件地址寻址、差错校验等功能。( 由底层网络定义协议)\n\n将比特组合成字节进而组合成数据帧，用MAC地址访问介质，错误发现但不能纠正\n\nMAC地址:每个网卡的唯一标识\n\n> 有了Mac地址之后就可以知道谁是接收者，谁是发送者，并且知道了数据的内容 并且进行了分组。\n> 那么他如何进行传播数据，他是进行广播的方式进行传输,在局域网内所有的计 算机都能收到消息\n\n在Windows下可以通过在终端输入ipconfig/all来查看物理地址即MAC地址\n\n在Mac下可以通过ifconfig/all来查看物理地址\n\n有了数据帧就可以通过交换机来进行交互\n\n本层重点：数据帧\n\n\n网络层#\n\n网络层是最复杂的一层，在这一层就定义了我们的IP，20.xxx.xx.xxx\n\n该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出\n路由等控制，将信息从一个网络设备传送到另一个网络设备\n\n1.寻址:对网络层而言使用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信(类似于数据链路层的MAC地址)\n\n2.路由:在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备\n\n这一层的经常被叫数据包\n\n\n传输层#\n\n传输层主要就是定义我们的端口号，以及控流，和校验。\n\n并且拥有两个熟知的协议TCP UDP\n\n * TCP是面向连接的协议并且TCP是可靠的 因为TCP会进行三次握手四次挥手所以是可靠的，但是这样会降低速度\n\n * UDP具有较好的实时性效率比TCP高 UDP是没有三次握手四次挥手的，故此不稳定，但是速度快常用于直播\n\n这一层经常被叫数据段\n\n\n会话层#\n\n会话层，是在发送方和接收方之间进行通信时创建、维持、之后终止或断开连接的地方，与电话通话有点相似\n\n会话层定义了一种机制，允许发送方和接收方启动或停止请求会话，以及当双方发生拥塞时仍然能保持对话\n\n会话层包含了一种称为检查点(Checkpoint) 的机制来维持可靠\n会话。检查点定义了一个最接近成功通信的点，并且定义了当发生内容丢失或损坏时需要回滚以便恢复丢失或损坏数据的点，即断点下载的原理\n\n这一层经常被叫报文\n\n\n表示层#\n\n表示层主要做了几件重要的事情安全，压缩，也是程序在网络中的一个翻译官\n\n1.安全在你的数据发送之前进行加密，在接受者的表示层进行解密\n\n2.表示层还会对图片文件等格式进行解码和编码例如JPEG、ASCII图片是人类能读懂的计算机需要转换成计算机能读懂的编码。\n\n这一层经常被叫报文\n\n\n应用层#\n\n应用层就是我们使用最多的一层\n\n例如：\n\n * ajax调用接口发送http请求\n\n * 域名系统DNS\n\n * 邮件协议SMTP\n\n * webSocket长连接\n\n * SSH协议\n\n这一层经常被叫报文","routePath":"/guide/network/1-OSI七层模型","lang":"","toc":[{"text":"OSI七层参考模型 & TCP/IP 四层/五层模型图","id":"osi七层参考模型--tcpip-四层五层模型图","depth":2,"charIndex":-1},{"text":"物理层","id":"物理层","depth":3,"charIndex":32},{"text":"数据链路层","id":"数据链路层","depth":3,"charIndex":338},{"text":"网络层","id":"网络层","depth":3,"charIndex":649},{"text":"传输层","id":"传输层","depth":3,"charIndex":954},{"text":"会话层","id":"会话层","depth":3,"charIndex":1134},{"text":"表示层","id":"表示层","depth":3,"charIndex":1351},{"text":"应用层","id":"应用层","depth":3,"charIndex":1500}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"","content":"TCP三次握手#\n\n先认识名词\n\n * seq（sequence number）序列号随机生成的\n * ack（acknowledgement number）确认号ack= seq+ 1\n * ACK（acknowledgement）确定序列号有效\n * SYN（synchronous）发起新连接\n * FIN（FINSH）完成\n\n一张流程图解决\n\n\n\n我们可以通过Wireshark工具来查看，免费开源\n\n在我们发送http请求之前，有三个TCP连接即三次握手\n\n * 第一步客户端生成Seq为0发送\n * 第二步服务端让Seq+1验证，验证通过，打上ACK=1\n * 第三步客户端让Seq = 客户端Seq + 1\n\n\n\n\nTCP四次挥手#\n\n超时等待状态（TIME_WAIT）：如果最后一个过程ACK标记在某个情况下丢失，但那这样服务端就永远不会断开了，就不稳定了，所以为了弥补缺失，执行了超时等待状态\n，如果丢失，服务器会重新发送断开连接的请求，ACK会重新发送，保证TCP链接可靠\n\n\n\n我们依旧可以通过工具来查看四次挥手\n\n * 第一步客户端生成Seq=673\n * 第二步服务端让Seq+1验证，通过，打上标记ACk=674\n\n> 此时进入WAIT_2阶段，如果还有别的任务会在这个阶段进行处理，完成后才进行第三次挥手\n\n * 第三步服务端发送FIN请求，验证ACK是否正确（通过客户端Seq+1），服务端还会生成一个它对应的Seq\n * 第四步客户端有一个ACK标记，通过服务端的Seq+1验证，它自身的Seq通过客户端自身Seq+1实现，最后CLOSE结束\n\n","routePath":"/guide/network/2-TCP三次握手和四次挥手","lang":"","toc":[{"text":"TCP三次握手","id":"tcp三次握手","depth":2,"charIndex":-1},{"text":"TCP四次挥手","id":"tcp四次挥手","depth":2,"charIndex":314}],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"","content":"过程#\n\nURL的组成不多解释，可自己查询\n\n在我们有了IP后，因为IP又长又难记，所以就产生了域名，但访问域名，网络是如何找到对应的服务器呢？就是通过DNS查询\n\nDNS是把IP和域名进行了一个映射，通过域名找到对应的IP，再拿到正确的资源\n\n\nDNS查询顺序#\n\n如下，若其中一步成功则直接跳到建立链接部分：\n\n * 浏览器自身DNS\n * 操作系统DNS\n * 本地hosts文件\n * 向域名服务器发送请求\n\n\n域名解析#\n\n * 请求发起后，游览器首先会解析这个域名，首先它会查看本地硬盘的hosts文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用hosts文件里面的i\n   p地址\n * 如果在本地的hosts文件没有能够找到对应的ip地址，浏览器会发出一个DNS请求到本地DNS(域名分布系统)服务器。本地DNS服务器一般都是你的网络接入服\n   务器商提供，比如中国电信，中国移动。\n * 查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式\n   进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询\n * 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程\n\n\noptions请求：#\n\n两种情况会发出options请求\n\n * 发送跨域请求的时候\n * 自定义请求头的时候\n\n\n强缓存#\n\n\n\n\n协商缓存#\n\n","routePath":"/guide/network/3-浏览器输入URL后发生了什么","lang":"","toc":[{"text":"过程","id":"过程","depth":2,"charIndex":-1},{"text":"**DNS**查询顺序","id":"dns查询顺序","depth":3,"charIndex":-1},{"text":"域名解析","id":"域名解析","depth":3,"charIndex":209},{"text":"options请求：","id":"options请求","depth":3,"charIndex":606},{"text":"强缓存","id":"强缓存","depth":3,"charIndex":665},{"text":"协商缓存","id":"协商缓存","depth":3,"charIndex":674}],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"","content":"CDN#\n\nContent Delivery Network 内容分发网络\n\nCDN是用来优化网络资源请求的时间的\n\n\n网站上线#\n\n网站上线必须有一台服务器，这个服务器上面存放前端资源，然后搞一个域名，通过DNS将域名解析我们服务器的IP（127.xx.xx.xx）\n\n找服务器如下\n\n就近的服务器是可以缓存数据的，如果源服务器出现什么状况，可以保证数据不会崩掉，做异地灾备等措施\n\n\n\n\nCDN：工作过程#\n\n浏览器在输入url后，第一回合需要进行DNS解析，如果配置了CDN，DNS会将最终的域名解析权交给CNAME（别名指向）指向的CDN专用DNS服务器\n\n\n\n\nCDN：负载均衡#\n\n在CDN中，负载均衡又分为服务器负载均衡和服务器整体负载均衡(也有的称为服务器全局负载均衡)。\n\n服务器负载均衡是指能够在性能不同的服务器之间进行任务分配，既能保证性能差的服务器不成为系统的瓶颈，又能保证性能高的服务器的资源得到充分利用。而服务器整体负载均衡\n允许Web网络托管商、门户站点和企业根据地理位置分配内容和服务。\n\n通过使用多站点内容和服务来提高容错性和可用性，防止因本地网或区域网络中断、断电或自然灾害而导致的故障。在CDN的方案中服务器整体负载均衡将发挥重要作用，其性能高\n低将直接影响整个CDN的性能。\n\n","routePath":"/guide/network/4-CDN内容分发","lang":"","toc":[{"text":"CDN","id":"cdn","depth":2,"charIndex":-1},{"text":"网站上线","id":"网站上线","depth":3,"charIndex":59},{"text":"CDN：工作过程","id":"cdn工作过程","depth":3,"charIndex":195},{"text":"CDN：负载均衡","id":"cdn负载均衡","depth":3,"charIndex":285}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"","content":"同源策略及跨域问题#\n\n同源策略是一套浏览器安全机制，当一个源的文档和脚本，与另一个源的资源进行通信时，同源策略就会对这个通信做出不同程度的限制。\n\n简单来说，同源策略对 同源资源 放行，对 异源资源 限制\n\n> 请求的时候拥有相同的协议，域名端口，只要有一个不同就属于跨域\n\n因此限制造成的开发问题，称之为跨域（异源）问题\n\n同源和异源#\n\n\n\n例如:\n\nhttps://study.duyiedu.com/api/movie的源为https://study.duyiedu.com\n\nhttp://localhost:7001/index.html的源为http://localhost:7001\n\n两个URL地址的源完全相同，则称之为同源，否则称之为异源（跨域）\n\n\n\n跨域出现的场景#\n\n跨域可能出现在三种场景：\n\n * 网络通信\n   \n   a元素的跳转；加载css、js、图片等；AJAX等等\n\n * JS API\n   \n   window.open、window.parent、iframe.contentWindow等等\n\n * 存储\n   \n   WebStorage、IndexedDB等等\n\n对于不同的跨域场景，以及每个场景中不同的跨域方式，同源策略都有不同的限制。\n\n本文重点讨论网络通信中AJAX的跨域问题\n\n网络中的跨域#\n\n当浏览器运行页面后，会发出很多的网络请求，例如CSS、JS、图片、AJAX等等\n\n请求页面的源称之为页面源，在该页面中发出的请求称之为目标源。\n\n当页面源和目标源一致时，则为同源请求，否则为异源请求（跨域请求）\n\n\n\n浏览器如何限制异源请求？#\n\n浏览器出于多方面的考量，制定了非常繁杂的规则来限制各种跨域请求，但总体的原则非常简单：\n\n * 对标签发出的跨域请求轻微限制\n * 对AJAX发出的跨域请求严厉限制\n\n\n\n\n解决方案#\n\n第一个方案：jsonp#\n\n原理：通过script标签的src不受同源策略的限制，可以跨域请求数据\n\n缺点：只能发送get请求，不安全和不易维护，容易被非法站点恶意调用\n\n> 恶意攻击者可能利用callback=恶意函数的方式实现XSS攻击\n\n后端返回的是一个函数，但这个函数是在前端定义的，它会把值注入到这个函数的参数里面\n\n实现jsonp\n\n前端代码，放在HTML的script标签里,通过live server启动\n\n\n\n后端代码，用Node实现\n\n首先需要安装依赖\n\n\n\n代码,因为jsonp只能发送get请求，所以后端定义的时候也要定义为get请求\n\n\n\n第二个方案：前端代理#\n\n纯前端解决\n\n前端代码，用fetch发送请求\n\n\n\n后端代码，改动一点，这时直接请求/api/json会有跨域的\n\n\n\n此时如何解决跨域呢？我们需要借助构建工具完成\n\n安装vite（webpack等其他工具差不多）\n\n\n\n新建vite.config.ts文件\n\n\n\n然后我们需要启动一个vite服务，在package.json配置\n\n\n\n前端就不用live server启动了，用npm run dev启动，且请求的url改动一下\n\n\n\n此时跨域就解决了，因为vite会拦截服务，然后代理转发到3000端口\n\n> 服务端对服务端是没有跨域限制的，所以可以这样解决\n\n注意：此方法只对开发环境有效，上线还需要Nginx改动配置\n\n第三个方案：后端设置请求头#\n\n前端还是之前的，用live server启动\n\n后端代码，设置请求头\n\n\n\n第四个方案：Nginx代理#\n\n安装Nginx#\n\n第一种方式\n\n可以百度官网，点击对应版本，建议安装主线版本\n\n安装完成后，解压打开文件夹，双击nginx.exe文件启动\n\n配置文件在conf文件夹下的nginx.conf，改动即可\n\n第二种方式\n\n可以通过Microsoft Store商店，搜索wsl，找一个对应版本（我的为20.04.6），下载一个Ubuntu\n\n它其实就是一个linux的内核\n\n打开Ubuntu，输入apt-get install nginx下载\n\n打开我的电脑，下面有一个Linux，点击\n\n\n\n打开会发现我们刚刚安装的乌班图就在这，打开，nginx默认安装在etc下面\n\n找到nginx文件夹，进入sites-available目录，有一个default，打开更改\n\n更改Nginx配置#\n\n首先找到主机ip，在乌班图输入cat /etc/resolv.conf找到nameserver\n\n因为我们代理的时候不能用localhost，所以需要找到自己主机的ip\n\n打开配置后，我们只需在下面配置一个代理即可\n\n\n\n写完以后我们在乌班图启动nginx服务，输入nginx\n\n访问80端口，进入nginx，此时如果我们在浏览器控制台请求的话就没有跨域了\n\n","routePath":"/guide/network/5-跨域+四种解决方案","lang":"","toc":[{"text":"同源策略及跨域问题","id":"同源策略及跨域问题","depth":3,"charIndex":-1},{"text":"同源和异源","id":"同源和异源","depth":4,"charIndex":163},{"text":"跨域出现的场景","id":"跨域出现的场景","depth":4,"charIndex":337},{"text":"网络中的跨域","id":"网络中的跨域","depth":4,"charIndex":569},{"text":"浏览器如何限制异源请求？","id":"浏览器如何限制异源请求","depth":4,"charIndex":687},{"text":"解决方案","id":"解决方案","depth":3,"charIndex":789},{"text":"第一个方案：jsonp","id":"第一个方案jsonp","depth":4,"charIndex":796},{"text":"第二个方案：前端代理","id":"第二个方案前端代理","depth":4,"charIndex":1079},{"text":"第三个方案：后端设置请求头","id":"第三个方案后端设置请求头","depth":4,"charIndex":1406},{"text":"第四个方案：Nginx代理","id":"第四个方案nginx代理","depth":4,"charIndex":1460}],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"","content":"计算机网络#\n\n在本章你将学习到计算机的基础模型，CDN 和跨域解决方案","routePath":"/guide/network/","lang":"","toc":[{"text":"计算机网络","id":"计算机网络","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"","content":"1-梦开始的地方#\n\n\n概述#\n\n 1. nodejs 并不是JavaScript应用，也不是编程语言，因为编程语言使用的JavaScript,Nodejs 是\n    JavaScript的运行时环境。\n\n\n\n 2. Nodejs 是构建在 V8 引擎之上的，V8 引擎是由 C/C++编写的，因此我们的 JavaSCript 代码需要由 C/C++转化后再执行。\n 3. NodeJs 使用异步 I/O 和事件驱动的设计理念，可以高效地处理大量并发请求，提供了非阻塞式 I/O\n    接口和事件循环机制，使得开发人员可以编写高性能、可扩展的应用程序,异步 I/O 最终都是由libuv 事件循环库去实现的。\n 4. NodeJs 使用 npm 作为包管理工具类似于 python 的 pip，或者是 java 的 Maven，目前 npm 拥有上百万个模块。\n    www.npmjs.com/\n 5. nodejs 适合干一些 IO 密集型应用，不适合 CPU 密集型应用，nodejsIO 依靠 libuv 有很强的处理能力，而 CPU 因为\n    nodejs 单线程原因，容易造成 CPU 占用率高，如果非要做 CPU 密集型应用，可以使用 C++插件编写 或者 nodejs\n    提供的cluster。(CPU 密集型指的是图像的处理 或者音频处理需要大量数据结构 + 算法)\n\n\nNodejs 大致架构图#\n\n\n\n\nNodejs 应用场景#\n\n以下展示并不是所有东西都是 nodejs 编写而是运行环境可以配合 nodejs 或者依靠 nodejs 运行。\n\n前端#\n\n * Vue\n * Angular\n * React\n * nuxtjs\n * nextjs\n\n后端#\n\n * serverLess\n\n * web 应用：epxress、Nestjs、koa (编写后端)\n\n * RPC 服务：gRPC(跨语言通信)\n\n * 爬虫：Puppeteer(自动化 UI 测试)、cheerio\n\n * BFF 层、网关层\n\n * 及时性应用 socket.io\n\n桌面端#\n\n * electron\n\n * tauri\n\n * NWjs\n\n移动端#\n\n * weex\n\n * ionic\n\n * hybrid\n\n * React Native\n\n基建端#\n\n * webpack、vite、rollup、gulp\n\n * less、scss、postCss\n\n * babel、swc\n\n * inquire、command 、shelljs\n\n嵌入式#\n\n * Ruff js\n\n单元测试#\n\n * jest、vitest、e2e\n\nCICD#\n\n * Jenkins、docker、Husky、miniprogram-ci\n\n反向代理#\n\n * http-proxy、Any-proxy\n\n\n安装 Nodejs#\n\n进入官网https://www.nodejs.com.cn/\n\n可以点击下载其他版本，Windows 可以下载.msi文件，安装非常简单，且会自动帮你自动配置环境变量，建议直接一直 next 下去安装即可\n\n如何检查是否安装成功呢？在 Windows 打开 cmd，输入以下三个，会输出版本号\n\n","routePath":"/guide/node/1-梦开始的地方","lang":"","toc":[{"text":"1-梦开始的地方","id":"1-梦开始的地方","depth":2,"charIndex":-1},{"text":"概述","id":"概述","depth":3,"charIndex":11},{"text":"Nodejs 大致架构图","id":"nodejs-大致架构图","depth":3,"charIndex":602},{"text":"Nodejs 应用场景","id":"nodejs-应用场景","depth":3,"charIndex":620},{"text":"安装 Nodejs","id":"安装-nodejs","depth":3,"charIndex":1211}],"domain":"","frontmatter":{},"version":""},{"id":20,"title":"","content":"10-CSR SSR SEO#\n\n\n概述#\n\n在上一章的时候我们说过在 node 环境中无法操作 DOM 和 BOM，但是如果非要操作 DOM 和 BOM 也是可以的我们需要使用第三方库帮助我们jsdom\n\n\n\njsdom 是一个模拟浏览器环境的库，可以在 Node.js 中使用 DOM API\n\n简单案例#\n\n\n\n运行完该脚本会在执行目录下生成 html 文件，里面内容都是渲染好的\n\n\n\n\nCSR SSR#\n\n我们上面的操作属于SSR (Server-Side Rendering)服务端渲染请求数据和拼装都在服务端完成\n\n而我们的Vue，React等框架(这里不谈 nuxtjs,nextjs)，是在客户端完成渲染拼接的属于CSR(Client-Side\nRendering)客户端渲染\n\nCSR 和 SSR 区别\n\n 1. 页面加载方式：\n    * CSR：在 CSR 中，服务器返回一个初始的 HTML 页面，然后浏览器下载并执行 JavaScript 文件，JavaScript\n      负责动态生成并更新页面内容。这意味着初始页面加载时，内容较少，页面结构和样式可能存在一定的延迟。\n    * SSR：在 SSR 中，服务器在返回给浏览器之前，会预先在服务器端生成完整的 HTML 页面，包含了初始的页面内容。浏览器接收到的是已经渲染好的\n      HTML 页面，因此初始加载的速度较快。\n 2. 内容生成和渲染：\n    * CSR：在 CSR 中，页面的内容生成和渲染是由客户端的 JavaScript 脚本负责的。当数据变化时，JavaScript 会重新生成并更新\n      DOM，从而实现内容的动态变化。这种方式使得前端开发更加灵活，可以创建复杂的交互和动画效果。\n    * SSR：在 SSR 中，服务器在渲染页面时会执行应用程序的代码，并生成最终的 HTML\n      页面。这意味着页面的初始内容是由服务器生成的，对于一些静态或少变的内容，可以提供更好的首次加载性能。\n 3. 用户交互和体验：\n    * CSR：在 CSR 中，一旦初始页面加载完成，后续的用户交互通常是通过 AJAX 或 WebSocket 与服务器进行数据交互，然后通过\n      JavaScript 更新页面内容。这种方式可以提供更快的页面切换和响应速度，但对于搜索引擎爬虫和\n      SEO（搜索引擎优化）来说，可能需要一些额外的处理。\n    * SSR：在 SSR\n      中，由于页面的初始内容是由服务器生成的，因此用户交互可以直接在服务器上执行，然后服务器返回更新后的页面。这样可以提供更好的首次加载性能和对搜索引擎友\n      好的内容。\n\n\nSEO#\n\nSEO （Search Engine Optimization）搜索引擎优化\n\nCSR 应用对 SEO 并不是很友好\n\n> 因为在首次加载的时候获取 HTML 信息较少 搜索引擎爬虫可能无法获取完整的页面内容\n\n如下的一个网页源代码 网址：https://iviewui.com/view-ui-plus/guide/introduce\n\n\n\n而 SSR 就不一样了 由于 SSR 在服务器端预先生成完整的 HTML\n页面，搜索引擎爬虫可以直接获取到完整的页面内容。这有助于搜索引擎正确理解和评估页面的内容\n\n下面是掘金，通过nuxt.js服务端渲染 网址：https://juejin.cn/\n\n\n\n说了这么多，哪些网站适合做 CSR，哪些适合做 SSR\n\nCSR 应用：ToB 型，例如后台管理系统、大屏可视化，都可以采用 CSR 渲染，不需要很高的 SEO 支持\n\nSSR 应用：内容密集型应用 ToC 型，例如 新闻网站、博客网站、电子商务、门户网站，需要 SEO 支持","routePath":"/guide/node/10-CSR  SSR  SEO","lang":"","toc":[{"text":"10-CSR SSR SEO","id":"10-csr-ssr-seo","depth":2,"charIndex":-1},{"text":"概述","id":"概述","depth":3,"charIndex":17},{"text":"简单案例","id":"简单案例","depth":4,"charIndex":149},{"text":"CSR SSR","id":"csr-ssr","depth":3,"charIndex":197},{"text":"SEO","id":"seo","depth":3,"charIndex":1148}],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"","content":"11-Path Windows & posix#\n\n> path 模块在不同的操作系统是有差异的(windows | posix)\n\nwindows大家肯定熟悉，posix可能大家没听说过\n\nposix（Portable Operating System Interface of UNIX）\n\nposix表示可移植操作系统接口，也就是定义了一套标准\n\n遵守这套标准的操作系统有(unix、linux、macOs、windows wsl)\n\n为什么要定义这套标准？比如在 Linux 系统启动一个进程需要调用fork函数，在 Windows 启动一个进程需要调用creatprocess函数\n\n这样就有问题，比如我在 Linux 写好了代码，需要移植到 Windows 发现函数不统一，posix标准的出现就是为了解决这个问题\n\nWindows 并没有完全遵循 POSIX 标准，Windows 在设计上采用了不同于 POSIX 的路径表示方法\n\n> 在 Windows 系统中，路径使用反斜杠（\\）作为路径分隔符。这与 POSIX 系统使用的正斜杠（/）是不同的。这是 Windows\n> 系统的历史原因所致，早期的 Windows 操作系统采用了不同的设计选择。\n\n\nWindows posix 差异#\n\npath.basename() 方法返回的是给定路径中的最后一部分\n\n在 posix 处理 Windows 路径，会发现结果返回的并不对，应该返回 myfile.html\n\n\n\n如果要在posix系统处理 Windows 的路径，需要调用对应操作系统的方法，应该修改为\n\n\n\n这样就能返回 myfile.html\n\n\npath.dirname#\n\n这个 API 和basename正好互补\n\n\n\ndirname API 返回 /aaaa/bbbb/cccc 除了最后一个路径的前面路径。\n\nbasename API 返回 最后一个路径 index.html\n\n\npath.extname#\n\n这个 API 用来返回扩展名，例如/bbb/ccc/file.txt 返回就是.txt\n\n\n\n> 如果有多个 . 返回最后一个，如果没有扩展名，返回空\n\n\npath.join#\n\n这个 API 主要是用来拼接路径的\n\n\n\n> 可以支持 .. ./ ../操作符\n\n\n\n\npath.resolve#\n\n用于将相对路径解析并且返回绝对路径\n\n如果传入了多个绝对路径 它将返回最右边的绝对路径\n\n\n\n传入绝对路径 + 相对路径\n\n\n\n如果只传入相对路径\n\n\n\n\npath.parse 和 path.format#\n\npath.format 和 path.parse 正好互补\n\nparse用于解析文件路径\n\n它接受一个路径字符串作为输入，并返回一个包含路径各个组成部分的对象\n\n\n\n * root：路径的根目录，即 /\n * dir：文件所在的目录，即 /home/user/documents\n * base：文件名，即 file.txt\n * ext：文件扩展名，即 .txt\n * name：文件名去除扩展名，即 file\n\nformat 正好相反，把对象转回字符串\n\n\n\n\npath.sep#\n\n根据操作系统返回的值是不一样的\n\nWindows 返回是\\ posix 返回的是/\n\n","routePath":"/guide/node/11-Path Windows和posix","lang":"","toc":[{"text":"11-Path Windows & posix","id":"11-path-windows--posix","depth":2,"charIndex":-1},{"text":"Windows posix 差异","id":"windows-posix-差异","depth":3,"charIndex":535},{"text":"path.dirname","id":"pathdirname","depth":3,"charIndex":713},{"text":"path.extname","id":"pathextname","depth":3,"charIndex":835},{"text":"path.join","id":"pathjoin","depth":3,"charIndex":928},{"text":"path.resolve","id":"pathresolve","depth":3,"charIndex":985},{"text":"path.parse 和 path.format","id":"pathparse-和-pathformat","depth":3,"charIndex":1078},{"text":"path.sep","id":"pathsep","depth":3,"charIndex":1338}],"domain":"","frontmatter":{},"version":""},{"id":22,"title":"","content":"12-OS#\n\nNodejs os 模块可以跟操作系统进行交互\n\n\n\n\n常用的 API#\n\n序号   API             作用\n1    os.type()       它在 Linux 上返回 'Linux'，在 macOS 上返回 'Darwin'，在 Windows 上返回\n                     'Windows_NT'\n2    os.platform()   返回标识为其编译 Node.js 二进制文件的操作系统平台的字符串。 该值在编译时设置。 可能的值为\n                     'aix'、'darwin'、'freebsd'、'linux'、'openbsd'、'sunos'、以及\n                     'win32'等\n3    os.release()    返回操作系统的版本例如10.xxxx代表 win10\n4    os.homedir()    返回用户目录 例如c:\\user\\su，底层原理就是 windows 下的echo %USERPROFILE%\n                     ，posix 系统下的$HOME\n5    os.arch()       返回 cpu 的架构 可能的值为\n                     'arm'、'arm64'、'ia32'、'mips'、'mipsel'、'ppc'、'ppc64'、's390'、's\n                     390x'、以及 'x64'\n6    os.version()    返回版本，如Windows 10 Pro\n\n> windows 在 cmd 下输入echo %USERPROFILE%就会输出用户的目录\n\n\n获取 CPU 的线程以及详细信息#\n\n\n\n输出如下的信息\n\n\n\n * model: 表示 CPU 的型号信息，其中 \"Intel(R) Core(TM) i7 CPU 860 @ 2.80GHz\" 是一种具体的型号描述\n * speed: 表示 CPU 的时钟速度，以 MHz 或 GHz 为单位。在这种情况下，速度为 2926 MHz 或 2.926 GHz\n * times: 是一个包含 CPU 使用时间的对象，其中包含以下属性：\n   * user: 表示 CPU 被用户程序使用的时间（以毫秒为单位）\n   * nice: 表示 CPU 被优先级较低的用户程序使用的时间（以毫秒为单位）\n   * sys: 表示 CPU 被系统内核使用的时间（以毫秒为单位）\n   * idle: 表示 CPU 处于空闲状态的时间（以毫秒为单位）\n   * irq: 表示 CPU 被硬件中断处理程序使用的时间（以毫秒为单位）\n\n例如我的电脑是六核十二线程就会获取到 12 个线程\n\n\n\n\n获取网络信息#\n\n\n\n\n\n * address: 表示本地回环接口的 IP 地址，这里是 '127.0.0.1'\n * netmask: 表示本地回环接口的子网掩码，这里是 '255.0.0.0'\n * family: 表示地址族（address family），这里是 'IPv4'，表示 IPv4 地址\n * mac: 表示本地回环接口的 MAC 地址，这里是 '00:00:00:00:00:00'。请注意，本地回环接口通常不涉及硬件，因此 MAC\n   地址通常为全零\n * internal: 表示本地回环接口是否是内部接口，这里是 true，表示它是一个内部接口\n * cidr: 表示本地回环接口的 CIDR 表示法，即网络地址和子网掩码的组合，这里是 '127.0.0.1/8'，表示整个 127.0.0.0 网络\n\n\n案例#\n\n知道这些信息有什么用？\n\n非常经典的例子 webpack vite 大家应该都用过 他们有一个配置项可以打开浏览器 open:true 我们来简单复刻一下\n\n","routePath":"/guide/node/12-OS","lang":"","toc":[{"text":"12-OS","id":"12-os","depth":2,"charIndex":-1},{"text":"常用的 API","id":"常用的-api","depth":3,"charIndex":35},{"text":"获取 CPU 的线程以及详细信息","id":"获取-cpu-的线程以及详细信息","depth":3,"charIndex":768},{"text":"获取网络信息","id":"获取网络信息","depth":3,"charIndex":1210},{"text":"案例","id":"案例","depth":3,"charIndex":1578}],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"","content":"13-process 进程#\n\nprocess 是 Nodejs 操作当前进程和控制当前进程的 API，并且是挂载到 globalThis 下面的全局 API\n\n\nAPI 介绍#\n\nprocess.arch#\n\nprocess.arch返回操作系统 CPU 架构 跟我们之前讲的os.arch 一样\n\n值：'arm'、'arm64'、'ia32'、'mips'、'mipsel'、'ppc'、'ppc64'、's390'、's390x'、以及 'x64'\n\nprocess.argv#\n\nprocess.argv获取执行进程后面的参数，返回是一个数组\n\n后面我们讲到命令行交互工具的时候会很有用，各种 cli 脚手架也是使用这种方式接受配置参数例如webpack\n\n\n\nprocess.cwd()#\n\nprocess.cwd()返回当前的工作目录\n\n> ESM 模式下，__dirname无法使用，这个是代替__dirname使用的\n\n例如在 F:\\project\\node> 执行的脚本就返回这个目录\n\n\n\nprocess.memoryUsage#\n\nprocess.memoryUsage用于获取当前进程的内存使用情况\n\n该方法返回一个对象，其中包含了各种内存使用指标，如 rss（Resident Set\nSize，常驻集大小）、heapTotal（堆区总大小）、heapUsed（已用堆大小）和 external（外部内存使用量）等\n\n\n\nprocess.exit()#\n\n调用 process.exit() 将强制进程退出，即使仍有未完全完成的异步操作挂起\n\n下面例子 5 不会被打印出来 因为在 2 秒钟的时候就被退出了\n\n\n\n它还可以监听对应的方法\n\n\n\nprocess.kill#\n\nprocess.kill与exit类似，kill用来杀死一个进程，接受一个参数进程 id 可以通过process.pid获取\n\n\n\nprocess.env#\n\nprocess.env用于读取操作系统所有的环境变量，也可以修改和查询环境变量\n\n> 注意：修改并不会真正影响操作系统的变量，而是只在当前线程生效，线程结束便释放\n\n\n\n\n环境变量场景#\n\n区分开发环境 和 生产环境\n\n\n\ncross-env能跨平台设置和使用环境变量，不论是在 Windows 系统还是 POSIX 系统。同时，它提供了一个设置环境变量的脚本，使得您可以在脚本中以\nunix 方式设置环境变量，然后在 Windows 上也能兼容运行\n\n如下，在 package 中设置cross-env NODE_ENV=dev\n\n\n\ncross-env原理:\n\n * 如果是 windows，就调用 SET 设置环境变量\n * 如果是 posix，就调用 export 设置环境变量\n\n","routePath":"/guide/node/13-process进程","lang":"","toc":[{"text":"13-process 进程","id":"13-process-进程","depth":2,"charIndex":-1},{"text":"API 介绍","id":"api-介绍","depth":3,"charIndex":81},{"text":"process.arch","id":"processarch","depth":4,"charIndex":90},{"text":"process.argv","id":"processargv","depth":4,"charIndex":228},{"text":"process.cwd()","id":"processcwd","depth":4,"charIndex":334},{"text":"process.memoryUsage","id":"processmemoryusage","depth":4,"charIndex":454},{"text":"process.exit()","id":"processexit","depth":4,"charIndex":623},{"text":"process.kill","id":"processkill","depth":4,"charIndex":734},{"text":"process.env","id":"processenv","depth":4,"charIndex":815},{"text":"环境变量场景","id":"环境变量场景","depth":3,"charIndex":915}],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"","content":"14-child_process 子进程 核心 API#\n\n子进程是 Nodejs 核心 API，如果你会 shell 命令，他会有非常大的帮助，或者你喜欢编写前端工程化工具之类的，他也有很大的用处，以及处理 CPU\n密集型应用。\n\n\n创建子进程#\n\nNodejs 创建子进程共有7个API Sync 同步 API 不加是异步 API\n\n 1. exec 执行命令(异步执行)\n 2. execSync 执行命令(同步执行)\n 3. execFile 执行可执行文件(异步执行)\n 4. execFileSync 执行可执行文件(同步执行)\n 5. spawn 执行命令(异步执行)\n 6. spawnSync 执行命令(同步执行)\n 7. fork 创建 node 子进程\n\n\nAPI 示例#\n\nexec 方法#\n\nexec适合执行较小的 shell 命令，有字节上限：200kb\n\n\n\nexec获取 nodejs 版本号\n\n\n\noptions配置项\n\n 1. cwd 子进程的当前工作目录。\n 2. env 环境变量键值对。\n 3. encoding 默认为 'utf8'。\n 4. shell 用于执行命令的 shell。 在 UNIX 上默认为 '/bin/bash'，在 Windows 上默认为\n    process.env.ComSpec。 详见 Shell Requirements 与 Default Windows Shell。\n 5. timeout 默认为 0。\n 6. maxBuffer stdout 或 stderr 允许的最大字节数。 默认为 200*1024。 如果超过限制，则子进程会被终止。 查看警告：\n    maxBuffer and Unicode。\n 7. killSignal | 默认为 'SIGTERM'。\n 8. uid 设置该进程的用户标识。（详见 setuid(2)）\n 9. gid 设置该进程的组标识。（详见 setgid(2)）\n\nexecSync 方法#\n\n获取 node 版本号 如果要执行单次shell命令，execSync方便一些，options同上\n\n\n\n打开谷歌浏览器 使用 exec 可以打开一些软件例如 wx 谷歌 qq 音乐等 以下会打开百度并且进入无痕模式\n\n\n\nexecFile 方法#\n\nexecFile适合执行可执行文件，例如执行一个 node 脚本，或者 shell 文件\n\nwindows 可以编写 cmd 脚本，posix 可以编写 bash 脚本\n\n> 简单示例\n\n新建文件bat.cmd写入以下代码。\n\n创建一个文件夹 mkdir，进入目录，写入一个文件 test.js，最后执行。\n\n\n\n使用execFile执行这个\n\n\n\n\n\nspawn 方法(异步用的多)#\n\nspawn用于执行一些实时获取的信息，因为 spawn 返回的是流边执行边返回\n\nexec是返回一个完整的 buffer，buffer 的大小是200k，如果超出会报错，而spawn是无上限的。\n\n\n\n\n\n> exec -> execFile -> spawn\n> \n> exec 是底层通过 execFile 实现，execFile 底层通过 spawn 实现\n\nfork#\n\n场景适合大量的计算，或者容易阻塞主进程操作的一些代码，就适合开发 fork\n\n新建index.js文件，写入以下\n\n\n\n新建test.js文件，写入以下\n\n\n\n> send 发送信息 ，message 接收消息，可以相互发送接收。\n\nfork 底层使用的是 IPC 通道进行通讯的，IPC 基于 libuv 实现\n\n根据不同操作系统调用不同的 API\n\n","routePath":"/guide/node/14-child_process 子进程 核心API","lang":"","toc":[{"text":"14-child_process 子进程 核心 API","id":"14-child_process-子进程-核心-api","depth":2,"charIndex":-1},{"text":"创建子进程","id":"创建子进程","depth":3,"charIndex":117},{"text":"API 示例","id":"api-示例","depth":3,"charIndex":339},{"text":"exec 方法","id":"exec-方法","depth":4,"charIndex":348},{"text":"execSync 方法","id":"execsync-方法","depth":4,"charIndex":848},{"text":"execFile 方法","id":"execfile-方法","depth":4,"charIndex":974},{"text":"spawn 方法(异步用的多)","id":"spawn-方法异步用的多","depth":4,"charIndex":1165},{"text":"fork","id":"fork","depth":4,"charIndex":1366}],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"","content":"15-FFmpeg#\n\nFFmpeg\n是一个开源的跨平台多媒体处理工具，可以用于处理音频、视频和多媒体流。它提供了一组强大的命令行工具和库，可以进行视频转码、视频剪辑、音频提取、音视频合并、流媒体传\n输等操作。\n\n\nFFmpeg 的主要功能和特性：#\n\n 1. 格式转换：FFmpeg 可以将一个媒体文件从一种格式转换为另一种格式，支持几乎所有常见的音频和视频格式，包括\n    MP4、AVI、MKV、MOV、FLV、MP3、AAC 等。\n 2. 视频处理：FFmpeg\n    可以进行视频编码、解码、裁剪、旋转、缩放、调整帧率、添加水印等操作。你可以使用它来调整视频的分辨率、剪辑和拼接视频片段，以及对视频进行各种效果处理。\n 3. 音频处理：FFmpeg\n    可以进行音频编码、解码、剪辑、混音、音量调节等操作。你可以用它来提取音频轨道、剪辑和拼接音频片段，以及对音频进行降噪、均衡器等处理。\n 4. 流媒体传输：FFmpeg 支持将音视频流实时传输到网络上，可以用于实时流媒体服务、直播和视频会议等应用场景。\n 5. 视频处理效率高：FFmpeg 是一个高效的工具，针对处理大型视频文件和高分辨率视频进行了优化，可以在保持良好质量的同时提供较快的处理速度。\n 6. 跨平台支持：FFmpeg 可以在多个操作系统上运行，包括 Windows、MacOS、Linux 等，同时支持多种硬件加速技术，如 NVIDIA\n    CUDA 和 Intel Quick Sync Video。\n\n\n安装 FFmpeg#\n\n官方网址，选择对应的操作系统下载即可，Windows 点击第一个，找到release builds下载 zip 包\n\n\n\n下载完成配置一下环境变量就 ok 了，输入 ffmpeg -version 不报错即可\n\n\n\n\n子进程配合 ffmpeg#\n\n常用的五个功能如下，更多的可以查看官网\n\n转换格式#\n\n简单的 demo 视频转 gif ，-i 表示输入的意思\n\n\n\n\n\n视频裁剪 + 控制大小**#\n\n-ss起始时间 -to结束事件\n\n> ss 写在 -i 的前面可能会导致精度问题，因为视频还没解析就跳转到了相关位置，但是解析速度快\n\n> ss 写在 -i 后面精度没问题，但是解析速度会变慢\n\n\n\n如下，该视频只有十秒被我们截取出来了\n\n1\n\n提取视频的音频#\n\n\n\n如下，音频已经被我们提取出来了\n\n\n\n添加水印#\n\n-vf 就是video filter\n\ndrawtext添加文字、fontsize大小、xy垂直水平方向、fontcolor颜色、text水印文案\n\n> 以上内容全部小写\n\n\n\n可以发现水印已经添加上了\n\n\n\n去掉水印#\n\nw h宽高，xy 垂直水平坐标，delogo使用的过滤参数删除水印\n\n宽高就是通过上面的水印大小，我们上面大小为 30，有两个字符，所以 w 为 60，h 即 30，x 和 y 与上面一致\n\n\n\n可以发现水印已经去除了\n\n","routePath":"/guide/node/15-FFmpeg","lang":"","toc":[{"text":"15-FFmpeg","id":"15-ffmpeg","depth":2,"charIndex":-1},{"text":"FFmpeg 的主要功能和特性：","id":"ffmpeg-的主要功能和特性","depth":3,"charIndex":107},{"text":"安装 FFmpeg","id":"安装-ffmpeg","depth":3,"charIndex":649},{"text":"子进程配合 ffmpeg","id":"子进程配合-ffmpeg","depth":3,"charIndex":770},{"text":"**转换格式**","id":"转换格式","depth":4,"charIndex":-1},{"text":"视频裁剪 + 控制大小**","id":"视频裁剪--控制大小","depth":4,"charIndex":847},{"text":"**提取视频的音频**","id":"提取视频的音频","depth":4,"charIndex":-1},{"text":"**添加水印**","id":"添加水印","depth":4,"charIndex":-1},{"text":"**去掉水印**","id":"去掉水印","depth":4,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"","content":"16-events 事件触发器#\n\n\nEventEmitter#\n\nNode.js 核心 API 都是采用异步事件驱动架构\n\n简单来说就是通过有效的方法来监听事件状态的变化，并在变化的时候做出相应的动作。\n\n\n\n举个例子，你去一家餐厅吃饭，这个餐厅就是一个调度中心，然后你去点饭，可以理解注册了一个事件emit,然后我们等候服务员的喊号，喊到我们的时候就去取餐，这就是监听\n了这个事件on\n\n\n事件模型#\n\nNodejs 事件模型采用了，发布订阅设计模式\n\n\n\n当一个发布者有新消息时，就将这个消息发布到调度中心。调度中心就会将这个消息通知给所有订阅者。这就实现了发布者和订阅者之间的解耦，发布者和订阅者不再直接依赖于彼此\n，他们可以独立地扩展自己\n\n\n代码案例#\n\n新建一个文件，输入如下代码，\n\n\n\n监听消息数量默认是 10 个，下面的代码超出了 10 个但只会输出 10 个\n\n\n\n如何解除限制？调用 setMaxListeners 传入数量\n\n\n\n只想监听一次，使用once监听，即使emit派发多次也只触发一次\n\n\n\n如何取消侦听？使用off\n\n\n\n\n使用地方#\n\n**process**的底层用到了events的模块\n\n\n\n打开 nodejs 源码，搜索 setupProcessObject 这个函数\n\n\n\n 1. 它首先引入event模块\n 2. 获取process的原型对象\n 3. 将evnet的原型对象设置给了process的原型对象并且重新绑定上下文\n 4. 将process挂载到globalThis，所以我们可以全局访问这个 API\n\n> 我们给fn的原型上添加了一个属性test，我们如何读到原型上的属性呢？如下\n> \n> 通过Object.getPrototypeOf()方法就可以访问，上面的源码就用到了\n\n\n\n> 我们如何把b原型上的属性嫁接到a原型呢？通过Object.setPrototypeOf()方法\n\n","routePath":"/guide/node/16-events 事件触发器","lang":"","toc":[{"text":"16-events 事件触发器","id":"16-events-事件触发器","depth":2,"charIndex":-1},{"text":"EventEmitter","id":"eventemitter","depth":3,"charIndex":18},{"text":"事件模型","id":"事件模型","depth":3,"charIndex":196},{"text":"代码案例","id":"代码案例","depth":3,"charIndex":326},{"text":"使用地方","id":"使用地方","depth":3,"charIndex":480}],"domain":"","frontmatter":{},"version":""},{"id":27,"title":"","content":"17-util#\n\nutil 是 Node.js 内部提供的很多实用或工具类型的 API，用来方便我们快速开发，下面介绍一些常用的 API\n\n\nutil.promisify#\n\nNode.js 大部分的 API 都是遵循回调函数的模式去编写的\n\n参考上面的第 14 章子进程其中的exec，如下，查看 node 版本\n\n\n\n这就是常规的写法\n\n我们使用util.promisify，可以将回调函数改为 Promise 风格，Promisfiy 接收original(一个函数体)，如下\n\n\n\npromisify 如何实现#\n\n * 第一步：promisify 是返回一个新的函数，因此如下\n\n\n\n * 第二步：promiseify 接收一个函数，并且需要在返回的函数中接收真正的参数，然后返回一个 Promise，如下\n\n\n\n * 调用真正的函数，将参数透传给original，如果失败就 reject，成功就返回 resolve，有多个的话返回一个对象\n\n\n\n这样我们可以大致实现该工具\n\n注意：该实现是拿不到 values 的 key 的，因为 Node.js 内部没有开放kCustomPromisifyArgsSymbol这个 Symbol\n给我们\n\n因此输出的结果是{ '0': 'v18.16.0\\n', '1': '' }\n\n而正常的结果应该是{ stdout: 'v18.16.0\\n', stderr: '' }\n\n\nutil.callbackify#\n\n这个和上面的 API 正好相反，是将 Promise 类型的 API 变为回调函数\n\n如下使用\n\n\n\n剖析 callbackify#\n\n如下，考虑到多个参数情况，回调函数肯定是在最后一个，通过 pop 方法将其取出\n\n\n\n\nutil.format#\n\n函数如下\n\n\n\n其中第一个 format 参数，语法和 C 语言基本一致，如下\n\n * %s:(String)将用于转换除 BigInt、Object 和 -0 之外的所有值\n\n> BigInt 值将用 n 表示，没有用户定义的 toString 函数的对象使用具有选项 { depth: 0, colors: false,\n> compact: 3 } 的 util.inspect() 进行检查。\n\n * %d:(Numer)将用于转换除 BigInt 和 Symbol 之外的所有值\n\n * %i:(parseInt(value, 10))用于除 BigInt 和 Symbol 之外的所有值\n\n * %f:(parseFloat(value))用于除 Symbol 之外的所有值\n\n * %j:(JSON) 如果参数包含循环引用，则替换为字符串 '[Circular]'\n\n * %o:(Object)具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于具有选项 { showHidden: true,\n   showProxy: true } 的 util.inspect()。 这将显示完整的对象，包括不可枚举的属性和代理\n\n * %O: (Object). 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于没有选项的 util.inspect()。\n   这将显示完整的对象，但不包括不可枚举的属性和代理\n\n * %c: (CSS). 此说明符被忽略，将跳过任何传入的 CSS\n\n * %%: 单个百分号 ('%')。 这不消费参数\n\n下面是例子，格式化一个字符串\n\n\n\n结果如下：\n\n\n\n如果不传入格式化的参数，就会按照空格分开\n\n\n\n结果如下：\n\n","routePath":"/guide/node/17-util","lang":"","toc":[{"text":"17-util","id":"17-util","depth":2,"charIndex":-1},{"text":"util.promisify","id":"utilpromisify","depth":3,"charIndex":71},{"text":"promisify 如何实现","id":"promisify-如何实现","depth":4,"charIndex":245},{"text":"util.callbackify","id":"utilcallbackify","depth":3,"charIndex":617},{"text":"剖析 callbackify","id":"剖析-callbackify","depth":4,"charIndex":687},{"text":"util.format","id":"utilformat","depth":3,"charIndex":748}],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"","content":"18-pngquant#\n\n\n什么是 pngquant?#\n\npngquant 是一个用于压缩 PNG 图像文件的工具。它可以显著减小 PNG 文件的大小，同时保持图像质量和透明度。\n\n通过减小文件大小，可以提高网页加载速度，并节省存储空间。pngquant 提供命令行接口和库，可轻松集成到各种应用程序和脚本中。\n\n前往 pngquant 官网下载\n\n> 下载完配置一下环境变量，终端输入pngquant --version输出版本号即成功\n\n\n原理是什么#\n\npngquant 使用修改过的 Median Cut 量化算法以及其他技术来实现压缩 PNG 图像的目的。它的工作原理如下：\n\n 1. 首先，pngquant 构建一个直方图，用于统计图像中的颜色分布情况。\n 2. 接下来，它选择盒子来代表一组颜色。与传统的 Median Cut 算法不同，pngquant 选择的盒子是为了最小化盒子中颜色与中位数的差异。\n 3. pngquant 使用感知模型给予图像中噪声较大的区域较少的权重，以建立更准确的直方图。\n 4. 为了进一步改善颜色，pngquant 使用类似梯度下降的过程对直方图进行调整。它多次重复 Median Cut 算法，并在较少出现的颜色上增加权重。\n 5. 最后，为了生成最佳的调色板，pngquant 使用 Voronoi 迭代（K-means）对颜色进行校正，以确保局部最优。\n 6. 在重新映射颜色时，pngquant 只在多个相邻像素量化为相同颜色且不是边缘的区域应用误差扩散。这样可以避免在视觉质量较高且不需要抖动的区域添加噪声。\n\n通过这些步骤，pngquant 能够在保持图像质量的同时，将 PNG 图像的文件大小减小到最低限度。\n\n\nMedian Cut 量化算法#\n\n假设我们有一张 8x8 像素的彩色图像，每个像素由红色、绿色和蓝色通道组成，每个通道的值范围是 0 到 255。\n\n 1. 初始化：我们将图像中的每个像素视为一个颜色点，并将它们放入一个初始的颜色桶。\n\n 2. 选择划分桶：在初始的颜色桶中选择一个具有最大范围的颜色通道，假设我们选择红色通道。\n\n 3. 划分颜色：对于选定的红色通道，将颜色桶中的颜色按照红色通道的值进行排序，并找到中间位置的颜色值作为划分点。假设划分点的红色值为 120。\n    \n    划分前的颜色桶：\n    \n    * 颜色 1: (100, 50, 200)\n    * 颜色 2: (150, 30, 100)\n    * 颜色 3: (80, 120, 50)\n    * 颜色 4: (200, 180, 160)\n    \n    划分后的颜色桶：\n    \n    * 子桶 1:\n      \n      * 颜色 1: (100, 50, 200)\n      * 颜色 3: (80, 120, 50)\n    \n    * 子桶 2:\n      \n      * 颜色 2: (150, 30, 100)\n      * 颜色 4: (200, 180, 160)\n\n 4. 重复划分：我们继续选择颜色范围最大的通道，假设我们选择子桶 1 中的绿色通道。\n    \n    划分前的颜色桶（子桶 1）：\n    \n    * 颜色 1: (100, 50, 200)\n    * 颜色 3: (80, 120, 50)\n    \n    划分后的颜色桶（子桶 1）：\n    \n    * 子桶 1.1:\n      * 颜色 3: (80, 120, 50)\n    * 子桶 1.2:\n      * 颜色 1: (100, 50, 200)\n    \n    子桶 2 中只有两个颜色，不需要再进行划分。\n\n 5. 颜色映射：将原始图像中的每个像素颜色映射到最接近的颜色桶中的颜色。\n    \n    假设原始图像中的一个像素为 (110, 70, 180)，我们将它映射到颜色 1: (100, 50, 200)\n    \n    大概的公式为 sqrt((110-100)^2 + (70-50)^2 + (180-200)^2) ≈ 31.62\n    \n    通过 Median Cut 算法，我们将原始图像中的颜色数目从 64 个（8x8 像素）减少到 4 个颜色桶，从而实现了图像的量化\n\n\nNodejs 中调用 pngquant#\n\n同样可以使用exec命令来调用，73kb 的图片压缩完之后为 22kb\n\n\n\n--quality参数表示图片质量，值范围 0-100，值越大，图片体积越大，但图片质量越好\n\n\n\n * --speed=1：最慢的速度，产生最高质量的输出图像\n\n * --speed=10：最快的速度，但可能导致输出图像质量降低\n   \n   > 取值范围 1-10，值越小越慢，但质量高，值越大越快，但质量一般\n\n","routePath":"/guide/node/18-pngquant","lang":"","toc":[{"text":"18-pngquant","id":"18-pngquant","depth":2,"charIndex":-1},{"text":"什么是 pngquant?","id":"什么是-pngquant","depth":3,"charIndex":14},{"text":"原理是什么","id":"原理是什么","depth":3,"charIndex":223},{"text":"Median Cut 量化算法","id":"median-cut-量化算法","depth":3,"charIndex":739},{"text":"Nodejs 中调用 pngquant","id":"nodejs-中调用-pngquant","depth":3,"charIndex":1815}],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"","content":"19-fs 上#\n\n\n概述#\n\n在 Node.js 中，fs 模块是文件系统模块（File System module）的缩写，它提供了与文件系统进行交互的各种功能。通过 fs\n模块，你可以执行诸如读取文件、写入文件、更改文件权限、创建目录等操作，fs模块是Node.js 核心API之一。\n\n\nfs 多种策略#\n\n如下代码\n\n\n\n 1. fs 支持同步和异步两种模式 ，增加了Sync fs 就会采用同步的方式运行代码，会阻塞下面的代码，不加 Sync 就是异步的模式不会阻塞。\n\n 2. fs 新增了 promise 版本，只需要在引入包后面增加/promises 即可，fs 便可支持 promise 回调。\n\n 3. fs 返回的是一个 buffer 二进制数据 每两个十六进制数字表示一个字节\n\nbuffer 如下:\n\n\n\n\n常用 API 介绍#\n\n读取文件 readFile#\n\n第一个参数 读取的路径， 第二个参数是个配置项\n\n配置项第一个是 encoding，支持各种编码 utf-8 之类的\n\n配置项第二个是 flag，它的配置就很多了，如下\n\n * 'a': 打开文件进行追加。 如果文件不存在，则创建该文件。\n\n * 'ax': 类似于 'a' 但如果路径存在则失败。\n\n * 'a+': 打开文件进行读取和追加。 如果文件不存在，则创建该文件。\n\n * 'ax+': 类似于 'a+' 但如果路径存在则失败。\n\n * 'as': 以同步模式打开文件进行追加。 如果文件不存在，则创建该文件。\n\n * 'as+': 以同步模式打开文件进行读取和追加。 如果文件不存在，则创建该文件。\n\n * 'r': 打开文件进行读取。 如果文件不存在，则会发生异常。\n\n * 'r+': 打开文件进行读写。 如果文件不存在，则会发生异常。\n\n * 'rs+': 以同步模式打开文件进行读写。 指示操作系统绕过本地文件系统缓存。\n   \n   这主要用于在 NFS 挂载上打开文件，因为它允许跳过可能过时的本地缓存。 它对 I/O 性能有非常实际的影响，因此除非需要，否则不建议使用此标志。\n   \n   这不会将 fs.open() 或 fsPromises.open() 变成同步阻塞调用。 如果需要同步操作，应该使用类似 fs.openSync()\n   的东西。\n\n * 'w': 打开文件进行写入。 创建（如果它不存在）或截断（如果它存在）该文件。\n\n * 'wx': 类似于 'w' 但如果路径存在则失败。\n\n * 'w+': 打开文件进行读写。 创建（如果它不存在）或截断（如果它存在）该文件。\n\n * 'wx+': 类似于 'w+' 但如果路径存在则失败。\n\n示例代码：\n\n\n\n使用可读流读取#\n\n使用场景:适合读取大文件\n\n\n\n创建文件夹#\n\n如果开启 recursive 可以递归创建多个文件夹\n\n\n\n删除文件夹#\n\n如果开启 recursive 递归删除全部文件夹\n\n\n\n重命名文件#\n\n第一个参数原始名称 第二个参数新的名称\n\n\n\n监听文件的变化#\n\n返回监听的事件如change,和监听的内容filename\n\n\n\n\n源码解析#\n\ngithub 源码地址\n\n目录：src/unix/fs.c\n\nfs 的源码是通过 C++ 层的 FSReqCallback 这个类 对libuv 的uv_fs_t 的一个封装，其实也就是将我们 fs 的参数透传给\nlibuv 层\n\n\n\nmkdir 举例\n\n\n\n\n注意事项#\n\n\n\n为什么先走 setImmediate 呢，而不是 fs 呢?\n\nNode.js 读取文件的时候是使用 libuv 进行调度的，而 setImmediate 是由 V8 进行调度的\n\n文件读取完成后 libuv 才会将 fs 的结果 推入 V8 的队列","routePath":"/guide/node/19-fs(上)","lang":"","toc":[{"text":"19-fs 上","id":"19-fs-上","depth":2,"charIndex":-1},{"text":"概述","id":"概述","depth":3,"charIndex":10},{"text":"fs 多种策略","id":"fs-多种策略","depth":3,"charIndex":147},{"text":"常用 API 介绍","id":"常用-api-介绍","depth":3,"charIndex":367},{"text":"读取文件 `readFile`","id":"读取文件-readfile","depth":4,"charIndex":-1},{"text":"使用可读流读取","id":"使用可读流读取","depth":4,"charIndex":1149},{"text":"创建文件夹","id":"创建文件夹","depth":4,"charIndex":1175},{"text":"删除文件夹","id":"删除文件夹","depth":4,"charIndex":1213},{"text":"重命名文件","id":"重命名文件","depth":4,"charIndex":1249},{"text":"监听文件的变化","id":"监听文件的变化","depth":4,"charIndex":1280},{"text":"源码解析","id":"源码解析","depth":3,"charIndex":1324},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":1462}],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"","content":"2-npm 和 package.json#\n\n\nnpm#\n\nnpm（全称 Node Package Manager）是 Node.js\n的包管理工具，它是一个基于命令行的工具，用于帮助开发者在自己的项目中安装、升级、移除和管理依赖项。\n\n> 官网地址\n\n * 类似于 PHP 的工具：Composer。它是 PHP 的包管理器，可以用于下载、安装和管理 PHP 的依赖项，类似于 npm。\n * 类似于 Java 的工具：Maven。它是 Java 的构建工具和项目管理工具，可以自动化构建、测试和部署 Java 应用程序，类似于 npm 和\n   webpack 的功能。\n * 类似于 Python 的工具：pip。它是 Python 的包管理器，可以用于安装和管理 Python 的依赖项，类似于 npm。\n * 类似于 Rust 的工具：Cargo。它是 Rust 的包管理器和构建工具，可以用于下载、编译和管理 Rust 的依赖项，类似于 npm 和 Maven\n   的功能。\n\n\nnpm 命令#\n\n 1.  npm init：初始化一个新的 npm 项目，创建 package.json 文件。\n\n 2.  npm install：安装一个包或一组包，并且会在当前目录存放一个 node_modules。\n     \n     > npm install 安装模块的时候一般是扁平化安装的，但是有时候出现嵌套的情况是因为版本不同\n     > \n     > A 依赖 C 1.0 B 依赖 C 1.0 D 依赖 C 2.0,\n     > \n     > 此时 C 1.0 就会被放到 A B 的 node_moduels, C 2.0 会被放入 D 模块下面的 node_moduels\n\n 3.  npm install ：安装指定的包。\n     \n     > 简写 npm i，通过在包后@版本号来安装指定版本\n\n 4.  npm install --save：安装指定的包，并将其添加到 package.json 文件中的依赖列表中。(如Vue，是生产环境所需要的依赖)\n\n 5.  npm install --save-dev：安装指定的包，并将其添加到 package.json\n     文件中的开发依赖列表中。(如webpack，是开发环境所需要的依赖)\n\n 6.  npm install -g ：全局安装指定的包。\n\n 7.  npm update ：更新指定的包。\n\n 8.  npm uninstall ：卸载指定的包。\n\n 9.  npm run ：执行 package.json 文件中定义的脚本命令。\n\n 10. npm search ：搜索 npm 库中包含指定关键字的包。\n\n 11. npm info ：查看指定包的详细信息。\n\n 12. npm list：列出当前项目中安装的所有包。\n\n 13. npm outdated：列出当前项目中需要更新的包。\n\n 14. npm audit：检查当前项目中的依赖项是否存在安全漏洞。\n\n 15. npm publish：发布自己开发的包到 npm 库中。\n\n 16. npm login：登录到 npm 账户。\n\n 17. npm logout：注销当前 npm 账户。\n\n 18. npm link: 将本地模块链接到全局的 node_modules 目录下\n\n 19. **npm config list **用于列出所有的 npm 配置信息。执行该命令可以查看当前系统和用户级别的所有 npm\n     配置信息，以及当前项目的配置信息（如果在项目目录下执行该命令）\n\n 20. npm get registry 用于获取当前 npm 配置中的 registry 配置项的值。registry 配置项用于指定 npm\n     包的下载地址，如果未指定，则默认使用 npm 官方的包注册表地址\n\n 21. **npm set registry npm config set registry **命令，将 registry 配置项的值修改为指定的 地址\n\n\nPackage json#\n\n执行npm init便可以初始化一个package.json文件\n\n 1.  name：项目名称，必须是唯一的字符串，通常采用小写字母和连字符的组合。\n\n 2.  version：项目版本号，通常采用语义化版本号规范。\n     \n     > version 是三段式版本号一般是 1.0.0 大版本号、次版本号 、修订号\n     > \n     >  * 大版本号一般是有重大变化才会升级\n     >  * 次版本号一般是增加功能进行升级\n     >  * 修订号一般是修改 bug 进行升级\n\n 3.  description：项目描述。\n\n 4.  main：项目的主入口文件路径，通常是一个 JavaScript 文件。\n\n 5.  keywords：项目的关键字列表，方便他人搜索和发现该项目。\n\n 6.  author：项目作者的信息，包括姓名、邮箱、网址等。\n\n 7.  license：项目的许可证类型，可以是自定义的许可证类型或者常见的开源许可证（如 MIT、Apache 等）。\n\n 8.  dependencies：项目所依赖的包的列表，这些包会在项目运行时自动安装。\n\n 9.  devDependencies：项目开发过程中所需要的包的列表，这些包不会随项目一起发布，而是只在开发时使用。\n\n 10. peerDependencies：项目的同级依赖，即项目所需要的模块被其他模块所依赖。\n     \n     > 一般是给编写插件的人员使用的，如在devDependencies有一个自己的插件vite-plugin-chen，但它不能凭空运行，需要依赖vit\n     > e环境，这时就需要添加\"vite\":\"^2.0.0\"\n\n 11. scripts：定义了一些脚本命令，比如启动项目、运行测试等。\n\n 12. repository：项目代码仓库的信息，包括类型、网址等。\n\n 13. bugs：项目的 bug 报告地址。\n\n 14. homepage：项目的官方网站地址或者文档地址。","routePath":"/guide/node/2-npm和package.json","lang":"","toc":[{"text":"2-npm 和 package.json","id":"2-npm-和-packagejson","depth":2,"charIndex":-1},{"text":"npm","id":"npm","depth":3,"charIndex":23},{"text":"npm 命令","id":"npm-命令","depth":3,"charIndex":446},{"text":"Package json","id":"package-json","depth":3,"charIndex":1732}],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"","content":"20-fs 下#\n\n\n概述#\n\n在 Node.js 中，fs 模块是文件系统模块（File System module）的缩写，它提供了与文件系统进行交互的各种功能。通过 fs\n模块，你可以执行诸如读取文件、写入文件、更改文件权限、创建目录等操作，Node.js 核心API之一。\n\n\nAPI#\n\n写入内容#\n\n\n\n 1. 第一个参数写入的文件\n\n 2. 第二个参数写入的内容\n\n 3. 第三个是 options 可选项 encoding 编码 mode 权限 flag 如下\n    \n    * 'a': 打开文件进行追加。 如果文件不存在，则创建该文件。\n    \n    * 'ax': 类似于 'a' 但如果路径存在则失败。\n    \n    * 'a+': 打开文件进行读取和追加。 如果文件不存在，则创建该文件。\n    \n    * 'ax+': 类似于 'a+' 但如果路径存在则失败。\n    \n    * 'as': 以同步模式打开文件进行追加。 如果文件不存在，则创建该文件。\n    \n    * 'as+': 以同步模式打开文件进行读取和追加。 如果文件不存在，则创建该文件。\n    \n    * 'r': 打开文件进行读取。 如果文件不存在，则会发生异常。\n    \n    * 'r+': 打开文件进行读写。 如果文件不存在，则会发生异常。\n    \n    * 'rs+': 以同步模式打开文件进行读写。 指示操作系统绕过本地文件系统缓存。\n      \n      > 这主要用于在 NFS 挂载上打开文件，因为它允许跳过可能过时的本地缓存。 它对 I/O\n      > 性能有非常实际的影响，因此除非需要，否则不建议使用此标志。\n      > \n      > 这不会将 fs.open() 或 fsPromises.open() 变成同步阻塞调用。 如果需要同步操作，应该使用类似\n      > \n      > fs.openSync() 的东西。\n    \n    * 'w': 打开文件进行写入。 创建（如果它不存在）或截断（如果它存在）该文件。\n    \n    * 'wx': 类似于 'w' 但如果路径存在则失败。\n    \n    * 'w+': 打开文件进行读写。 创建（如果它不存在）或截断（如果它存在）该文件。\n    \n    * 'wx+': 类似于 'w+' 但如果路径存在则失败。\n\n追加内容#\n\n第一种方式 设置 flag 为 a 可以追加\n\n\n\n查看内容\n\n\n\n第二种方式\n\n\n\n使用appendFileSync也可以追加内容\n\n\n可写流#\n\n\n\n我们可以创建一个可写流 打开一个通道，可以一直写入数据，用于处理大量的数据写入，写入完成之后调用 end 关闭可写流，监听 finish 事件 写入完成\n\n\n硬链接 和 软连接#\n\n\n\n硬链接的作用和用途如下：\n\n 1. 文件共享：硬链接允许多个文件名指向同一个文件，这样可以在不同的位置使用不同的文件名引用相同的内容。这样的共享文件可以节省存储空间，并且在多个位置对文件的\n    修改会反映在所有引用文件上。\n 2. 文件备份：通过创建硬链接，可以在不复制文件的情况下创建文件的备份。如果原始文件发生更改，备份文件也会自动更新。这样可以节省磁盘空间，并确保备份文件与原始\n    文件保持同步。\n 3. 文件重命名：通过创建硬链接，可以为文件创建一个新的文件名，而无需复制或移动文件。这对于需要更改文件名但保持相同内容和属性的场景非常有用。\n\n软链接的一些特点和用途如下：\n\n 1. 软链接可以创建指向文件或目录的引用。这使得你可以在不复制或移动文件的情况下引用它们，并在不同位置使用不同的文件名访问相同的内容。\n 2. 软链接可以用于创建快捷方式或别名，使得你可以通过一个简短或易记的路径来访问复杂或深层次的目录结构。\n 3. 软链接可以用于解决文件或目录的位置变化问题。如果目标文件或目录被移动或重命名，只需更新软链接的目标路径即可，而不需要修改引用该文件或目录的其他代码。","routePath":"/guide/node/20-fs(下)","lang":"","toc":[{"text":"20-fs 下","id":"20-fs-下","depth":2,"charIndex":-1},{"text":"概述","id":"概述","depth":3,"charIndex":10},{"text":"API","id":"api","depth":3,"charIndex":142},{"text":"写入内容","id":"写入内容","depth":4,"charIndex":148},{"text":"追加内容","id":"追加内容","depth":4,"charIndex":1029},{"text":"可写流","id":"可写流","depth":3,"charIndex":1105},{"text":"硬链接 和 软连接","id":"硬链接-和-软连接","depth":3,"charIndex":1192}],"domain":"","frontmatter":{},"version":""},{"id":32,"title":"","content":"21-crypto#\n\ncrypto 模块的目的是为了提供通用的加密和哈希算法。用纯 JavaScript 代码实现这些功能不是不可能，但速度会非常慢。nodejs 用\nC/C++实现这些算法后，通过 crypto 这个模块暴露为 JavaScript 接口，这样用起来方便，运行速度也快。\n\n密码学是计算机科学中的一个重要领域，它涉及到加密、解密、哈希函数和数字签名等技术。Node.js 是一个流行的服务器端 JavaScript\n运行环境，它提供了强大的密码学模块，使开发人员能够轻松地在其应用程序中实现各种密码学功能。本文将介绍密码学的基本概念，并探讨 Node.js 中常用的密码学\nAPI。\n\n\n对称加密#\n\n对称加密是一种简单而快速的加密方式，它使用相同的密钥（称为对称密钥）来进行加密和解密。这意味着发送者和接收者在加密和解密过程中都使用相同的密钥。对称加密算法的加\n密速度很快，适合对大量数据进行加密和解密操作。然而，对称密钥的安全性是一个挑战，因为需要确保发送者和接收者都安全地共享密钥，否则有风险被未授权的人获取密钥并解密\n数据，crypto 使用对称加密如下\n\n\n\n\n非对称加密#\n\n非对称加密使用一对密钥，分别是公钥和私钥。发送者使用接收者的公钥进行加密，而接收者使用自己的私钥进行解密。公钥可以自由分享给任何人，而私钥必须保密。非对称加密算\n法提供了更高的安全性，因为即使公钥泄露，只有持有私钥的接收者才能解密数据。然而，非对称加密算法的加密速度相对较慢，不适合加密大量数据。因此，在实际应用中，通常使\n用非对称加密来交换对称密钥，然后使用对称加密算法来加密实际的数据。\n\n\n\n\n哈希函数#\n\n哈希函数具有以下特点：\n\n 1. 固定长度输出：不论输入数据的大小，哈希函数的输出长度是固定的。例如，常见的哈希函数如 MD5 和 SHA-256 生成的哈希值长度分别为 128 位和\n    256 位。\n 2. 不可逆性：哈希函数是单向的，意味着从哈希值推导出原始输入数据是非常困难的，几乎不可能。即使输入数据发生微小的变化，其哈希值也会完全不同。\n 3. 唯一性：哈希函数应该具有较低的碰撞概率，即不同的输入数据生成相同的哈希值的可能性应该非常小。这有助于确保哈希值能够唯一地标识输入数据。\n\n使用场景:\n\n 1. 我们可以避免密码明文传输 使用 md5 加密或者 sha256\n\n 2. 验证文件完整性，读取文件内容生成 md5 如果前端上传的 md5 和后端的读取文件内部的 md5 匹配说明文件是完整的\n\n","routePath":"/guide/node/21-crypto","lang":"","toc":[{"text":"21-crypto","id":"21-crypto","depth":2,"charIndex":-1},{"text":"对称加密","id":"对称加密","depth":3,"charIndex":303},{"text":"非对称加密","id":"非对称加密","depth":3,"charIndex":495},{"text":"哈希函数","id":"哈希函数","depth":3,"charIndex":703}],"domain":"","frontmatter":{},"version":""},{"id":33,"title":"","content":"22-脚手架#\n\n\n编写自己的脚手架#\n\n什么是脚手架呢？如vue-cli、Create React App、Angular CLI，这一系列帮我们创建模板的工具\n\n编写自己的脚手架是指创建一个定制化的工具，用于快速生成项目的基础结构和代码文件，以及提供一些常用的命令和功能。通过编写自己的脚手架，可以定义项目的目录结构、文件\n模板，管理项目的依赖项，生成代码片段，以及提供命令行接口等功能\n\n * 项目结构：脚手架定义了项目的目录结构，包括源代码、配置文件、静态资源等。\n\n * 文件模板：脚手架提供了一些预定义的文件模板，如 HTML 模板、样式表、配置文件等，以加快开发者创建新文件的速度。\n\n * 命令行接口：脚手架通常提供一个命令行接口，通过输入命令和参数，开发者可以执行各种任务，如创建新项目、生成代码文件、运行测试等。\n\n * 依赖管理：脚手架可以帮助开发者管理项目的依赖项，自动安装和配置所需的库和工具。\n\n * 代码生成：脚手架可以生成常见的代码结构，如组件、模块、路由等，以提高开发效率。\n\n * 配置管理：脚手架可以提供一些默认的配置选项，并允许开发者根据需要进行自定义配置\n\n\n\n\n工具介绍#\n\n我们来学习一下所需要用到的第三方库，通过npm init生成初始的 package，然后npm i下载下面的库\n\n * commander\n\n> Commander 是一个用于构建命令行工具的 npm 库。它提供了一种简单而直观的方式来创建命令行接口，并处理命令行参数和选项。使用\n> Commander，你可以轻松定义命令、子命令、选项和帮助信息。它还可以处理命令行的交互，使用户能够与你的命令行工具进行交互\n\n * inquirer\n\n> Inquirer\n> 是一个强大的命令行交互工具，用于与用户进行交互和收集信息。它提供了各种丰富的交互式提示（如输入框、选择列表、确认框等），可以帮助你构建灵活的命令行界面。通过\n> Inquirer，你可以向用户提出问题，获取用户的输入，并根据用户的回答采取相应的操作。\n\n * ora\n\n> Ora 是一个用于在命令行界面显示加载动画的 npm 库。它可以帮助你在执行耗时的任务时提供一个友好的加载状态提示。Ora\n> 提供了一系列自定义的加载动画，如旋转器、进度条等，你可以根据需要选择合适的加载动画效果，并在任务执行期间显示对应的加载状态。\n\n * download-git-repo\n\n> Download-git-repo 是一个用于下载 Git 仓库的 npm 库。它提供了一个简单的接口，可以方便地从远程 Git\n> 仓库中下载项目代码。你可以指定要下载的仓库和目标目录，并可选择指定分支或标签。Download-git-repo 支持从各种 Git 托管平台（如\n> GitHub、GitLab、Bitbucket 等）下载代码。\n\n\n编写代码#\n\nindex.js#\n\n第一行要写 #!/usr/bin/env node\n\n这是一个 特殊的注释 用于告诉操作系统用 node 解释器去执行这个文件，而不是显式地调用 node 命令\n\n\n\nutils.js#\n\n\n\npackage.json#\n\n加入如下的配置\n\n\n\n配置完成之后 需要执行npm link，用于生成软连接挂载到全局，便可以全局执行 vue-cli 这个命令\n\n\n\n然后执行命令：\n\n\n\n生成如下：","routePath":"/guide/node/22-脚手架","lang":"","toc":[{"text":"22-脚手架","id":"22-脚手架","depth":2,"charIndex":-1},{"text":"编写自己的脚手架","id":"编写自己的脚手架","depth":3,"charIndex":9},{"text":"工具介绍","id":"工具介绍","depth":3,"charIndex":502},{"text":"编写代码","id":"编写代码","depth":3,"charIndex":1208},{"text":"index.js","id":"indexjs","depth":4,"charIndex":1215},{"text":"utils.js","id":"utilsjs","depth":4,"charIndex":1310},{"text":"package.json","id":"packagejson","depth":4,"charIndex":1323}],"domain":"","frontmatter":{},"version":""},{"id":34,"title":"","content":"<%- content %>","routePath":"/guide/node/23-Markdown 转 html","lang":"","toc":[{"text":"23-Markdown 转 html","id":"23-markdown-转-html","depth":2,"charIndex":-1},{"text":"所用库","id":"所用库","depth":3,"charIndex":-1},{"text":"EJS 语法","id":"ejs-语法","depth":3,"charIndex":-1},{"text":"1. 纯脚本语言","id":"1-纯脚本语言","depth":4,"charIndex":-1},{"text":"2. 输出经过 HTML 转义的内容","id":"2-输出经过-html-转义的内容","depth":4,"charIndex":-1},{"text":"3. 输出非转义的内容(原始内容)","id":"3-输出非转义的内容原始内容","depth":4,"charIndex":-1},{"text":"4. 引入其他模版","id":"4-引入其他模版","depth":4,"charIndex":-1},{"text":"5. 条件判断","id":"5-条件判断","depth":4,"charIndex":-1},{"text":"6. 循环","id":"6-循环","depth":4,"charIndex":-1},{"text":"编写","id":"编写","depth":3,"charIndex":-1},{"text":"template.ejs","id":"templateejs","depth":4,"charIndex":-1},{"text":"marked","id":"marked","depth":4,"charIndex":-1},{"text":"browserSync","id":"browsersync","depth":4,"charIndex":-1},{"text":"index.css","id":"indexcss","depth":4,"charIndex":-1},{"text":"完整代码","id":"完整代码","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":35,"title":"","content":"24-zlib#\n\n在 Node.js 中，zlib 模块提供了对数据压缩和解压缩的功能，以便在应用程序中减少数据的传输大小和提高性能。该模块支持多种压缩算法，包括\nDeflate、Gzip 和 Raw Deflate。\n\nzlib 模块的主要作用如下：\n\n 1. 数据压缩：使用 zlib 模块可以将数据以无损压缩算法（如\n    Deflate、Gzip）进行压缩，减少数据的大小。这在网络传输和磁盘存储中特别有用，可以节省带宽和存储空间。\n 2. 数据解压缩：zlib 模块还提供了对压缩数据的解压缩功能，可以还原压缩前的原始数据。\n 3. 流压缩：zlib\n    模块支持使用流（Stream）的方式进行数据的压缩和解压缩。这种方式使得可以对大型文件或网络数据流进行逐步处理，而不需要将整个数据加载到内存中。\n 4. 压缩格式支持：zlib 模块支持多种常见的压缩格式，如 Gzip 和 Deflate。这些格式在各种应用场景中广泛使用，例如 HTTP\n    响应的内容编码、文件压缩和解压缩等。\n\n使用 zlib\n模块进行数据压缩和解压缩可以帮助优化应用程序的性能和资源利用。通过减小数据的大小，可以减少网络传输的时间和带宽消耗，同时减少磁盘上的存储空间。此外，zlib\n模块还提供了丰富的选项和方法，使得开发者可以根据具体需求进行灵活的压缩和解压缩操作。\n\n\n代码案例#\n\n压缩一个 txt 文件gzip 原大小index.txt(439kb) 压缩完index.txt.gz(4b)\n\n\n\n解压 gzip\n\n\n\n无损压缩 deflate 使用 createDeflate 方法\n\n\n\n解压 deflate\n\n\n\n\ngzip 和 deflate 区别#\n\n 1. 压缩算法：Gzip 使用的是 Deflate 压缩算法，该算法结合了 LZ77 算法和哈夫曼编码。LZ77\n    算法用于数据的重复字符串的替换和引用，而哈夫曼编码用于进一步压缩数据。\n 2. 压缩效率：Gzip\n    压缩通常具有更高的压缩率，因为它使用了哈夫曼编码来进一步压缩数据。哈夫曼编码根据字符的出现频率，将较常见的字符用较短的编码表示，从而减小数据的大小。\n 3. 压缩速度：相比于仅使用 Deflate 的方式，Gzip\n    压缩需要更多的计算和处理时间，因为它还要进行哈夫曼编码的步骤。因此，在压缩速度方面，Deflate 可能比 Gzip 更快。\n 4. 应用场景：Gzip 压缩常用于文件压缩、网络传输和 HTTP 响应的内容编码。它广泛应用于 Web\n    服务器和浏览器之间的数据传输，以减小文件大小和提高网络传输效率。\n\n\nhttp 请求压缩#\n\ndeflate 压缩前(8.2kb) -> 压缩后(236b)\n\n\n\ngizp 压缩前(8.2kb) ->压缩后(245b)\n\n","routePath":"/guide/node/24-zlib","lang":"","toc":[{"text":"24-zlib","id":"24-zlib","depth":2,"charIndex":-1},{"text":"代码案例","id":"代码案例","depth":3,"charIndex":587},{"text":"gzip 和 deflate 区别","id":"gzip-和-deflate-区别","depth":3,"charIndex":715},{"text":"http 请求压缩","id":"http-请求压缩","depth":3,"charIndex":1119}],"domain":"","frontmatter":{},"version":""},{"id":36,"title":"","content":"25-http#\n\nhttp 模块是 Node.js 中用于创建和处理 HTTP 服务器和客户端的核心模块。它使得构建基于 HTTP 协议的应用程序变得更加简单和灵活。\n\n 1. 创建 Web 服务器：你可以使用 http 模块创建一个 HTTP 服务器，用于提供 Web\n    应用程序或网站。通过监听特定的端口，服务器可以接收客户端的请求，并生成响应。你可以处理不同的路由、请求方法和参数，实现自定义的业务逻辑。\n 2. 构建 RESTful API：http 模块使得构建 RESTful API 变得简单。你可以使用 HTTP 请求方法（如\n    GET、POST、PUT、DELETE 等）和路径来定义 API 的不同端点。通过解析请求参数、验证身份和权限，以及生成相应的 JSON\n    或其他数据格式，你可以构建强大的 API 服务。\n 3. 代理服务器：http\n    模块还可以用于创建代理服务器，用于转发客户端的请求到其他服务器。代理服务器可以用于负载均衡、缓存、安全过滤或跨域请求等场景。通过在代理服务器上添加逻辑，\n    你可以对请求和响应进行修改、记录或过滤。\n 4. 文件服务器：http 模块可以用于创建一个简单的文件服务器，用于提供静态文件（如\n    HTML、CSS、JavaScript、图像等）。通过读取文件并将其作为响应发送给客户端，你可以轻松地构建一个基本的文件服务器。\n\n\n创建 http 服务器#\n\n\n\n前端中最常用的请求就是 GET 和 POST，那么 nodejs 如何区分这两个请求呢\n\n\n\n一个完整的代码\n\n\n\n\n如何调试#\n\nVSCode 有一个非常方便的插件，如下\n\n\n\n安装完成之后编写简易的代码就可以直接发送请求了，编写具体如下\n\n[POST | GET | PUT] [URL] [http 版本]\n\n[请求头]\n\n[传递的数据]\n\n\n\n在运行 http 后，在 http 文件中右键，然后点击 send request 即可发送\n\n\n\n我们在上面打印的是 a 的值，所以控制台输出了 1\n\n","routePath":"/guide/node/25-http","lang":"","toc":[{"text":"25-http","id":"25-http","depth":2,"charIndex":-1},{"text":"创建 http 服务器","id":"创建-http-服务器","depth":3,"charIndex":614},{"text":"如何调试","id":"如何调试","depth":3,"charIndex":689}],"domain":"","frontmatter":{},"version":""},{"id":37,"title":"","content":"","routePath":"/guide/node/26-反向代理","lang":"","toc":[{"text":"26-反向代理","id":"26-反向代理","depth":2,"charIndex":-1},{"text":"什么是反向代理?","id":"什么是反向代理","depth":3,"charIndex":-1},{"text":"代码实现","id":"代码实现","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":38,"title":"","content":"27-动静分离#\n\n\n什么是动静分离？#\n\n动静分离是一种在Web服务器架构中常用的优化技术，旨在提高网站的性能和可伸缩性。它基于一个简单的原则：将动态生成的内容（如动态网页、API请求）与静态资源（如H\nTML、CSS、JavaScript、图像文件）分开处理和分发。\n\n通过将动态内容和静态资源存储在不同的服务器或服务上，并使用不同的处理机制，可以提高网站的处理效率和响应速度。这种分离的好处包括：\n\n 1. 性能优化：将静态资源与动态内容分离可以提高网站的加载速度。由于静态资源往往是不变的，可以使用缓存机制将其存储在CDN（内容分发网络）或浏览器缓存中，从而\n    减少网络请求和数据传输的开销。\n 2. 负载均衡：通过将动态请求分发到不同的服务器或服务上，可以平衡服务器的负载，提高整个系统的可伸缩性和容错性。\n 3. 安全性：将动态请求与静态资源分开处理可以提高系统的安全性。静态资源通常是公开可访问的，而动态请求可能涉及敏感数据或需要特定的身份验证和授权。通过将静态资\n    源与动态内容分离，可以更好地管理访问控制和安全策略。\n\n实现动静分离的方法\n\n * 使用反向代理服务器（如Nginx、Apache）将静态请求和动态请求转发到不同的后端服务器或服务。\n * 将静态资源部署到CDN上，通过CDN分发静态资源，减轻源服务器的负载。\n * 使用专门的静态文件服务器（如Amazon S3、Google Cloud Storage）存储和提供静态资源，而将动态请求交给应用服务器处理。\n\n\n代码编写#\n\n下面是一个使用Node.js编写的示例代码，演示了如何处理动静分离的请求：\n\n\n\n> 因为每个文件所对应的mime类型都不一样，如果手写的话有很多，不过强大的nodejs社区提供了mime库，可以帮我们通过后缀直接分析出\n> 所对应的mime类型，然后我们通过强缓存让浏览器缓存静态资源\n\n\n常见的mime库#\n\n * 文本文件\n   * text/plain：纯文本文件\n   * text/html：HTML 文件\n   * text/css：CSS 样式表文件\n   * text/javascript：JavaScript 文件\n   * application/json：JSON 数据\n * 图像文件\n   * image/jpeg：JPEG 图像\n   * image/png：PNG 图像\n   * image/gif：GIF 图像\n   * image/svg+xml：SVG 图像\n * 音频文件\n   * audio/mpeg：MPEG 音频\n   * audio/wav：WAV 音频\n   * audio/midi：MIDI 音频\n * 视频文件\n   * video/mp4：MP4 视频\n   * video/mpeg：MPEG 视频\n   * video/quicktime：QuickTime 视频\n * 应用程序文件\n   * application/pdf：PDF 文件\n   * application/zip：ZIP 压缩文件\n   * application/x-www-form-urlencoded：表单提交数据\n   * multipart/form-data：多部分表单数据","routePath":"/guide/node/27-动静分离","lang":"","toc":[{"text":"27-动静分离","id":"27-动静分离","depth":2,"charIndex":-1},{"text":"什么是动静分离？","id":"什么是动静分离","depth":3,"charIndex":10},{"text":"代码编写","id":"代码编写","depth":3,"charIndex":654},{"text":"常见的mime库","id":"常见的mime库","depth":3,"charIndex":807}],"domain":"","frontmatter":{},"version":""},{"id":39,"title":"","content":"28-邮件服务#\n\n\n邮件作用#\n\n邮件服务在我们工作中邮件服务充当着一个重要的角色\n\n * 任务分配与跟踪：邮件服务可以用于分配任务、指派工作和跟踪项目进展。通过邮件，可以发送任务清单、工作说明和进度更新，确保团队成员了解其责任和任务要求，并监控\n   工作的完成情况。\n\n * 错误报告和故障排除：当程序出现错误或异常时，程序员可以通过邮件将错误报告发送给团队成员或相关方。这样可以帮助团队了解问题的性质、复现步骤和相关环境，从而更\n   好地进行故障排除和修复。邮件中可以提供详细的错误消息、堆栈跟踪和其他相关信息，以便其他团队成员能够更好地理解问题并提供解决方案。\n\n * 自动化构建和持续集成：在持续集成和自动化构建过程中，邮件服务可以用于通知团队成员构建状态、单元测试结果和代码覆盖率等信息。如果构建失败或出现警告，系统可以\n   自动发送邮件通知相关人员，以便及时采取相应措施。（企业很常用）\n\n\n代码编写#\n\n需要用到的库\n\n\n\n我们邮件的账号（密码| 授权码）不可能明文写到代码里面一般存放在yaml文件或者环境变量里面\n\n> js-yaml 解析yaml文件，如下\n\n\n\n\n\nnodemailder.createTransport 创建邮件服务这里用qq举例，QQ邮件服务文档\n\n\nPOP3/SMTP 设置方法#\n\n用户名/帐户： 你的QQ邮箱完整的地址\n\n密码： 生成的授权码\n\n电子邮件地址： 你的QQ邮箱的完整邮件地址\n\n接收邮件服务器： pop.qq.com，使用SSL，端口号995\n\n发送邮件服务器： smtp.qq.com，使用SSL，端口号465或587\n\n授权码生成如下，在上面网址的地方\n\n\n\n\n\n授权码管理可以查询授权码登录情况\n\n\n\n测试发送，还是使用之前的插件，编写一个http文件，然后右键发送，发现成功\n\n\n\n","routePath":"/guide/node/28-邮件服务","lang":"","toc":[{"text":"28-邮件服务","id":"28-邮件服务","depth":2,"charIndex":-1},{"text":"邮件作用","id":"邮件作用","depth":3,"charIndex":10},{"text":"代码编写","id":"代码编写","depth":3,"charIndex":405},{"text":"POP3/SMTP 设置方法","id":"pop3smtp-设置方法","depth":3,"charIndex":550}],"domain":"","frontmatter":{},"version":""},{"id":40,"title":"","content":"29-express#\n\n\nexpress介绍#\n\nExpress是一个流行的Node.js\nWeb应用程序框架，用于构建灵活且可扩展的Web应用程序和API。它是基于Node.js的HTTP模块而创建的，简化了处理HTTP请求、响应和中间件的过程。\n\n 1. 简洁而灵活：Express提供了简单而直观的API，使得构建Web应用程序变得简单快捷。它提供了一组灵活的路由和中间件机制，使开发人员可以根据需求定制和\n    组织应用程序的行为。\n 2. 路由和中间件：Express使用路由和中间件来处理HTTP请求和响应。开发人员可以定义路由规则，将特定的URL路径映射到相应的处理函数。同时，中间件允许\n    开发人员在请求到达路由处理函数之前或之后执行逻辑，例如身份验证、日志记录和错误处理。\n 3. 路由模块化：Express支持将路由模块化，使得应用程序可以根据不同的功能或模块进行分组。这样可以提高代码的组织性和可维护性，使得多人协作开发更加便捷。\n 4. 视图引擎支持：Express可以与各种模板引擎集成，例如EJS、Pug（以前称为Jade）、Handlebars等。这使得开发人员可以方便地生成动态的H\n    TML页面，并将数据动态渲染到模板中。\n 5. 中间件生态系统：Express有一个庞大的中间件生态系统，开发人员可以使用各种中间件来扩展和增强应用程序的功能，例如身份验证、会话管理、日志记录、静态文\n    件服务等。\n\n\n编码#\n\n * 启动一个http服务\n\n\n\n * 编写get/post接口\n\n\n\n * 接收前端的参数\n\n\n\n\n模块化#\n\n> 我们正常开发的时候肯定不会把代码写到一个模块里面，Express允许将路由处理程序拆分为多个模块，每个模块负责处理特定的路由。通过将路由处理程序拆分为模块，\n> 可以使代码逻辑更清晰，易于维护和扩展\n\n结构大部分如下\n\n\n\nsrc/user.js\n\n\n\napp.js\n\n\n\n\n中间件#\n\n中间件是一个关键概念。中间件是处理HTTP请求和响应的函数，它位于请求和最终路由处理函数之间，可以对请求和响应进行修改、执行额外的逻辑或者执行其他任务。\n\n中间件函数接收三个参数：req（请求对象）、res（响应对象）和next（下一个中间件函数）。通过调用next()方法，中间件可以将控制权传递给下一个中间件函数\n。如果中间件不调用next()方法，请求将被中止，不会继续传递给下一个中间件或路由处理函数\n\n * 实现一个日志中间件\n\n\n\nlog4js是一个用于Node.js应用程序的流行的日志记录库，它提供了灵活且可配置的日志记录功能。log4js允许你在应用程序中记录不同级别的日志消息，并可以\n将日志消息输出到多个目标，如控制台、文件、数据库等\n\nexpress\\middleware\\logger.js\n\n\n\napp.js\n\n","routePath":"/guide/node/29-express","lang":"","toc":[{"text":"29-express","id":"29-express","depth":2,"charIndex":-1},{"text":"express介绍","id":"express介绍","depth":3,"charIndex":13},{"text":"编码","id":"编码","depth":3,"charIndex":629},{"text":"模块化","id":"模块化","depth":3,"charIndex":685},{"text":"中间件","id":"中间件","depth":3,"charIndex":831}],"domain":"","frontmatter":{},"version":""},{"id":41,"title":"","content":"3-npm install 原理#\n\n\n执行 npm install 的时候发生了什么#\n\n首先安装的依赖都会存放在根目录的node_modules,默认采用扁平化的方式安装，并且排序规则.bin第一个然后@系列，再然后按照首字母排序 abcd等\n\n使用的算法是广度优先遍历，在遍历依赖树时，npm 会首先处理项目根目录下的依赖，然后逐层处理每个依赖包的依赖，直到所有依赖都被处理完毕。\n\n在处理每个依赖时，npm 会检查该依赖的版本号是否符合依赖树中其他依赖的版本要求，如果不符合，则会尝试安装适合的版本\n\n\n\n\n扁平化#\n\n扁平化理想状态如下\n\n\n\n安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块\n\n因为 A 模块下的 C 模块被安装到了第一级，这使得 B 模块能够复用处在同一级下；且名称，版本，均相同的 C 模块\n\n非理性状态如下\n\n\n\n因为 B 和 A 所要求的依赖模块不同，（B 下要求是 v2.0 的 C，A 下要求是 v1.0 的 C ）\n\n所以 B 不能像 2 中那样复用 A 下的 C v1.0 模块\n\n所以如果这种情况还是会出现模块冗余的情况，他就会给 B 继续搞一层node_modules，就是非扁平化了。\n\n\nnpm install 后续的流程#\n\n通过图片可以很清楚的了解后续的流程\n\nnpmrc 的配置可以参考下面\n\n\n\n\npackage-lock.json 的作用#\n\n很多朋友只知道这个东西可以锁定版本记录即依赖树详细信息\n\n * version 该参数指定了当前包的版本号\n * resolved 该参数指定了当前包的下载地址\n * integrity 用于验证包的完整性\n * dev 该参数指定了当前包是一个开发依赖包\n * bin 该参数指定了当前包中可执行文件的路径和名称\n * engines 该参数指定了当前包所依赖的 Node.js 版本范围\n\n知识点来了，package-lock.json 帮我们做了缓存，他会通过 name + version + integrity\n信息生成一个唯一的key，这个key能找到对应的index-v5 下的缓存记录 也就是npm cache 文件夹下的\n\n> 可以通过命令npm config list输出的 cache 来找到缓存的路径\n\n\n\n如果发现有缓存记录，就会找到tar 包的hash 值，然后将对应的二进制文件解压到node_modeules\n\n","routePath":"/guide/node/3-npm install原理","lang":"","toc":[{"text":"3-npm install 原理","id":"3-npm-install-原理","depth":2,"charIndex":-1},{"text":"执行 npm install 的时候发生了什么","id":"执行-npm-install-的时候发生了什么","depth":3,"charIndex":19},{"text":"扁平化","id":"扁平化","depth":3,"charIndex":257},{"text":"npm install 后续的流程","id":"npm-install-后续的流程","depth":3,"charIndex":535},{"text":"package-lock.json 的作用","id":"package-lockjson-的作用","depth":3,"charIndex":594}],"domain":"","frontmatter":{},"version":""},{"id":42,"title":"","content":"30-防盗链#\n\n防盗链（Hotlinking）是指在网页或其他网络资源中，通过直接链接到其他网站上的图片、视频或其他媒体文件，从而显示在自己的网页上。这种行为通常会给被链接的网\n站带来额外的带宽消耗和资源浪费，而且可能侵犯了原始网站的版权。\n\n为了防止盗链，网站管理员可以采取一些措施：\n\n 1. 通过HTTP引用检查：网站可以检查HTTP请求的来源，如果来源网址与合法的来源不匹配，就拒绝提供资源。这可以通过服务器配置文件或特定的脚本实现。\n 2. 使用Referrer检查：网站可以检查HTTP请求中的Referrer字段，该字段指示了请求资源的来源页面。如果Referrer字段不符合预期，就拒绝提\n    供资源。这种方法可以在服务器配置文件或脚本中实现。\n 3. 使用访问控制列表（ACL）：网站管理员可以配置服务器的访问控制列表，只允许特定的域名或IP地址访问资源，其他来源的请求将被拒绝。\n 4. 使用防盗链插件或脚本：一些网站平台和内容管理系统提供了专门的插件或脚本来防止盗链。这些工具可以根据需要配置，阻止来自未经授权的网站的盗链请求。\n 5. 使用水印技术：在图片或视频上添加水印可以帮助识别盗链行为，并提醒用户资源的来源。\n\n\n编码#\n\n * 第一步需要初始化静态资源目录 express.static\n\n\n\n\n\n\n\n\n增加防盗链#\n\n防盗链一般主要就是验证host 或者 referer\n\n\n\n127.0.0.1无权限\n\n\n\nlocalhost有权限\n\n","routePath":"/guide/node/30-防盗链","lang":"","toc":[{"text":"30-防盗链","id":"30-防盗链","depth":2,"charIndex":-1},{"text":"编码","id":"编码","depth":3,"charIndex":525},{"text":"增加防盗链","id":"增加防盗链","depth":3,"charIndex":571}],"domain":"","frontmatter":{},"version":""},{"id":43,"title":"","content":"31-响应头和请求头#\n\n\n响应头#\n\nHTTP响应头（HTTP response\nheaders）是在HTTP响应中发送的元数据信息，用于描述响应的特性、内容和行为。它们以键值对的形式出现，每个键值对由一个标头字段（header\nfield）和一个相应的值组成。\n\n例如以下示例\n\n\n\n\n响应头和跨域之间的关系#\n\n * cors\n\n跨域资源共享（Cross-Origin Resource Sharing，CORS）是一种机制，用于在浏览器中实现跨域请求访问资源的权限控制。当一个网页通过\nXMLHttpRequest 或 Fetch API 发起跨域请求时，浏览器会根据同源策略（Same-Origin\nPolicy）进行限制。同源策略要求请求的源（协议、域名和端口）必须与资源的源相同，否则请求会被浏览器拒绝。\n\n * 发送请求\n\n\n\n * express编写一个get接口\n\n\n\n发现是有报错的\n根据同源策略我们看到协议一样，域名一样，但是端口不一致，端口也无法一致，会有冲突，否则就是前后端不分离的项目，前后端代码放在一起，只用一个端口，不过我们是分离的\n没法这么做。\n\n\n\n这个时候就需要后端支持跨域资源请求放行\n\n\n\n增加以下响应头 允许localhost 5500 访问\n\n\n\n结果返回\n\n\n\n\n请求头#\n\n默认情况下cors仅支持客户端向服务器发送如下九个请求头\n\n> tips 没有application/json\n\n 1. Accept：指定客户端能够处理的内容类型。\n 2. Accept-Language：指定客户端偏好的自然语言。\n 3. Content-Language：指定请求或响应实体的自然语言。\n 4. Content-Type：指定请求或响应实体的媒体类型。\n 5. DNT (Do Not Track)：指示客户端不希望被跟踪。\n 6. Origin：指示请求的源（协议、域名和端口）。\n 7. User-Agent：包含发起请求的用户代理的信息。\n 8. Referer：指示当前请求的源 URL。\n 9. Content-type: application/x-www-form-urlencoded | multipart/form-data |\n    text/plain\n\n如果客户端需要支持额外的请求那么我们需要在客户端支持\n\n\n\n\n请求方法支持#\n\n我们服务端默认只支持 GET POST HEAD OPTIONS 请求\n\n例如我们遵循restFul风格，要支持PATCH 或者其他请求\n\n * 增加patch\n\n\n\n * 发送patch\n\n\n\n * 发现报错说patch不在我们的methods里面\n\n\n\n * 修改如下\n\n\n\n\n\n\n预检请求 OPTIONS#\n\n现在很多地方都在使用预检请求，如下\n\n\n\n预检请求的主要目的是确保跨域请求的安全性 它需要满足一定条件才会触发\n\n 1. 自定义请求方法：当使用非简单请求方法（Simple Request Methods）时，例如\n    PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH 等，浏览器会发送预检请求。\n 2. 自定义请求头部字段：当请求包含自定义的头部字段时，浏览器会发送预检请求。自定义头部字段是指不属于简单请求头部字段列表的字段，例如\n    Content-Type 为 application/json、Authorization 等。\n 3. 带凭证的请求：当请求需要在跨域环境下发送和接收凭证（例如包含 cookies、HTTP 认证等凭证信息）时，浏览器会发送预检请求。\n\n * 尝试发送预检请求\n\n\n\n * express编写\n\n\n\n会发现报错了\n\n\n\n阅读就知道因为 application/json 不属于cors 范畴需要手动支持\n\n\n\n\n\n输出code 200，成功\n\n\n\n\n自定义响应头#\n\n在我们做需求的时候肯定会碰到后端自定义响应头\n\n\n\n\n\n前端如何读取呢？\n\n\n\n发现是null 这是因为后端没有抛出该响应头，所以后端需要增加抛出的一个字段\n\n\n\n\n\n\nSSE技术#\n\nServer-Sent Events（SSE）是一种在客户端和服务器之间实现单向事件流的机制，允许服务器主动向客户端发送事件数据。在 SSE\n中，可以使用自定义事件（Custom Events）来发送具有特定类型的事件数据。\n\n> webSocket属于全双工通讯，也就是前端可以给后端实时发送，后端也可以给前端实时发送，SSE属于单工通讯，后端可以给前端实时发送\n\n * express 增加该响应头text/event-stream就变成了sse event 事件名称 data 发送的数据\n\n\n\n前端接受\n\n\n\n","routePath":"/guide/node/31-响应头和请求头","lang":"","toc":[{"text":"31-响应头和请求头","id":"31-响应头和请求头","depth":2,"charIndex":-1},{"text":"响应头","id":"响应头","depth":3,"charIndex":13},{"text":"响应头和跨域之间的关系","id":"响应头和跨域之间的关系","depth":3,"charIndex":144},{"text":"请求头","id":"请求头","depth":3,"charIndex":556},{"text":"请求方法支持","id":"请求方法支持","depth":3,"charIndex":995},{"text":"预检请求 OPTIONS","id":"预检请求-options","depth":3,"charIndex":1147},{"text":"自定义响应头","id":"自定义响应头","depth":3,"charIndex":1626},{"text":"SSE技术","id":"sse技术","depth":3,"charIndex":1720}],"domain":"","frontmatter":{},"version":""},{"id":44,"title":"","content":"32-数据库#\n\nMySQL是一种开源的关系型数据库管理系统（RDBMS），它是最受欢迎的数据库系统之一。MySQL广泛用于Web应用程序和其他需要可靠数据存储的应用程序中。\n\n以下是MySQL数据库的一些重要特点和概念：\n\n 1.  数据库：MySQL是一个数据库管理系统，用于创建和管理数据库。数据库是一个组织结构，用于存储和管理数据。\n 2.  表：数据库中的数据被组织成表的形式。表由行和列组成，行表示记录，列表示字段。\n 3.  SQL：MySQL使用结构化查询语言（SQL）进行数据库操作。SQL是一种用于定义、操作和查询数据库的语言。\n 4.  数据类型：MySQL支持各种数据类型，例如整数、浮点数、字符串、日期和时间等。每个列都有自己的数据类型。\n 5.  索引：MySQL允许创建索引以加快数据检索速度。索引是对表中一列或多列的值进行排序的数据结构。\n 6.  主键：主键是表中的唯一标识符。它用于确保表中的每个记录都有唯一的标识。\n 7.  外键：外键用于建立表与表之间的关联。它定义了一个表中的列与另一个表中的列之间的关系。\n 8.  触发器：触发器是一种在数据库中定义的操作，它会在特定事件发生时自动执行。例如，当向表中插入新记录时，可以触发一个触发器来执行其他操作。\n 9.  存储过程：存储过程是一组预编译的SQL语句，可以在数据库中进行重复使用。它可以接受参数并返回结果。\n 10. 备份和恢复：MySQL提供了备份和恢复数据库的工具和命令，以确保数据的安全性和可靠性。\n\n什么是关系型数据库？\n\n在关系型数据库中，数据以结构化的方式存储，其中每个表格由一组列（字段）和一组行（记录）组成。每个列定义了数据的类型和属性，而每个行则表示一个特定的数据实例。表格\n之间的关系通过使用主键和外键进行建立。主键是唯一标识表格中每个行的列，而外键是指向其他表格主键的列，用于建立表格之间的关联关系。\n\n\n安装流程#\n\n官网：www.mysql.com/\n\n\n\n滚动到下面\n\n\n\n\n\n\n\n\n\n下载后打开，默认端口3306\n\n\n\n设置密码\n\n\n\n添加mysql服务 把名字记住(MySQL83)\n\n\n\n继续往下走就行了\n\n\n\n安装完成之后检查Mysql服务是否开启 services.msc，键盘win + r弹出输入检查\n\n\n\n为什么让大家记住那个名字 MySQL83 因为就是服务的名字 出问题可以检查一下服务\n\n\n\n然后配置环境变量，找到你安装MySQL的地方，找到bin目录，复制地址\n\n\n\n添加进来即可\n\n\n\n测试Mysql，打开cmd，输入如下，然后输入密码\n\n\n\n进来即代表成功\n\n\n\n可视化工具安装\n\n打开VScode\n\n选择扩展 搜索 database 然后安装 Database Client\n\n\n\n点击左侧，然后创建连接，输入你刚刚创建的密码，点击连接\n\n\n\n左边出现连接，且头部为√代表成功，保存即可\n\n\n\n新建库，点击左侧新建，出现sql代码，记得增加数据库名称\n\n\n\n右键，点击执行sql\n\n\n\n成功\n\n\n\n我们也可以cmd自己查看，进入mysql，输入show databases;\n\n\n\n新建表，右键执行sql即可\n\n\n\n插入数据\n\n\n\n也可以点击右边的橙色，更方便输入\n\n\n\n","routePath":"/guide/node/32-数据库","lang":"","toc":[{"text":"32-数据库","id":"32-数据库","depth":2,"charIndex":-1},{"text":"安装流程","id":"安装流程","depth":3,"charIndex":812}],"domain":"","frontmatter":{},"version":""},{"id":45,"title":"","content":"33-SQL语句#\n\nSQL（Structured Query\nLanguage）是一种用于管理关系型数据库系统的语言。它是一种标准化语言，用于执行各种数据库操作，包括数据查询、插入、更新和删除等。\n\n\n数据库的操作#\n\n * 创建数据库\n\n\n\n如果进行重复的创建就会失败，不允许重复创建\n\n\n\n为了避免这个问题 可以添加if not exists\n\n\n\n\n\n如果数据库不存在就创建，存在就什么都不做，我宁愿不做，也不愿犯错。\n\n添加字符集utf-8，这样后面数据库中可以添加中文数据\n\n\n\n\n数据表#\n\n * 创建表\n\n\n\n解析如下\n\ncreate table 表名字 (\n\n 1. id字段名称 int数据类型代表数字类型 NOT NULL(不能为空) AUTO_INCREMENT(id自增) PRIMARY KEY(id为主键)\n 2. name(字段名称) varchar(100)字符串类型100字符 COMMENT(注释)\n 3. age(字段名称) int数据类型代表数字类型 COMMENT(注释)\n 4. create_time(字段名称) timestamp(时间戳) DEFAULT CURRENT_TIMESTAMP(自动填充创建时间)\n\n)\n\n\n\n * 修改表名\n\n\n\n\n\n * 增加列\n\n\n\n\n\n * 删除列\n\n\n\n\n\n * 编辑列\n\n\n\n","routePath":"/guide/node/33-SQL语句","lang":"","toc":[{"text":"33-SQL语句","id":"33-sql语句","depth":2,"charIndex":-1},{"text":"数据库的操作","id":"数据库的操作","depth":3,"charIndex":101},{"text":"数据表","id":"数据表","depth":3,"charIndex":246}],"domain":"","frontmatter":{},"version":""},{"id":46,"title":"","content":"34-查询#\n\n目前为止我们已经学到数据库的基本操作，以及库和表的基本语句，不过对于Mysql来说最常用的还是增删改查的语句\n\n\n查询#\n\n> 查询是使用频率最高的语句\n\n查询单个列#\n\n\n\n查询多个列，逗号隔开即可#\n\n\n\n\n\n查询所有列 *#\n\n\n\n\n\n列的别名 as#\n\n\n\n\n\n排序#\n\nORDER BY [字段名称] desc降序(从大到小) asc 升序(从小到大)\n\n\n\n\n\n限制查询结果#\n\nlimit [开始行] [限制条数]\n\n> 使用limit的时候是从0开始的跟数组一样\n\n\n\n\n\n条件查询#\n\n我们需要把搜索条件放在WHERE子句中 例如查询name字段所对应的值 小苏 完全匹配\n\n\n\n\n\n多个条件联合查询#\n\n比如说 我想查询 name 叫 小苏的，并且年龄是20岁以下的\n\n\n\n * and 操作符\n\n在给定多个搜索条件的时候，我们有时需要某条记录只在符合所有搜索条件的时候进行查询，这种情况我们可以使用and操作符来连接多个搜索条件\n\n\n\n\n\n * or 操作符\n\n在给定多个搜索条件的时候，我们有时需要某条记录在符合某一个搜索条件的时候就将其加入结果集中，这种情况我们可以使用OR操作符来连接多个搜索条件\n\n\n\n\n\n模糊查询#\n\n在MySQL中，\"LIKE\"操作符用于模糊匹配字符串。而百分号（%）是用作通配符，表示任意字符（包括零个字符或多个字符）的占位符。\n\n当你在使用\"LIKE\"操作符时，可以在模式（pattern）中使用百分号来匹配一个或多个字符。下面是一些使用百分号的示例：\n\n * \"苏%\"：匹配以\"满\"开头的字符串，后面可以是任意字符。\n * \"%苏\"：匹配以\"满\"结尾的字符串，前面可以是任意字符。\n * \"%苏%\"：匹配包含\"满\"的任意位置的字符串，前后可以是任意字符。\n\n\n\n","routePath":"/guide/node/34-查询","lang":"","toc":[{"text":"34-查询","id":"34-查询","depth":2,"charIndex":-1},{"text":"查询","id":"查询","depth":3,"charIndex":64},{"text":"查询单个列","id":"查询单个列","depth":4,"charIndex":85},{"text":"查询多个列，逗号隔开即可","id":"查询多个列逗号隔开即可","depth":4,"charIndex":95},{"text":"查询所有列 *","id":"查询所有列-","depth":4,"charIndex":114},{"text":"列的别名 `as`","id":"列的别名-as","depth":4,"charIndex":-1},{"text":"排序","id":"排序","depth":4,"charIndex":142},{"text":"限制查询结果","id":"限制查询结果","depth":4,"charIndex":194},{"text":"条件查询","id":"条件查询","depth":4,"charIndex":252},{"text":"多个条件联合查询","id":"多个条件联合查询","depth":4,"charIndex":308},{"text":"模糊查询","id":"模糊查询","depth":4,"charIndex":525}],"domain":"","frontmatter":{},"version":""},{"id":47,"title":"","content":"35-增删改#\n\n上节学习了查询，这节学习增删改\n\n\n新增#\n\n在这个语句中，我们明确了插入的顺序，第一个字段对应name，第二个hobby，第三个age，values里面的值是与之对应的\n\n\n\n\n\n插入null值\n\n在设计表结构的时候，我们允许 name age hobby 为null，所以我们也可以插入null值\n\n\n\n\n\n插入多条数据 逗号隔开即可\n\n\n\n\n\n\n删除#\n\n删除id为10的记录\n\n\n\n\n\n批量删除\n\n\n\n\n\n\n更改#\n\n更新的字段使用 = 赋值, where确定更新的条例\n\n\n\n","routePath":"/guide/node/35-增删改","lang":"","toc":[{"text":"35-增删改","id":"35-增删改","depth":2,"charIndex":-1},{"text":"新增","id":"新增","depth":3,"charIndex":26},{"text":"删除","id":"删除","depth":3,"charIndex":184},{"text":"更改","id":"更改","depth":3,"charIndex":216}],"domain":"","frontmatter":{},"version":""},{"id":48,"title":"","content":"36-表达式和函数#\n\n\n表达式#\n\nMySQL表达式是一种在MySQL数据库中使用的计算式或逻辑式。它们可用于查询、更新和过滤数据，以及进行条件判断和计算。\n\n 1. 算术表达式：可以执行基本的数学运算，例如加法、减法、乘法和除法。例如：SELECT col1 + col2 AS sum FROM\n    table_name;\n 2. 字符串表达式：可以对字符串进行操作，例如连接、截取和替换。例如：SELECT CONCAT(first_name, ' ', last_name) AS\n    full_name FROM table_name;\n 3. 逻辑表达式：用于执行条件判断，返回布尔值（TRUE或FALSE）。例如：SELECT * FROM table_name WHERE age > 18\n    AND gender = 'Male';\n 4. 条件表达式：用于根据条件返回不同的结果。例如：SELECT CASE WHEN age < 18 THEN 'Minor' ELSE 'Adult'\n    END AS age_group FROM table_name;\n 5. 聚合函数表达式：用于计算数据集的聚合值，例如求和、平均值、最大值和最小值。例如：SELECT AVG(salary) AS average_salary\n    FROM table_name;\n 6. 时间和日期表达式：用于处理时间和日期数据，例如提取年份、月份或计算日期差值。例如：SELECT YEAR(date_column) AS year\n    FROM table_name;\n\n例如查询的时候增加数值100\n\n\n\n\n\n如果要换一个列名可以用as\n\n\n\n\n\n\n函数#\n\nMySQL提供了大量的内置函数，用于在查询和操作数据时进行计算、转换和处理。以下是一些常用的MySQL函数分类及其示例：\n\n 1. 字符串函数：\n    * CONCAT(str1, str2, ...)：将多个字符串连接起来。\n    * SUBSTRING(str, start, length)：从字符串中提取子字符串。\n    * UPPER(str)：将字符串转换为大写。\n    * LOWER(str)：将字符串转换为小写。\n    * LENGTH(str)：返回字符串的长度。\n 2. 数值函数：\n    * ABS(x)：返回x的绝对值。\n    * ROUND(x, d)：将x四舍五入为d位小数。\n    * CEILING(x)：返回不小于x的最小整数。\n    * FLOOR(x)：返回不大于x的最大整数。\n    * RAND()：返回一个随机数。\n 3. 日期和时间函数：\n    * NOW()：返回当前日期和时间。\n    * CURDATE()：返回当前日期。\n    * CURTIME()：返回当前时间。\n    * DATE_FORMAT(date, format)：将日期格式化为指定的格式。\n    * DATEDIFF(date1, date2)：计算两个日期之间的天数差。\n 4. 条件函数：\n    * IF(condition, value_if_true, value_if_false)：根据条件返回不同的值。\n    * CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 ELSE result\n      END：根据条件返回不同的结果。\n 5. 聚合函数：\n    * COUNT(expr)：计算满足条件的行数。\n    * SUM(expr)：计算表达式的总和。\n    * AVG(expr)：计算表达式的平均值。\n    * MAX(expr)：返回表达式的最大值。\n    * MIN(expr)：返回表达式的最小值。\n\n * 返回随机数\n\n\n\n * 求和\n\n\n\n * 字符串拼接\n\n\n\n * 获取总数\n\n","routePath":"/guide/node/36-表达式和函数","lang":"","toc":[{"text":"36-表达式和函数","id":"36-表达式和函数","depth":2,"charIndex":-1},{"text":"表达式","id":"表达式","depth":3,"charIndex":12},{"text":"函数","id":"函数","depth":3,"charIndex":742}],"domain":"","frontmatter":{},"version":""},{"id":49,"title":"","content":"37-子查询和连表#\n\n\n子查询#\n\n子查询（Subquery），也被称为嵌套查询（Nested\nQuery），是指在一个查询语句中嵌套使用另一个完整的查询语句。子查询可以被视为一个查询的结果集，它可以作为外层查询的一部分，用于进一步筛选、计算或操作数据。\n\n子查询通常出现在主查询的WHERE子句、FROM子句、HAVING子句或SELECT子句中，以提供更复杂的查询逻辑。子查询可以根据主查询的结果动态生成结果集，用\n于过滤和匹配数据，或者作为函数的参数使用。\n\n子查询可以返回单个值、一列值、一行值或者一个结果集，具体取决于子查询的语法和用法。根据子查询返回的结果类型，可以将其与主查询的其他表达式进行比较、连接或使用作为\n条件进行过滤。\n\n我们之前的案例都是在一张表去查询，现实中不会把所有东西都放在一张表，会进行分表，甚至还会分库分表，读写分离等等。\n\n\n案例通过名字查询photo表#\n\nphoto表数据\n\n\n\nuser表数据\n\n\n\n关联关系为 user表的id 关联 photo表的user_id\n\n但是我们现在需要通过名字查询出photo表的数据 但是photo表没有存名字怎么弄子查询\n\n我们的思路就是通过名字查询user表的id，然后通过user表的id去查询photo的user_id就完成了\n\n\n\n\n\n\n连表#\n\nMysql的连表分为内连接，外连接，交叉连接\n\n 1. 对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的内连接。\n 2. 对于外连接的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。\n 3. 交叉连接是指在两张或多张表之间没有任何连接条件的连接。简单来说，交叉连接可以让你查询所有可能的组合。\n\n内连接#\n\n\n\n\n\n外连接#\n\n左连接#\n\n语法规则 LEFT JOIN [连接的表] ON [连接的条件]\n\n并且以第一个表作为驱动表 被驱动表如果没有值则补充null\n\n\n\n\n\n右连接#\n\n语法规则 RIGHT JOIN [连接的表] ON [连接的条件]\n\n并且以第二个表作为驱动表 被驱动表如果没有值则忽略\n\n\n\n","routePath":"/guide/node/37-子查询和连表","lang":"","toc":[{"text":"37-子查询和连表","id":"37-子查询和连表","depth":2,"charIndex":-1},{"text":"子查询","id":"子查询","depth":3,"charIndex":12},{"text":"案例通过名字查询photo表","id":"案例通过名字查询photo表","depth":3,"charIndex":382},{"text":"连表","id":"连表","depth":3,"charIndex":563},{"text":"内连接","id":"内连接","depth":4,"charIndex":768},{"text":"外连接","id":"外连接","depth":4,"charIndex":778}],"domain":"","frontmatter":{},"version":""},{"id":50,"title":"","content":"38-mysql2#\n\n在之前的篇章中，已经学习完成mysql的基本知识，那么现在开始，我们需要把mysql和express,nodejs连接起来。\n\n\n安装依赖#\n\n在终端输入如下代码，安装依赖\n\n\n\n 1. mysql2 用来连接mysql和编写sq语句\n 2. express 用来提供接口 增删改差\n 3. js-yaml 用来编写配置文件\n\n\n编写代码#\n\ndb.config.yaml\n\n\n\nindex.js\n\n\n\nindex.http，方便测试接口\n\n\n\n\n\n\n\n\n\n","routePath":"/guide/node/38-mysql2","lang":"","toc":[{"text":"38-mysql2","id":"38-mysql2","depth":2,"charIndex":-1},{"text":"安装依赖","id":"安装依赖","depth":3,"charIndex":76},{"text":"编写代码","id":"编写代码","depth":3,"charIndex":176}],"domain":"","frontmatter":{},"version":""},{"id":51,"title":"","content":"39-ORM( Knex + express )#\n\n\nKnex#\n\nKnex是一个基于JavaScript的查询生成器，它允许你使用JavaScript代码来生成和执行SQL查询语句。它提供了一种简单和直观的方式来与关系型数据库\n进行交互，而无需直接编写SQL语句。你可以使用Knex定义表结构、执行查询、插入、更新和删除数据等操作。\n\nKnex的安装和设置#\n\n> Knex支持多种数据库 如pg、sqlite3、mysql2、oracledb、tedious\n\n\n\n连接数据库\n\n\n\n\n定义表结构#\n\n\n\n\n实现增删改差#\n\n新增接口\n\n\n\n删除接口\n\n\n\n删除接口\n\n\n\n查询接口\n\n\n\n\n高级玩法#\n\n反编译为SQL语句，用SQL语句调用\n\n\n\n连表\n\n\n\n排序\n\n\n\n\n事务#\n\n你可以使用事务来确保一组数据库操作的原子性，即要么全部成功提交，要么全部回滚\n\n例如A给B转钱，需要两条语句，如果A语句成功了，B语句因为一些场景失败了，那这钱就丢了，所以事务就是为了解决这个问题，要么都成功，要么都回滚，保证金钱不会丢失。\n\n","routePath":"/guide/node/39-ORM( Knex + express )","lang":"","toc":[{"text":"39-ORM( Knex + express )","id":"39-orm-knex--express-","depth":2,"charIndex":-1},{"text":"Knex","id":"knex","depth":3,"charIndex":27},{"text":"Knex的安装和设置","id":"knex的安装和设置","depth":4,"charIndex":169},{"text":"定义表结构","id":"定义表结构","depth":3,"charIndex":245},{"text":"实现增删改差","id":"实现增删改差","depth":3,"charIndex":256},{"text":"高级玩法","id":"高级玩法","depth":3,"charIndex":298},{"text":"事务","id":"事务","depth":3,"charIndex":340}],"domain":"","frontmatter":{},"version":""},{"id":52,"title":"","content":"4-npm run 原理#\n\n\nnpm run xxx 发生了什么#\n\n按照下面的例子npm run dev举例过程中发生了什么\n\n\n\n读取package json的scripts对应的脚本命令dev:vite,vite 是个可执行脚本，他的查找规则是：\n\n * 先从当前项目的node_modules/.bin去查找可执行命令vite\n\n * 如果没找到就去全局的node_modules去找可执行命令vite\n   \n   > 全局的可以通过npm config list输出的 prefix 找到路径\n\n * 如果还没找到就去环境变量查找\n\n * 再找不到就进行报错\n\n如果成功找到会发现有三个文件\n\n\n\n> 因为 nodejs 是跨平台的所以可执行命令兼容各个平台\n\n * .sh文件是给 Linux、Unix、Macos 使用\n * .cmd给 Windows 的 cmd 使用\n * .ps1给 Windows 的 powerShell 使用\n\n\nnpm 生命周期#\n\n没想到吧 npm 执行命令也有生命周期！\n\n创建了 3 个文件index.js、post.js、prev.js，内容是console.log(文件名字)\n\n> 注意：nodejs 的 console api 是自己实现的，与浏览器的 console api 不同\n\n在package.json的scripts书写如下代码\n\n\n\n执行npm run dev命令的时候predev会自动执行 他的生命周期是在dev之前执行，然后执行dev命令，再然后执行postdev，也就是dev之后执行\n\n运用场景：例如npm run build可以在打包之后删除 dist 目录等等\n\npost 例如你编写完一个工具发布 npm，那就可以在之后写一个 cli 脚本顺便帮你推送到 git 等等\n\n> 谁用到了如上的场景\n> \n> 例如 vue-cli github.com/vuejs/vue-c…\n\n","routePath":"/guide/node/4-npm run原理","lang":"","toc":[{"text":"4-npm run 原理","id":"4-npm-run-原理","depth":2,"charIndex":-1},{"text":"npm run xxx 发生了什么","id":"npm-run-xxx-发生了什么","depth":3,"charIndex":15},{"text":"npm 生命周期","id":"npm-生命周期","depth":3,"charIndex":429}],"domain":"","frontmatter":{},"version":""},{"id":53,"title":"","content":"40-ORM( Prisma + express )#\n\n\n什么是 prisma?#\n\nPrisma 是一个现代化的数据库工具套件，用于简化和改进应用程序与数据库之间的交互。它提供了一个类型安全的查询构建器和一个强大的\nORM（对象关系映射）层，使开发人员能够以声明性的方式操作数据库。\n\nPrisma 支持多种主流数据库，包括 PostgreSQL、MySQL 和 SQLite，它通过生成标准的数据库模型来与这些数据库进行交互。使用\nPrisma，开发人员可以定义数据库模型并生成类型安全的查询构建器，这些构建器提供了一套直观的方法来创建、更新、删除和查询数据库中的数据。\n\nPrisma 的主要特点包括：\n\n 1. 类型安全的查询构建器：Prisma 使用强类型语言（如\n    TypeScript）生成查询构建器，从而提供了在编译时捕获错误和类型检查的能力。这有助于减少错误，并提供更好的开发人员体验。\n 2. 强大的 ORM 层：Prisma 提供了一个功能强大的 ORM 层，使开发人员能够以面向对象的方式操作数据库。它自动生成了数据库模型的\n    CRUD（创建、读取、更新、删除）方法，简化了与数据库的交互。\n 3. 数据库迁移：Prisma 提供了数据库迁移工具，可帮助开发人员管理数据库模式的变更。它可以自动创建和应用迁移脚本，使数据库的演进过程更加简单和可控。\n 4. 性能优化：Prisma\n    使用先进的查询引擎和数据加载技术，以提高数据库访问的性能。它支持高级查询功能，如关联查询和聚合查询，并自动优化查询以提供最佳的性能\n\n\n安装使用#\n\n 1. 安装 Prisma CLI：\n    * 使用 npm 安装：运行 npm install -g prisma。\n    * 使用 yarn 安装：运行 yarn global add prisma。\n 2. 初始化项目\n    * 使用prisma init --datasource-provider mysql\n\n此时就会创建生成基本目录\n\n\n\n 3. 连接mysql\n\n * 修改.env文件 [DATABASE_URL=\"mysql://账号:密码@主机:端口/库名\"]\n * 例子 DATABASE_URL=\"mysql://root:123456@localhost:3306/su\"\n\n\n创建表#\n\nprisma/schema.prisma\n\n> 没有高亮可以去扩展搜索prisma下载，在右下角语言关联prisma即可\n\n\n\n执行命令 创建表\n\n\n\n\n\n\n实现增删改查#\n\n\n\n测试http，仅参考\n\n\n\n\n\n\n\n\n\n\n\n> 注意删除这里：因为post表中有关联我们的user表数据即post表有外键在user表，如果只是用delete方法或者在数据库中删除都会发现不成功，所以我们\n> 需要级联删除，和它相关的都删除了才能删除它本身","routePath":"/guide/node/40-ORM( Prisma + express )","lang":"","toc":[{"text":"40-ORM( Prisma + express )","id":"40-orm-prisma--express-","depth":2,"charIndex":-1},{"text":"什么是 prisma?","id":"什么是-prisma","depth":3,"charIndex":29},{"text":"安装使用","id":"安装使用","depth":3,"charIndex":681},{"text":"创建表","id":"创建表","depth":3,"charIndex":994},{"text":"实现增删改查","id":"实现增删改查","depth":3,"charIndex":1079}],"domain":"","frontmatter":{},"version":""},{"id":54,"title":"","content":"41-项目架构( MVC + loC + 装饰器 )#\n\n到现在为止，我们学习了，express框架，编写接口，mysql数据库读写数据，knex,prisma\nORM框架，现在是时候把这些组合到一起，并且实现一个类似于Nestjs或者java的SpringBoot的架构真正的去开发我们的nodejs项目\n\n\nMVC#\n\nMVC（Model-View-Controller）是一种常用的软件架构模式，用于设计和组织应用程序的代码。它将应用程序分为三个主要组件：模型（Model）、视\n图（View）和控制器（Controller），各自负责不同的职责。\n\n 1. 模型（Model）：模型表示应用程序的数据和业务逻辑。它负责处理数据的存储、检索、验证和更新等操作。模型通常包含与数据库、文件系统或外部服务进行交互的代\n    码。\n 2. 视图（View）：视图负责将模型的数据以可视化的形式呈现给用户。它负责用户界面的展示，包括各种图形元素、页面布局和用户交互组件等。视图通常是根据模型的状\n    态来动态生成和更新的。\n 3. 控制器（Controller）：控制器充当模型和视图之间的中间人，负责协调两者之间的交互。它接收用户输入（例如按钮点击、表单提交等），并根据输入更新模型\n    的状态或调用相应的模型方法。控制器还可以根据模型的变化来更新视图的显示。\n\nMVC 的主要目标是将应用程序的逻辑、数据和界面分离，以提高代码的可维护性、可扩展性和可重用性。通过将不同的职责分配给不同的组件，MVC\n提供了一种清晰的结构，使开发人员能够更好地管理和修改应用程序的各个部分。\n\n\nIoC控制反转和DI依赖注入#\n\n控制反转（Inversion of Control，IoC）和依赖注入（Dependency\nInjection，DI）是软件开发中常用的设计模式和技术，用于解耦和管理组件之间的依赖关系。虽然它们经常一起使用，但它们是不同的概念。\n\n 1. 控制反转（IoC）是一种设计原则，它将组件的控制权从组件自身转移到外部容器。传统上，组件负责自己的创建和管理，而控制反转则将这个责任转给了一个外部的容器\n    或框架。容器负责创建组件实例并管理它们的生命周期，组件只需声明自己所需的依赖关系，并通过容器获取这些依赖。这种反转的控制权使得组件更加松耦合、可测试和可\n    维护。\n 2. 依赖注入（DI）是实现控制反转的一种具体技术。它通过将组件的依赖关系从组件内部移动到外部容器来实现松耦合。组件不再负责创建或管理它所依赖的其他组件，而是\n    通过构造函数、属性或方法参数等方式将依赖关系注入到组件中。依赖注入可以通过构造函数注入（Constructor\n    Injection）、属性注入（Property Injection）或方法注入（Method Injection）等方式实现。\n\n\n安装依赖#\n\n 1. inversify + reflect-metadata 实现依赖注入 官网\n 2. 接口编写express 官网\n 3. 连接工具 inversify-express-utils 文档\n 4. orm框架 prisma 官网\n 5. dto class-validator + class-transformer 文档\n\n\n项目架构#\n\n新建一个文件夹\n\n通过 prisma init --datasource-provider mysql 构建prisma项目 上一章讲过了\n\n目录结构\n\n * /src\n   * /user\n     * /controller.ts\n     * /service.ts\n     * /user.dto.ts\n   * /post\n     * /controller.ts\n     * /service.ts\n     * /post.dto.ts\n   * /db\n     * /index.ts\n   * /prisma\n     * /schema.prisma\n * main.ts\n * .env\n * tsconfig.json\n * package.json\n * README.md\n\n\n代码编写#\n\nmain.ts\n\n\n\nsrc/user/controller.ts\n\n\n\nsrc/user/service.ts\n\n\n\nsrc/user/user.dto.ts\n\n\n\nsrc/db/index.ts\n\n\n\ntsconig.json\n\n支持装饰器和反射 打开一下 严格模式关闭\n\n","routePath":"/guide/node/41-项目架构( MVC + loC + 装饰器 )","lang":"","toc":[{"text":"41-项目架构( MVC + loC + 装饰器 )","id":"41-项目架构-mvc--loc--装饰器-","depth":2,"charIndex":-1},{"text":"MVC","id":"mvc","depth":3,"charIndex":155},{"text":"IoC控制反转和DI依赖注入","id":"ioc控制反转和di依赖注入","depth":3,"charIndex":694},{"text":"安装依赖","id":"安装依赖","depth":3,"charIndex":1210},{"text":"项目架构","id":"项目架构","depth":3,"charIndex":1384},{"text":"代码编写","id":"代码编写","depth":3,"charIndex":1748}],"domain":"","frontmatter":{},"version":""},{"id":55,"title":"","content":"42-项目架构( JWT鉴权 )#\n\n\n什么是jwt?#\n\nJWT（JSON Web Token）是一种开放的标准（RFC\n7519），用于在网络应用间传递信息的一种方式。它是一种基于JSON的安全令牌，用于在客户端和服务器之间传输信息。 jwt.io/\n\nJWT由三部分组成，它们通过点（.）进行分隔：\n\n 1. Header（头部）：包含了令牌的类型和使用的加密算法等信息。通常采用Base64编码表示。\n 2. Payload（负载）：包含了身份验证和授权等信息，如用户ID、角色、权限等。也可以自定义其他相关信息。同样采用Base64编码表示。\n 3. Signature（签名）：使用指定的密钥对头部和负载进行签名，以确保令牌的完整性和真实性。\n\nJWT的工作流程如下：\n\n 1. 用户通过提供有效的凭证（例如用户名和密码）进行身份验证。\n 2. 服务器验证凭证，并生成一个JWT作为响应。JWT包含了用户的身份信息和其他必要的数据。\n 3. 服务器将JWT发送给客户端。\n 4. 客户端在后续的请求中，将JWT放入请求的头部或其他适当的位置。\n 5. 服务器在接收到请求时，验证JWT的签名以确保其完整性和真实性。如果验证通过，服务器使用JWT中的信息进行授权和身份验证。\n\n\n用到的依赖#\n\n 1. passport passport是一个流行的用于身份验证和授权的Node.js库\n 2. passport-jwt Passport-JWT是Passport库的一个插件，用于支持使用JSON Web Token (JWT)\n    进行身份验证和授权\n 3. jsonwebtoken 生成token的库\n\n\n代码编写#\n\n沿用上一章的代码 在src下增加jwt目录\n\nsrc/jwt/index.ts\n\n\n\nmain.ts\n\n\n\nsrc/user/controller.ts\n\n\n\nsrc/user/services.ts\n\n\n\njwt接口验证，哪个接口需要token验证就往哪儿加就可以了，http可自行编写\n\n","routePath":"/guide/node/42-项目架构( JWT鉴权 )","lang":"","toc":[{"text":"42-项目架构( JWT鉴权 )","id":"42-项目架构-jwt鉴权-","depth":2,"charIndex":-1},{"text":"什么是jwt?","id":"什么是jwt","depth":3,"charIndex":19},{"text":"用到的依赖","id":"用到的依赖","depth":3,"charIndex":544},{"text":"代码编写","id":"代码编写","depth":3,"charIndex":713}],"domain":"","frontmatter":{},"version":""},{"id":56,"title":"","content":"43-Redis( 介绍与安装 )#\n\n\n\nRedis（Remote Dictionary\nServer）是一个开源的内存数据结构存储系统，它提供了一个高效的键值存储解决方案，并支持多种数据结构，如字符串（Strings）、哈希（Hashes）、列表（\nLists）、集合（Sets）和有序集合（Sorted Sets）等。它被广泛应用于缓存、消息队列、实时统计等场景。\n\n以下是一些关键特性和用途介绍：\n\n 1. 内存存储：Redis主要将数据存储在内存中，因此具有快速的读写性能。它可以持久化数据到磁盘，以便在重新启动后恢复数据。\n 2. 多种数据结构：Redis不仅仅是一个简单的键值存储，它支持多种数据结构，如字符串、哈希、列表、集合和有序集合。这些数据结构使得Redis能够更灵活地存储\n    和操作数据。\n 3. 发布/订阅：Redis支持发布/订阅模式，允许多个客户端订阅一个或多个频道，以接收实时发布的消息。这使得Redis可以用作实时消息系统。\n 4. 事务支持：Redis支持事务，可以将多个命令打包成一个原子操作执行，确保这些命令要么全部执行成功，要么全部失败。\n 5. 持久化：Redis提供了两种持久化数据的方式：RDB（Redis Database）和AOF（Append Only\n    File）。RDB是将数据以快照形式保存到磁盘，而AOF是将每个写操作追加到文件中。这些机制可以确保数据在意外宕机或重启后的持久性。\n 6. 高可用性：Redis支持主从复制和Sentinel哨兵机制。通过主从复制，可以创建多个Redis实例的副本，以提高读取性能和容错能力。Sentinel是\n    一个用于监控和自动故障转移的系统，它可以在主节点宕机时自动将从节点提升为主节点。\n 7. 缓存：由于Redis具有快速的读写性能和灵活的数据结构，它被广泛用作缓存层。它可以将常用的数据存储在内存中，以加快数据访问速度，减轻后端数据库的负载。\n 8. 实时统计：Redis的计数器和有序集合等数据结构使其非常适合实时统计场景。它可以存储和更新计数器，并对有序集合进行排名和范围查询，用于统计和排行榜功能\n\n\nredis安装#\n\nwindows安装#\n\n 1. 安装包形式\n\n * 可以找人要安装包，建议b站搜索小满zs加vx群要，把解压后的路径添加到环境变量\n\n\n\n * 添加到windows服务(cmd管理员模式进入到该文件夹下)\n\n\n\n * 可以win+r输入services.msc，找到Redis查看是否启动，并设置为自动\n\n\n\n 2. wsl安装\n    \n    * 官方文档\n    \n    * cmd管理员模式 执行 wsl --update 升级wsl版本 wsl --set-default-version 2 设置wsl版本2\n    \n    * 搜索栏搜索功能，打开如下的虚拟机平台\n    \n    * \n    \n    * 打开Microsoft Store 搜索 wsl 安装一个乌班图\n    \n    * \n    \n    * 接着跟着官网执行以下命令即可\n    \n    * \n\nMac,Linux 安装#\n\nMac：brew install redis 启动redis redis-server 连接redis redis-cli\n\nLinux：wget https://download.redis.io/redis-stable.tar.gz\n\n * 编译源文件\n   \n   \n\n * 启动redis\n   \n   \n\n> Redis可视化也可通过之前的连接mysql的Database Client工具来连接Redis","routePath":"/guide/node/43-Redis( 介绍与安装 )","lang":"","toc":[{"text":"43-Redis( 介绍与安装 )","id":"43-redis-介绍与安装-","depth":2,"charIndex":-1},{"text":"redis安装","id":"redis安装","depth":3,"charIndex":915},{"text":"windows安装","id":"windows安装","depth":4,"charIndex":925},{"text":"Mac,Linux 安装","id":"maclinux-安装","depth":4,"charIndex":1324}],"domain":"","frontmatter":{},"version":""},{"id":57,"title":"","content":"44-Redis( 基本使用 )#\n\n上一章配置完环境变量后在cmd输入redis-cli即可运行下面命令，可以通过工具查看是否运行成功操作\n\n\n字符串的操作#\n\n\n\n * key：要设置的键名。\n\n * value：要设置的值。\n\n * NX：可选参数，表示只在键不存在时才设置值。\n\n * XX：可选参数，表示只在键已经存在时才设置值。\n\n * EX seconds：可选参数，将键的过期时间设置为指定的秒数。\n\n * PX milliseconds：可选参数，将键的过期时间设置为指定的毫秒数。\n\n * GET：可选参数，返回键的旧值。\n\n 1. 设置键名为 \"name\" 的值为 \"chenchen\"：\n\n\n\n 2. 设置键名为 \"counter\" 的值为 10，并设置过期时间为 60 秒：\n\n\n\n 3. 只在键名为 \"status\" 不存在时，设置其值为 \"active\"：\n\n\n\n 4. 只在键名为 \"score\" 已经存在时，将其值增加 5：\n\n\n\n 5. 设置键名为 \"message\" 的值为 \"Hello\"，并返回旧的值：\n\n\n\n 6. 删除键名为 \"name\" 的键：\n\n\n\n 7. 批量删除多个键名：\n\n\n\n 8. 删除不存在的键名，不会报错，返回删除的键数量为 0：\n\n\n\n\n集合的操作#\n\n集合（Set）是一种无序且不重复的数据结构，用于存储一组独立的元素。集合中的元素之间没有明确的顺序关系，每个元素在集合中只能出现一次。\n\n 1. 添加成员到集合：\n    \n    \n\n 2. 获取集合中的所有成员：\n    \n    \n    \n    输出结果：\n    \n    \n\n 3. 检查成员是否存在于集合中：\n    \n    \n    \n    输出结果：\n    \n    \n\n 4. 从集合中移除成员：\n    \n    \n    \n    输出结果：\n    \n    \n\n 5. 获取集合中的成员数量：\n    \n    \n    \n    输出结果：\n    \n    \n\n 6. 获取随机成员：\n    \n    \n    \n    输出结果：\n    \n    \n\n 7. 求多个集合的并集：\n    \n    \n    \n    输出结果：\n    \n    \n\n 8. 求多个集合的交集：\n    \n    \n    \n    输出结果：\n    \n    \n\n 9. 求多个集合的差集：\n    \n    \n    \n    输出结果：\n    \n    \n\n\n哈希表操作#\n\n哈希表（Hash）是一种数据结构，也称为字典、关联数组或映射，用于存储键值对集合。在哈希表中，键和值都是存储的数据项，并通过哈希函数将键映射到特定的存储位置，从\n而实现快速的数据访问和查找。\n\n 1.  设置哈希表中的字段值：\n     \n     \n\n 2.  获取哈希表中的字段值：\n     \n     \n     \n     输出结果：\n     \n     \n\n 3.  一次设置多个字段的值：\n     \n     \n\n 4.  获取多个字段的值：\n     \n     \n     \n     输出结果：\n     \n     \n\n 5.  获取哈希表中所有字段和值：\n     \n     \n     \n     输出结果：\n     \n     \n\n 6.  删除哈希表中的字段：\n     \n     \n     \n     输出结果：\n     \n     \n\n 7.  检查哈希表中是否存在指定字段：\n     \n     \n     \n     输出结果：\n     \n     \n\n 8.  获取哈希表中所有的字段：\n     \n     \n     \n     输出结果：\n     \n     \n\n 9.  获取哈希表中所有的值：\n     \n     \n     \n     输出结果：\n     \n     \n\n 10. 获取哈希表中字段的数量：\n     \n     \n     \n     输出结果：\n     \n     \n\n\n列表的操作#\n\n列表（List）是一种有序、可变且可重复的数据结构。在许多编程语言和数据存储系统中，列表是一种常见的数据结构类型，用于存储一组元素\n\n 1. 添加元素：\n\n\n\n>  * LPUSH key element1 element2\n>    ...：将一个或多个元素从列表的左侧插入，即将元素依次插入列表的头部。如果列表不存在，则在执行操作前会自动创建一个新的列表。\n>  * RPUSH key element1 element2\n>    ...：将一个或多个元素从列表的右侧插入，即将元素依次插入列表的尾部。如果列表不存在，则在执行操作前会自动创建一个新的列表。\n\n 1. 获取元素：\n\n\n\n 1. 修改元素：\n\n\n\n 1. 删除元素：\n\n\n\n 1. 获取列表长度：\n\n","routePath":"/guide/node/44-Redis( 基本使用 )","lang":"","toc":[{"text":"44-Redis( 基本使用 )","id":"44-redis-基本使用-","depth":2,"charIndex":-1},{"text":"字符串的操作","id":"字符串的操作","depth":3,"charIndex":72},{"text":"集合的操作","id":"集合的操作","depth":3,"charIndex":551},{"text":"哈希表操作","id":"哈希表操作","depth":3,"charIndex":1059},{"text":"列表的操作","id":"列表的操作","depth":3,"charIndex":1702}],"domain":"","frontmatter":{},"version":""},{"id":58,"title":"","content":"45-Redis( 发布订阅 + 事务 )#\n\n\n发布订阅#\n\n发布-订阅是一种消息传递模式，其中消息发布者（发布者）将消息发送到频道（channel），而订阅者（订阅者）可以订阅一个或多个频道以接收消息。这种模式允许消息的\n解耦，发布者和订阅者之间可以独立操作，不需要直接交互。\n\n在Redis中，发布-订阅模式通过以下命令进行操作：\n\n 1. PUBLISH命令：用于将消息发布到指定的频道。语法为：PUBLISH channel message。例如，PUBLISH news \"Hello,\n    world!\" 将消息\"Hello, world!\"发布到名为\"news\"的频道。\n 2. SUBSCRIBE命令：用于订阅一个或多个频道。语法为：SUBSCRIBE channel [channel ...]。例如，SUBSCRIBE\n    news sports 订阅了名为\"news\"和\"sports\"的频道。\n 3. UNSUBSCRIBE命令：用于取消订阅一个或多个频道。语法为：UNSUBSCRIBE [channel [channel\n    ...]]。例如，UNSUBSCRIBE news 取消订阅名为\"news\"的频道。\n 4. PSUBSCRIBE命令：用于模式订阅一个或多个匹配的频道。语法为：PSUBSCRIBE pattern [pattern\n    ...]。其中，pattern可以包含通配符。例如，PSUBSCRIBE news. 订阅了以\"news.\"开头的所有频道。\n 5. PUNSUBSCRIBE命令：用于取消模式订阅一个或多个匹配的频道。语法为：PUNSUBSCRIBE [pattern [pattern\n    ...]]。例如，PUNSUBSCRIBE news. 取消订阅以\"news.\"开头的所有频道。\n\n> 可以开两个cmd，一个做发布一个做订阅\n\n\n\n\n事务#\n\nRedis支持事务（Transaction），它允许用户将多个命令打包在一起作为一个单元进行执行。事务提供了一种原子性操作的机制，要么所有的命令都执行成功，要么\n所有的命令都不执行。\n\nRedis的事务使用MULTI、EXEC、WATCH和DISCARD等命令来管理。\n\n 1. MULTI命令：用于开启一个事务。在执行MULTI命令后，Redis会将接下来的命令都添加到事务队列中，而不是立即执行。\n 2. EXEC命令：用于执行事务中的所有命令。当执行EXEC命令时，Redis会按照事务队列中的顺序执行所有的命令。执行结果以数组的形式返回给客户端。\n 3. WATCH命令：用于对一个或多个键进行监视。如果在事务执行之前，被监视的键被修改了，事务将被中断，不会执行。\n 4. DISCARD命令：用于取消事务。当执行DISCARD命令时，所有在事务队列中的命令都会被清空，事务被取消。\n\n使用事务的基本流程如下：\n\n 1. 使用MULTI命令开启一个事务。\n 2. 将需要执行的命令添加到事务队列中。\n 3. 如果需要，使用WATCH命令监视键。\n 4. 执行EXEC命令执行事务。Redis会按照队列中的顺序执行命令，并返回执行结果。\n 5. 根据返回结果判断事务执行是否成功。\n\n事务中的命令在执行之前不会立即执行，而是在执行EXEC命令时才会被执行。这意味着事务期间的命令并不会阻塞其他客户端的操作，也不会中断其他客户端对键的读写操作。\n\n需要注意的是，Redis的事务不支持回滚操作。如果在事务执行期间发生错误，事务会继续执行，而不会回滚已执行的命令。因此，在使用Redis事务时，需要保证事务中的\n命令是幂等的，即多次执行命令的结果和一次执行的结果相同\n\n\n\n","routePath":"/guide/node/45-Redis( 发布订阅 + 事务 )","lang":"","toc":[{"text":"45-Redis( 发布订阅 + 事务 )","id":"45-redis-发布订阅--事务-","depth":2,"charIndex":-1},{"text":"发布订阅","id":"发布订阅","depth":3,"charIndex":24},{"text":"事务","id":"事务","depth":3,"charIndex":812}],"domain":"","frontmatter":{},"version":""},{"id":59,"title":"","content":"46-Redis( 持久化RDB AOF )#\n\n\nredis持久化#\n\nRedis提供两种持久化方式：\n\n 1. RDB（Redis\n    Database）持久化：RDB是一种快照的形式，它会将内存中的数据定期保存到磁盘上。可以通过配置Redis服务器，设置自动触发RDB快照的条件，比如在\n    指定的时间间隔内，或者在指定的写操作次数达到一定阈值时进行快照保存。RDB持久化生成的快照文件是一个二进制文件，包含了Redis数据的完整状态。在恢复数\n    据时，可以通过加载快照文件将数据重新加载到内存中。\n 2. AOF（Append-Only\n    File）持久化：AOF持久化记录了Redis服务器执行的所有写操作命令，在文件中以追加的方式保存。当Redis需要重启时，可以重新执行AOF文件中保存\n    的命令，以重新构建数据集。相比于RDB持久化，AOF持久化提供了更好的数据恢复保证，因为它记录了每个写操作，而不是快照的形式。然而，AOF文件相对于RD\n    B文件更大，恢复数据的速度可能会比较慢。\n\n\nRDB使用#\n\n打开redis配置文件\n\n\n\n找到save\n\n\n\n他提供了三个案例\n\n 1. 3600秒内也就是一小时进行一次改动就会触发快照\n 2. 300秒内也就是5分钟，进行100次修改就会进行快照\n 3. 60秒内一万次修改就会进行快照\n\n具体场景需要根据你的用户量，以及负载情况自己定义.\n\n\n\n其次就是可以通过命令行手动触发快照\n\n\n\n\nAOF使用#\n\n将 appendonly 配置项的值设置为 yes：默认情况下，该配置项的值为 no，表示未启用AOF持久化。将其值修改为 yes，以启用AOF持久化。\n\n","routePath":"/guide/node/46-Redis( 持久化RDB AOF )","lang":"","toc":[{"text":"46-Redis( 持久化RDB AOF )","id":"46-redis-持久化rdb-aof-","depth":2,"charIndex":-1},{"text":"redis持久化","id":"redis持久化","depth":3,"charIndex":25},{"text":"RDB使用","id":"rdb使用","depth":3,"charIndex":468},{"text":"AOF使用","id":"aof使用","depth":3,"charIndex":643}],"domain":"","frontmatter":{},"version":""},{"id":60,"title":"","content":"47-Redis( 主从复制 )#\n\nRedis主从复制是一种数据复制和同步机制，其中一个Redis服务器（称为主服务器）将其数据复制到一个或多个其他Redis服务器（称为从服务器）。主从复制提供了\n数据冗余备份、读写分离和故障恢复等功能。\n\n\n\n以下是Redis主从复制的一般工作流程：\n\n 1. 配置主服务器：在主服务器上，你需要在配置文件中启用主从复制并指定从服务器的IP地址和端口号。你可以使用replicaof配置选项或slaveof配置选项\n    来指定从服务器。\n 2. 连接从服务器：从服务器连接到主服务器并发送复制请求。从服务器通过发送SYNC命令请求进行全量复制或通过发送PSYNC命令请求进行部分复制（增量复制）。\n 3. 全量复制（SYNC）：如果从服务器是第一次连接或无法执行部分复制，主服务器将执行全量复制。在全量复制期间，主服务器将快照文件（RDB文件）发送给从服务器\n    ，从服务器将接收并加载该文件以完全复制主服务器的数据。\n 4. 部分复制（PSYNC）：如果从服务器已经执行过全量复制并建立了复制断点，主服务器将执行部分复制。在部分复制期间，主服务器将发送增量复制流（replica\n    tion stream）给从服务器，从服务器将接收并应用该流以保持与主服务器的同步。\n 5. 复制持久化：从服务器接收到数据后，会将其保存在本地磁盘上，以便在重启后仍然保持数据的一致性。\n 6. 同步延迟：从服务器的复制是异步的，因此存在复制延迟。延迟取决于网络延迟、主服务器的负载和从服务器的性能等因素。\n 7. 读写分离：一旦建立了主从复制关系，从服务器可以接收读操作。这使得可以将读流量从主服务器分散到从服务器上，从而减轻主服务器的负载。\n 8. 故障恢复：如果主服务器发生故障，可以将一个从服务器提升为新的主服务器，以继续提供服务。当主服务器恢复时，它可以作为从服务器连接到新的主服务器，继续进行数\n    据复制。\n\n\n修改配置文件#\n\n在根目录下面新建一个 redis-6378.conf 配置文件 作为redis从服务器,默认的配置文件6379作为主服务器\n\nredis-6378.conf 文件配置，配置文件名字随便取\n\n\n\n启动从服务器\n\n\n\n打开从服务器cli\n\n\n\n启动主服务器\n\n\n\n主服务器写入一个值\n\n\n\n从服务器直接同步过来这个值 就可以直接获取到\n\n> 注意从服务器是不允许写入的操作","routePath":"/guide/node/47-Redis( 主从复制 )","lang":"","toc":[{"text":"47-Redis( 主从复制 )","id":"47-redis-主从复制-","depth":2,"charIndex":-1},{"text":"修改配置文件","id":"修改配置文件","depth":3,"charIndex":832}],"domain":"","frontmatter":{},"version":""},{"id":61,"title":"","content":"48-Redis( ioredis )#\n\nioredis 是一个强大且流行的 Node.js 库，用于与 Redis 进行交互。Redis 是一个开源的内存数据结构存储系统。ioredis\n提供了一个简单高效的 API，供 Node.js 应用程序与 Redis 服务器进行通信。\n\n以下是 ioredis 的一些主要特点：\n\n 1. 高性能：ioredis 设计为快速高效。它支持管道操作，可以在一次往返中发送多个 Redis\n    命令，从而减少网络延迟。它还支持连接池，并且可以在连接丢失时自动重新连接到 Redis 服务器。\n 2. Promises 和 async/await 支持：ioredis 使用 promises，并支持 async/await 语法，使得编写异步代码和处理\n    Redis 命令更加可读。\n 3. 集群和 sentinel 支持：ioredis 内置支持 Redis 集群和 Redis Sentinel，这是 Redis\n    的高级功能，用于分布式设置和高可用性。它提供了直观的 API，用于处理 Redis 集群和故障转移场景。\n 4. Lua 脚本：ioredis 允许你使用 eval 和 evalsha 命令在 Redis 服务器上执行 Lua\n    脚本。这个功能使得你可以在服务器端执行复杂操作，减少客户端与服务器之间的往返次数。\n 5. 发布/订阅和阻塞命令：ioredis 支持 Redis 的发布/订阅机制，允许你创建实时消息系统和事件驱动架构。它还提供了对 BRPOP 和 BLPOP\n    等阻塞命令的支持，允许你等待项目被推送到列表中并原子地弹出它们。\n 6. 流和管道：ioredis 支持 Redis\n    的流数据类型，允许你消费和生成数据流。它还提供了一种方便的方式将多个命令进行管道化，减少与服务器之间的往返次数。\n\n\n使用方法#\n\n安装\n\n\n\n连接redis\n\n\n\n 1. 字符串\n\n\n\n 2. 集合\n\n\n\n 3. 哈希\n\n\n\n 4. 队列\n\n\n\n\n发布订阅#\n\n","routePath":"/guide/node/48-Redis( ioredis )","lang":"","toc":[{"text":"48-Redis(  ioredis )","id":"48-redis--ioredis-","depth":2,"charIndex":-1},{"text":"使用方法","id":"使用方法","depth":3,"charIndex":805},{"text":"发布订阅","id":"发布订阅","depth":3,"charIndex":871}],"domain":"","frontmatter":{},"version":""},{"id":62,"title":"","content":"49-lua( 安装-介绍 )#\n\n\nlua#\n\nLua是一种轻量级、高效、可嵌入的脚本语言，最初由巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de\nJaneiro）的一个小团队开发而成。它的名字\"Lua\"在葡萄牙语中意为\"月亮\"，寓意着Lua作为一门明亮的语言。\n\nLua具有简洁的语法和灵活的语义，被广泛应用于嵌入式系统、游戏开发、Web应用、脚本编写等领域。它的设计目标之一是作为扩展和嵌入式脚本语言，可以与其他编程语言无\n缝集成。Lua的核心只有很小的代码库，但通过使用模块和库可以轻松地扩展其功能。\n\n以下是一些关键特点和用途介绍：\n\n 1. 简洁高效：Lua的语法简单清晰，语义灵活高效。它使用动态类型和自动内存管理，支持面向过程和函数式编程风格，并提供了强大的协程支持。\n 2. 嵌入式脚本语言：Lua被设计为一种可嵌入的脚本语言，可以轻松地与其他编程语言集成。它提供了C\n    API，允许开发者将Lua嵌入到C/C++程序中，或者通过扩展库将Lua嵌入到其他应用程序中。\n 3. 游戏开发：Lua在游戏开发中广泛应用。许多游戏引擎（如Unity和Corona\n    SDK）都支持Lua作为脚本语言，开发者可以使用Lua编写游戏逻辑、场景管理和AI等。\n 4. 脚本编写：由于其简洁性和易学性，Lua经常被用作脚本编写语言。它可以用于编写各种系统工具、自动化任务和快速原型开发。\n 5. 配置文件：Lua的语法非常适合用作配置文件的格式。许多应用程序和框架使用Lua作为配置文件语言，因为它易于阅读、编写和修改。\n\n为了增强性能和扩展性，可以将Lua与Redis和Nginx结合使用。这种组合可以用于构建高性能的Web应用程序或API服务。\n\n 1. Redis：Redis是一个快速、高效的内存数据存储系统，它支持各种数据结构，如字符串、哈希、列表、集合和有序集合。与Lua结合使用，可以利用Redis\n    的高速缓存功能和Lua的灵活性来处理一些复杂的计算或数据查询。\n    * 缓存数据：使用Redis作为缓存存储，可以将频繁访问的数据存储在Redis中，以减轻后端数据库的负载。Lua可以编写与Redis交互的脚本，通过读取\n      和写入Redis数据来提高数据访问速度。\n    * 分布式锁：通过Redis的原子性操作和Lua的脚本编写能力，可以实现分布式锁机制，用于解决并发访问和资源竞争的问题。\n 2. Nginx：Nginx是一个高性能的Web服务器和反向代理服务器。它支持使用Lua嵌入式模块来扩展其功能。\n    * 请求处理：使用Nginx的Lua模块，可以编写Lua脚本来处理HTTP请求。这使得可以在请求到达应用程序服务器之前进行一些预处理、身份验证、请求路由\n      等操作，从而减轻后端服务器的负载。\n    * 动态响应：通过结合Lua和Nginx的subrequest机制，可以实现动态生成响应。这对于根据请求参数或其他条件生成动态内容非常有用。\n    * 访问控制：使用Lua脚本，可以在Nginx层面对访问进行细粒度的控制，例如IP白名单、黑名单、请求频率限制等。\n\n\n安装#\n\nlua官网\n\n\n\n\n\n\n\n选择对应的平台下载就好\n\n\n\n下载完成，解压到文件夹，将文件夹路径配置环境变量即可\n\n使用lua54 测试一下\n\n\n\n\nvscode支持#\n\n找到扩展安装以下两个插件\n\n\n\n调试代码\n\n","routePath":"/guide/node/49-lua( 安装-介绍 )","lang":"","toc":[{"text":"49-lua( 安装-介绍 )","id":"49-lua-安装-介绍-","depth":2,"charIndex":-1},{"text":"lua","id":"lua","depth":3,"charIndex":18},{"text":"安装","id":"安装","depth":3,"charIndex":1353},{"text":"vscode支持","id":"vscode支持","depth":3,"charIndex":1431}],"domain":"","frontmatter":{},"version":""},{"id":63,"title":"","content":"5-npx#\n\n\nnpx 是什么#\n\nnpx是一个命令行工具，它是npm 5.2.0 版本中新增的功能。它允许用户在不安装全局包的情况下，运行已安装在本地项目中的包或者远程仓库中的包。\n\nnpx的作用是在命令行中运行 node 包中的可执行文件，而无需全局安装这些包\n\n这可以使开发人员更轻松地管理包的依赖关系，并且可以避免全局污染的问题。\n\n它还可以帮助开发人员在项目中使用不同版本的包，而不会出现版本冲突的问题。\n\nnpx 的优势\n\n 1. 避免全局安装：npx允许你执行npm package，而不需要你先全局安装它。\n 2. 总是使用最新版本：如果你没有在本地安装相应的npm package，npx会从npm的package仓库中下载并使用最新版。\n 3. 执行任意npm包：npx不仅可以执行在package.json的scripts部分定义的命令，还可以执行任何npm package。\n 4. 执行 GitHub gist：npx甚至可以执行GitHub gist或者其他公开的JavaScript文件。\n\n\nnpm 和 npx 区别#\n\nnpx侧重于执行命令的，执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令\n\nnpm侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。\n\n\n示例 1#\n\ncreate-react-app.bootcss.com/docs/gettin…\n\n\n\n例如创建一个 react 项目 在之前需要安装到全局\n\n\n\n然后执行 create-react-app my-app这样的话会有两个问题\n\n * 首先需要全局安装这个包占用磁盘空间\n * 并且如果需要更新还得执行更新命令\n\n如果使用npx命令就不会有上面的问题了\n\n\n示例 2#\n\n查看全局安装的包\n\n\n\n\n\n> 我全局并没有安装vite\n\n当前项目安装vite\n\n\n\n安装完成之后发现无法执行运行vite命令\n\n\n\n这时候就可以使用npx vite 了\n\n\n\nnpx的运行规则和npm是一样的\n\n本地目录查找.bin看有没有 如果没有就去全局的 node_moduels 查找\n\n如果还没有就去下载这个包，然后运行命令，然后删除这个包","routePath":"/guide/node/5-npx","lang":"","toc":[{"text":"5-npx","id":"5-npx","depth":2,"charIndex":-1},{"text":"npx 是什么","id":"npx-是什么","depth":3,"charIndex":8},{"text":"npm 和 npx 区别","id":"npm-和-npx-区别","depth":3,"charIndex":462},{"text":"示例 1","id":"示例-1","depth":3,"charIndex":-1},{"text":"示例 2","id":"示例-2","depth":3,"charIndex":746}],"domain":"","frontmatter":{},"version":""},{"id":64,"title":"","content":"50-lua( lua的基本使用 )#\n\n\nlua基本使用#\n\n全局变量局部变量\n\n * 全局变量是在全局作用域中定义的变量，可以在脚本的任何地方访问。\n * 全局变量在定义时不需要使用关键字，直接赋值即可。\n\n\n\n * 局部变量是在特定作用域内定义的变量，只能在其所属的作用域内部访问。\n * 局部变量的作用域通常是函数体内部，也可以在代码块（使用 do...end）中创建局部变量。\n * 在局部作用域中，可以通过简单的赋值语句定义局部变量。\n\n\n\n条件语句\n\n在Lua中，条件判断语句可以使用 if、elseif 和 else 关键字来实现\n\n\n\n函数\n\n在Lua中，函数是一种可重复使用的代码块，用于执行特定的任务或操作\n\n\n\n\n数据类型#\n\n 1. nil：表示无效值或缺失值。\n 2. boolean：表示布尔值，可以是 true 或 false。\n 3. number：表示数字，包括整数和浮点数。\n 4. string：表示字符串，由字符序列组成。\n 5. table：表示表，一种关联数组，用于存储和组织数据。\n 6. function：表示函数，用于封装可执行的代码块。\n 7. userdata：表示用户自定义数据类型，通常与C语言库交互使用。\n 8. thread：表示协程，用于实现多线程编程。\n 9. metatable：表示元表，用于定义表的行为。\n\n常用数据类型用法\n\n\n\n字符串拼接 ..\n\n\n\ntable 可以描述 对象和数组\n\n> lua索引从1开始\n\n\n\n循环\n\n\n\n循环table\n\n\n\n循环数组\n\n\n\n\n模块化#\n\ntest.lua 暴露一个方法add\n\n\n\nindex.lua 引入该文件调用add方法\n\n","routePath":"/guide/node/50-lua( 基本使用 )","lang":"","toc":[{"text":"50-lua( lua的基本使用 )","id":"50-lua-lua的基本使用-","depth":2,"charIndex":-1},{"text":"lua基本使用","id":"lua基本使用","depth":3,"charIndex":21},{"text":"数据类型","id":"数据类型","depth":3,"charIndex":318},{"text":"模块化","id":"模块化","depth":3,"charIndex":673}],"domain":"","frontmatter":{},"version":""},{"id":65,"title":"","content":"抽奖","routePath":"/guide/node/51-lua + Redis( 限流阀 )","lang":"","toc":[{"text":"51-lua + Redis( 限流阀 )","id":"51-lua--redis-限流阀-","depth":2,"charIndex":-1},{"text":"限流功能","id":"限流功能","depth":3,"charIndex":-1},{"text":"安装依赖","id":"安装依赖","depth":3,"charIndex":-1},{"text":"代码编写","id":"代码编写","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":66,"title":"","content":"52-定时任务( 自动签到 )#\n\n\n什么是定时任务？#\n\n定时任务是指在预定的时间点或时间间隔内执行的任务或操作。它们是自动化执行特定逻辑的一种方式，可用于执行重复性的、周期性的或计划性的任务。\n\n定时任务通常用于以下情况：\n\n 1. 执行后台任务：定时任务可用于自动执行后台任务，如数据备份、日志清理、缓存刷新等。通过设定适当的时间点或时间间隔，可以确保这些任务按计划进行，而无需手动干\n    预。\n 2. 执行定期操作：定时任务可用于执行定期操作，如发送电子邮件提醒、生成报告、更新数据等。通过设定适当的时间点，可以自动触发这些操作，提高效率并减少人工操作的\n    需求。\n 3. 调度任务和工作流：定时任务可以用于调度和协调复杂的任务和工作流程。通过设置任务之间的依赖关系和执\n\n\n安装依赖#\n\n\n\nnode-schedule官方文档，request调用接口\n\n> 一般定时任务都是用cron表达式去表示时间的\n\n\ncron表达式#\n\nCron表达式是一种用于指定定时任务执行时间的字符串表示形式。它由6个或7个字段组成，每个字段表示任务执行的时间单位和范围。\n\nCron表达式的典型格式如下：\n\n\n\n域               是否必需   取值范围                                             特殊字符\n秒 Seconds       是      [0, 59]                                          * , - /\n分钟 Minutes      是      [0, 59]                                          * , - /\n小时 Hours        是      [0, 23]                                          * , - /\n日期 DayofMonth   是      [1, 31]                                          * , - / ? L W\n月份 Month        是      [1, 12]或[JAN, DEC]                               * , - /\n星期 DayofWeek    是      [1, 7]或[MON, SUN]。若使用[1, 7]表达方式，1代表星期一，7代表星期日。   * , - / ? L #\n年 Year          否      1970+                                            - * /\n\n每个字段可以接受特定的数值、范围、通配符和特殊字符来指定任务的执行时间：\n\n * 数值：表示具体的时间单位，如1、2、10等。\n * 范围：使用-连接起始和结束的数值，表示一个范围内的所有值，如1-5表示1到5的所有数值。\n * 通配符：使用*表示匹配该字段的所有可能值，如*表示每分钟、每小时、每天等。\n * 逗号分隔：使用逗号分隔多个数值或范围，表示匹配其中任意一个值，如1,3表示1或3。\n * 步长：使用/表示步长，用于指定间隔的数值，如*/5表示每隔5个单位执行一次。\n * 特殊字符：Cron表达式还支持一些特殊字符来表示特定的含义，如?用于替代日和星期字段中的任意值，L表示最后一天，W表示最近的工作日等。\n\n以下是一些常见的Cron表达式示例：\n\n * * * * * *：每分钟执行一次任务。\n * 0 * * * *：每小时的整点执行一次任务。\n * 0 0 * * *：每天的午夜执行一次任务。\n * 0 0 * * 1：每周一的午夜执行一次任务。\n * 0 0 1 * *：每月的1号午夜执行一次任务。\n * 0 0 1 1 *：每年的1月1日午夜执行一次任务。\n\n\n代码编写(掘金自动签到)#\n\n\n\nconfig.js\n\n\n\n运行，在这我设置每秒调用，所以返回重复签到了\n\n\n\n> aid和uid可以在掘金网页f12中网络随便一个接口都有显示，cookie可以通过f12应用查看\n\n查看是否签到成功，发现成功\n\n","routePath":"/guide/node/52-定时任务( 自动签到 )","lang":"","toc":[{"text":"52-定时任务( 自动签到 )","id":"52-定时任务-自动签到-","depth":2,"charIndex":-1},{"text":"什么是定时任务？","id":"什么是定时任务","depth":3,"charIndex":18},{"text":"安装依赖","id":"安装依赖","depth":3,"charIndex":346},{"text":"cron表达式","id":"cron表达式","depth":3,"charIndex":413},{"text":"代码编写(掘金自动签到)","id":"代码编写掘金自动签到","depth":3,"charIndex":1650}],"domain":"","frontmatter":{},"version":""},{"id":67,"title":"","content":"53-serverLess( 云函数 )#\n\n\n什么是serverLess?#\n\nserverLess并不是一个技术，他只是一种架构模型，(无服务器架构)，在传统模式下，我们部署一个服务，需要选择服务器Linux,windows等,并且还要安\n装环境，熟悉操作系统命令，知晓安全知识等，有一定成本，serverLess，核心思想就是，让开发者更多的是关注业务本身，而不是服务器运行成本。\n\n\nFaaS与BaaS#\n\n 1. 函数即服务（FaaS）：\n    FaaS是一种Serverless计算模型，它允许开发人员编写和部署函数代码，而无需关心底层的服务器管理。在FaaS中，开发人员只需关注函数的实现和逻辑\n    ，将其上传到云平台上，平台会负责函数的运行和扩展。当有请求触发函数时，云平台会自动为函数提供所需的计算资源，并根据请求量进行弹性扩展。这种按需计算的模式\n    使开发人员可以更专注于业务逻辑的实现，同时实现了资源的高效利用。\n\n> 每个函数即一个服务，函数内只需处理业务，可以使用BASS层提供的服务已完成业务，无需关心背后计算资源的问题。\n\n 2. 后端即服务（BaaS）：\n    后端即服务是一种提供面向移动应用和Web应用的后端功能的云服务模型。BaaS为开发人员提供了一组预构建的后端服务，如用户身份验证、数据库存储、文件存储、\n    推送通知等，以简化应用程序的开发和管理。开发人员可以使用BaaS平台提供的API和SDK，直接集成这些功能到他们的应用中，而无需自己构建和维护后端基础设\n    施。\n\n> 对后端的资源当成一种服务，如文件存储，数据存储，推送服务，身份验证。该层只需提供对应的服务，无需关心业务。定义为底层基础服务，由其他服务调用，正常不触及用户\n> 终端。\n\n\n编写serverLess云函数#\n\n安装依赖\n\n\n\n@serverless-devs/s文档\n\nServerless Devs 是一个开源开放的 Serverless 开发者平台，致力于为开发者提供强大的工具链体系。通过该平台，开发者不仅可以一键体验多云\nServerless 产品，极速部署 Serverless 项目，还可以在 Serverless 应用全生命周期进行项目的管理，并且非常简单快速的将\nServerless Devs 与其他工具/平台进行结合，进一步提升研发、运维效能。\n\n 1. 配置密钥\n\n我们需要选择一款云产品，这里用阿里云演示，当然你也可以用别的。\n\n访问旁边链接，登录阿里云，RAM控制\n\n\n\n 2. 添加密钥\n\ns命令 你安装完成 @serverless-devs/s 这个之后就有了\n\n\n\n\n\n选择阿里云 输入刚才的 AccessKeyID AccessKeySecret 第三个是个别名可以自定义\n\n\n\n检查密钥是否正确,能输出信息就是对的\n\n\n\n\n\n 3. 创建项目\n\n直接运行s命令即可，根据下图创建\n\n\n\n\n\n打开生成好的项目，在目录下执行s deploy,上传成功\n\n\n\n访问此链接即可找到函数，如果没有就找到你所选的服务器地区\n\n\n\n","routePath":"/guide/node/53-serverLess( 云函数 )","lang":"","toc":[{"text":"53-serverLess( 云函数 )","id":"53-serverless-云函数-","depth":2,"charIndex":-1},{"text":"什么是serverLess?","id":"什么是serverless","depth":3,"charIndex":23},{"text":"FaaS与BaaS","id":"faas与baas","depth":3,"charIndex":195},{"text":"编写serverLess云函数","id":"编写serverless云函数","depth":3,"charIndex":758}],"domain":"","frontmatter":{},"version":""},{"id":68,"title":"","content":"54-net#\n\nnet模块是Node.js的核心模块之一，它提供了用于创建基于网络的应用程序的API。net模块主要用于创建TCP服务器和TCP客户端，以及处理网络通信。\n\n\n\nTCP（Transmission Control\nProtocol）是一种面向连接的、可靠的传输协议，用于在计算机网络上进行数据传输。它是互联网协议套件（TCP/IP）的一部分，是应用层和网络层之间的传输层协议\n。\n\nTCP的主要特点包括：\n\n 1. 可靠性：TCP通过使用确认机制、序列号和重传策略来确保数据的可靠传输。它可以检测并纠正数据丢失、重复、损坏或失序的问题。\n 2. 面向连接：在进行数据传输之前，TCP需要在发送方和接收方之间建立一个连接。连接的建立是通过三次握手来完成的，确保双方都准备好进行通信。\n 3. 全双工通信：TCP支持双方同时进行双向通信，即发送方和接收方可以在同一时间发送和接收数据。\n 4. 流式传输：TCP将数据视为连续的字节流进行传输，而不是离散的数据包。发送方将数据划分为较小的数据块，但TCP在传输过程中将其作为连续的字节流处理。\n 5. 拥塞控制：TCP具备拥塞控制机制，用于避免网络拥塞和数据丢失。它通过动态调整发送速率、使用拥塞窗口和慢启动算法等方式来控制数据的发送速度。\n\n\n场景#\n\n服务端之间的通讯#\n\n服务端之间的通讯可以直接使用TCP通讯，而不需要上升到http层\n\nserver.js\n\n创建一个TCP服务，并且发送套接字，监听端口号3000\n\n\n\nclient.js\n\n连接server端，并且监听返回的数据\n\n\n\n传输层实现http协议#\n\n创建一个TCP服务\n\n\n\nnet.createServer创建 Unix 域套接字并且返回一个server对象接受一个回调函数\n\nsocket可以监听很多事件\n\n 1. close 一旦套接字完全关闭就触发\n 2. connect 当成功建立套接字连接时触发\n 3. data 接收到数据时触发\n 4. end 当套接字的另一端表示传输结束时触发，从而结束套接字的可读端\n\n通过node http.js 启动之后我们使用浏览器访问一下，打不开，但控制台输出了如下\n\n\n\n可以看到浏览器发送了一个http get 请求 我们可以通过关键字get 返回相关的内容例如html\n\n\n\n这时我们再访问localhost:3000就会有信息了\n\n","routePath":"/guide/node/54-net","lang":"","toc":[{"text":"54-net","id":"54-net","depth":2,"charIndex":-1},{"text":"场景","id":"场景","depth":3,"charIndex":552},{"text":"服务端之间的通讯","id":"服务端之间的通讯","depth":4,"charIndex":557},{"text":"传输层实现http协议","id":"传输层实现http协议","depth":4,"charIndex":678}],"domain":"","frontmatter":{},"version":""},{"id":69,"title":"","content":"55-socket.io#","routePath":"/guide/node/55-socket.io","lang":"","toc":[{"text":"55-socket.io","id":"55-socketio","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":70,"title":"","content":"6-发布 npm 包#\n\n\n发布 npm 的包的好处是什么#\n\n * 方便团队或者跨团队共享代码，使用 npm 包就可以方便的管理，并且还可以进行版本控制\n * 做开源造轮子必备技术，否则你做完的轮子如何让别人使用，难道是 U 盘拷贝？\n * 面试很经常问到\n * 增加个人 IP让更多的人知道你的技术能力和贡献\n\n\n发布前准备工作#\n\n\n\n首先先检查一下是否是 npm 源然后创建一个 npm 账号\n\n\n\n> 创建完成之后使用 npm login 登录账号\n\n\n\n登录完成之后使用npm publish 发布 npm 包\n\n\n\n发布成功，如果出现 403 说明包名被占用了","routePath":"/guide/node/6-发布npm包","lang":"","toc":[{"text":"6-发布 npm 包","id":"6-发布-npm-包","depth":2,"charIndex":-1},{"text":"发布 npm 的包的好处是什么","id":"发布-npm-的包的好处是什么","depth":3,"charIndex":13},{"text":"发布前准备工作","id":"发布前准备工作","depth":3,"charIndex":158}],"domain":"","frontmatter":{},"version":""},{"id":71,"title":"","content":"7-搭建 npm 私服#\n\n\n构建 npm 私服#\n\n构建私服有什么收益吗？\n\n * 可以离线使用，你可以将npm 私服部署到内网集群，这样离线也可以访问私有的包。\n * 提高包的安全性，使用私有的 npm 仓库可以更好的管理你的包，避免在使用公共的 npm 包的时候出现漏洞。\n * 提高包的下载速度，使用私有 npm 仓库，你可以将经常使用的 npm\n   包缓存到本地，从而显著提高包的下载速度，减少依赖包的下载时间。这对于团队内部开发和持续集成、部署等场景非常有用\n\n\n如何搭建 npm 私服#\n\nverdaccio.org/zh-CN/\n\nVerdaccio 是可以帮我们快速构建 npm 私服的一个工具\n\n\n\n使用方式非常简单，直接运行命令verdaccio即可\n\n> 可以通过verdaccio --help查看配置\n\n\n\n然后访问 4873 默认端口即可\n\n\n\n如果不是中文，点击设置切换为中文简体即可\n\n\n\n\n基本命令#\n\n\n\n其他配置文件项\n\nverdaccio.org/zh-CN/docs/…","routePath":"/guide/node/7-搭建npm私服","lang":"","toc":[{"text":"7-搭建 npm 私服","id":"7-搭建-npm-私服","depth":2,"charIndex":-1},{"text":"构建 npm 私服","id":"构建-npm-私服","depth":3,"charIndex":14},{"text":"如何搭建 npm 私服","id":"如何搭建-npm-私服","depth":3,"charIndex":238},{"text":"基本命令","id":"基本命令","depth":3,"charIndex":413}],"domain":"","frontmatter":{},"version":""},{"id":72,"title":"","content":"8-模块化(cjs、esm、源码)#\n\nNodejs 模块化规范遵循两套：CommonJS规范和ESM规范\n\n\nCommonJS 规范#\n\n注意：需要通过npm init -y生成package.json，在该文件中添加或修改一个属性\"type\":\"commonjs\"，如下图\n\n\n\n引入模块（require）支持五种格式\n\n * 支持引入自己编写的模块 ./ ../ 等\n\n * 支持引入第三方模块express md5 koa 等\n\n * 支持引入内置模块例如 http os fs child_process 等nodejs内置模块\n   \n   > 高版本 nodejs 引入需要这样写node:模块名，低版本直接写模块名即可\n\n * 支持引入addon.node 等 C++扩展模块 .node文件\n\n * 支持引入json文件\n\n\n\n导出模块exports 和 module.exports\n\n\n\n如果不想导出对象，可以直接导出值\n\n\n\n\nESM 模块规范#\n\n引入模块 import 必须写在头部\n\n> 注意使用 ESM 模块的时候需要打开 package.json 设置\"type\":\"module\"\n\n\n\n> 如果要引入 json 文件需要特殊处理 需要增加断言并且指定类型 json，node 低版本不支持\n\n\n\n可以加载模块的不同导出\n\n\n\n加载，并可以起别名\n\n\n\n加载模块的整体对象\n\n\n\n动态导入模块\n\nimport 静态加载不支持掺杂在逻辑中，如果想动态加载请使用 import 函数模式\n\n\n\n模块导出\n\n * 导出一个默认对象export default，default 只能有一个不可重复\n\n\n\n * 导出变量\n\n\n\n\nCjs 和 ESM 的区别#\n\n 1. Cjs是基于运行时的同步加载，ESM是基于编译时的异步加载\n\n 2. Cjs是可以修改值的，ESM值并且不可修改（可读的）\n\n 3. Cjs不可以 Tree shaking，ESM支持 Tree shaking\n    \n    > Tree shaking 是一个用于在打包过程中去除未使用代码（dead code）的技术，它可以有效地减小最终生成的 JavaScript\n    > 文件的大小。\n\n 4. Cjs中顶层的this指向这个模块本身，而 ES6 中顶层this指向undefined\n\n\nnodejs 部分源码解析#\n\n可以去官网下载源代码\n\n.json 文件如何处理#\n\n> 文件在modules目录下的cjs下的loader.js\n\n使用fs读取 json 文件读取完成之后是个字符串，然后JSON.parse变成对象返回\n\n\n\n.node 文件如何处理#\n\n发现是通过 process.dlopen 方法处理.node 文件\n\n\n\n.js 文件如何处理#\n\n\n\n如果缓存过这个模块就直接从缓存中读取，如果没有缓存就从fs读取文件\n\n判断如果是cjs但是type为module就报错，并且从父模块读取详细的行号进行报错，如果没问题就调用 compile\n\n\n\n首先，它检查是否存在安全策略对象 policy.manifest，如果存在，表示有安全策略限制需要处理 将函数将模块文件名转换为 URL\n格式，redirects是一个 URL\n映射表，用于处理模块依赖关系，manifest则是一个安全策略对象，用于检测模块的完整性和安全性，然后调用wrapSafe\n\n\n\nwrapSafe调用了wrap方法\n\n\n\nwrap方法，发现就是把我们的代码包装到一个函数里面\n\n\n\n然后继续看wrapSafe函数，发现把返回的字符串即包装之后的代码放入nodejs 虚拟机里面Script，看有没有动态 import\n去加载，最后返回执行后的结果\n\n然后继续看**_compile**，获取到wrapSafe返回的函数，通过Reflect.apply调用因为要填充五个参数[exports, require,\nmodule, filename, dirname],最后返回执行完的结果","routePath":"/guide/node/8-模块化(cjs、esm、源码)","lang":"","toc":[{"text":"8-模块化(cjs、esm、源码)","id":"8-模块化cjsesm源码","depth":2,"charIndex":-1},{"text":"CommonJS 规范","id":"commonjs-规范","depth":3,"charIndex":55},{"text":"ESM 模块规范","id":"esm-模块规范","depth":3,"charIndex":425},{"text":"Cjs 和 ESM 的区别","id":"cjs-和-esm-的区别","depth":3,"charIndex":727},{"text":"nodejs 部分源码解析","id":"nodejs-部分源码解析","depth":3,"charIndex":1000}],"domain":"","frontmatter":{},"version":""},{"id":73,"title":"","content":"9-全局变量 & 全局 API#\n\n\n全局变量#\n\n如何在nodejs定义全局变量呢？\n\n在nodejs中使用global定义全局变量，新建文件index.js\n\n\n\n创建文件child.js，运行会输出全局变量\n\n\n\n> 注意 require 引入 child 文件需要在定义变量后，否则会访问到 undefined\n\n在浏览器中我们定义的全局变量都在window，nodejs在global，不同的环境还需要判断，于是在 ECMAScript 2020\n出现了一个**globalThis**全局变量，在nodejs环境自动切换global，浏览器环境自动切换window，非常方便\n\n\n\n\n关于其他全局 API#\n\n> nodejs 中没有 DOM 和 BOM，除了这些 API，其他的 ECMAscriptAPI 基本都能用\n\n例如下面，这些 API 都是可以正常用的\n\n\n\n\nnodejs 内置全局 API#\n\n__dirname#\n\n它表示当前模块的所在目录的绝对路径\n\n\n\n__filename#\n\n它表示当前模块文件的绝对路径，包括文件名和文件扩展名\n\n\n\nrequire module#\n\n\n\n引入模块和模块导出上一章已经详细讲过了\n\nprocess#\n\n 1. process.argv: 这是一个包含命令行参数的数组。第一个元素是 Node.js 的执行路径，第二个元素是当前执行的 JavaScript\n    文件的路径，之后的元素是传递给脚本的命令行参数\n 2. process.env: 这是一个包含当前环境变量的对象。您可以通过process.env访问并操作环境变量\n 3. process.cwd(): 这个方法返回当前工作目录的路径\n 4. process.on(event, listener):\n    用于注册事件监听器。您可以使用process.on监听诸如exit、uncaughtException等事件，并在事件发生时执行相应的回调函数\n 5. process.exit([code]): 用于退出当前的 Node.js 进程。您可以提供一个可选的退出码作为参数\n 6. process.pid: 这个属性返回当前进程的PID（进程 ID）\n\n这些只是process对象的一些常用属性和方法，还有其他许多属性和方法可用于监控进程、设置信号处理、发送 IPC 消息等\n\n需要注意的是，process对象是一个全局对象，可以在任何模块中直接访问，无需导入或定义\n\nBuffer#\n\n 1. 创建 Buffer 实例：\n    * Buffer.alloc(size[, fill[, encoding]]):\n      创建一个指定大小的新的Buffer实例，初始内容为零。fill参数可用于填充缓冲区，encoding参数指定填充的字符编码\n    * Buffer.from(array): 创建一个包含给定数组的Buffer实例\n    * Buffer.from(string[, encoding]): 创建一个包含给定字符串的Buffer实例\n 2. 读取和写入数据：\n    * buffer[index]: 通过索引读取或写入Buffer实例中的特定字节\n    * buffer.length: 获取Buffer实例的字节长度\n    * buffer.toString([encoding[, start[, end]]]): 将Buffer实例转换为字符串\n 3. 转换数据：\n    * buffer.toJSON(): 将Buffer实例转换为JSON 对象\n    * buffer.slice([start[, end]]): 返回一个新的Buffer实例，其中包含原始Buffer实例的部分内容\n 4. 其他方法：\n    * Buffer.isBuffer(obj): 检查一个对象是否是Buffer实例\n    * Buffer.concat(list[, totalLength]): 将一组Buffer实例或字节数组连接起来形成一个新的Buffer实例\n\n请注意，从Node.js\n6.0版本开始，Buffer构造函数的使用已被弃用，推荐使用Buffer.alloc()、Buffer.from()等方法来创建Buffer实例\n\nBuffer类在处理文件、网络通信、加密和解密等操作中非常有用，尤其是在需要处理二进制数据时","routePath":"/guide/node/9-全局变量和全局API","lang":"","toc":[{"text":"9-全局变量 & 全局 API","id":"9-全局变量--全局-api","depth":2,"charIndex":-1},{"text":"全局变量","id":"全局变量","depth":3,"charIndex":18},{"text":"关于其他全局 API","id":"关于其他全局-api","depth":3,"charIndex":297},{"text":"nodejs 内置全局 API","id":"nodejs-内置全局-api","depth":3,"charIndex":392},{"text":"__dirname","id":"__dirname","depth":4,"charIndex":410},{"text":"__filename","id":"__filename","depth":4,"charIndex":443},{"text":"require module","id":"require-module","depth":4,"charIndex":486},{"text":"process","id":"process","depth":4,"charIndex":526},{"text":"Buffer","id":"buffer","depth":4,"charIndex":1055}],"domain":"","frontmatter":{},"version":""},{"id":74,"title":"","content":"Node#\n\n本章你将学习到 Node 的相关知识","routePath":"/guide/node/","lang":"","toc":[{"text":"Node","id":"node","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":75,"title":"","content":"React 进阶篇#\n\n这是接下来进阶篇的学习目标","routePath":"/guide/react/advance/","lang":"","toc":[{"text":"React 进阶篇","id":"react-进阶篇","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":76,"title":"","content":"属性默认值和类型验证#\n\n在Vue中，我们可以针对props属性进行类型验证，那么在React中同样也能对props进行验证。\n\n> 官网文档地址: https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html\n\n从React v15.5开始，React.PropTypes已移入另一个包中。因此首先我们需要安装prop-types库。\n\n> prop-types 库文档地址: https://www.npmjs.com/package/prop-types\n\n有关props验证这一块，我们主要需要搞清楚以下几个知识点:\n\n * 提供了哪些验证类型\n * 如何设置默认值\n\n\n验证类型#\n\n有关props能够验证的类型，官网实际上已经全部罗列出来了。\n\n> 对应地址:\n> https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html#proptypes\n\n下面是一个简单示例。 在根组件中我们使用到了子组件，并向子组件传递了name和age这两个props属性:\n\n\n\n在子组件中，我们针对props做了类型的限制，要求name为string 类型，age为number类型:\n\n\n\n如果官方为你提供的验证规则不够用?没关系，我们还可以自定义验证器，它在验证失败时应返回一个Error对象。例如：\n\n\n\n另外，针对props是数组或者对象时，如果要验证的不仅仅是否是数组或对象类型，而是要验证数组和对象的每项，那么可以使用arrayOf或objectOf验证器。\n\n例如，我们现在有一个需求，要求数组的每一项为数字， 验证器示例如下:\n\n\n\n子组件下面的props是无法通过验证的：\n\n\n\nscore对应的数组值每一项都应为number类型，以下的用法能够通过验证：\n\n\n\n\n插槽的验证#\n\nReact的插槽也通过props来实现\n\n针对插槽，使用prop-types 可以进行插槽元素的单一验证，例如：\n\n\n\n在上面的示例中，我们为ChildCom设置了一个插槽，并且设置了一个验证，要求父组件在使用ChildCom子组件时，必须要插入一个根元素。\n\n以下的使用方式无法通过验证:\n\n\n\n\n\n以下的使用可以通过验证：\n\n\n\n\n默认值#\n\nprops属性还可以设置默认值，这一点官网已经有了很好的示例，请参阅：\n\n> 官网地址：默认Prop值","routePath":"/guide/react/advance/第一章/1-属性默认值和类型验证","lang":"","toc":[{"text":"属性默认值和类型验证","id":"属性默认值和类型验证","depth":2,"charIndex":-1},{"text":"验证类型","id":"验证类型","depth":3,"charIndex":324},{"text":"插槽的验证","id":"插槽的验证","depth":3,"charIndex":810},{"text":"默认值","id":"默认值","depth":3,"charIndex":986}],"domain":"","frontmatter":{},"version":""},{"id":77,"title":"","content":"高阶组件#\n\n高阶组件英语全称为 Higher-Order Components，简称 HOC，所谓高阶组件，是 React 中一种复用逻辑的技巧。\n高阶组件的学习，主要有下面2个点：\n\n * 认识到高阶组件并非一个组件，而是增强组件功能的一个函数\n * 高阶组件的作用是对多组件公共逻辑进行横向抽离\n\n\n高阶组件是一个函数#\n\n这个点非常有意思，很多人一看到这个名字，自然到会认为高阶组件是一个组件，但是名字往往具有欺骗性，就像javascript和java相关一样\n\n官方对高阶组件给出了很明确的定义，甚至还给了一个公式\n\n> 高阶组件是参数为组件，返回值为新组件的函数。\n\n\n高阶组件要做的事情#\n\n高阶组件作为一个函数，接收你传入的组件。然后又返回一个新组件给你，那你猜都猜得到在高阶组件的内部肯定是对你原有的组件做了一些增强操作，然后为你返回的是增强后的组\n件。\n\n那什么又叫做对组件公共逻辑进行横向抽离呢？看下图：\n\n\n\n假设我们这里有三个组件，每个组件有一部分公共逻辑，一部分该组件自身的业务逻辑，那么很明显每个组件都书写遍这样的公共逻辑是不划算的。\n\n作为一个程序员，我们自然而然想到的就是将这部分公共逻辑提取出来。\n\n早期的React采用的是mixins 来解决这种横切关注点相关的问题。Mixins 的原理可以简单理解为将一个mixin对象上的方法增加到组件上。\n\n\n\n眼熟不?没错，在Vue2.x中也支持mixins这样的混合注入。\n\n不过这只能在React的旧语法React.createClasss 中使用，目前已经不再推荐使用了。\n\n> mixins 问题\n> \n>  * mixins 引入了隐式的依赖关系\n> \n> 你可能会写一个有状态的组件，然后你的同事可能添加一个读取这个组件state的mixin。几个月之后，你可能希望将该state移动到父组件，以便与其兄弟组件共\n> 享。你会记得更新这个mixin来读取props而不是state吗?如果此时，其它组件也在使用这个mixin呢?\n> \n>  * mixins 引起名称冲突\n> \n> 无法保证两个特定的mixin可以一起使用。例如，如果 FluxListenerMixin 和 WindowSizeMixin\n> 都定义来handleChange(),则不能一起使用它们。同时，你也无法在自己的组件上定义具有此名称的方法。\n> \n>  * mixins 导致滚雪球式的复杂性\n> \n> 每一个新的需求都使mixins更难理解。使用相同mixin的组件会随着时间的推移变得越来越耦合。任何新功能都可以使用mixins添加到所有组件中。渐渐地，封\n> 装边界被侵蚀了，由于很难更改或删除现有的mixins,它们变得越来越抽象，直到没有人理解它们是如何工作的。\n> \n> 关于 mixins\n> 的讨论，参考官网：https://zh-hans.reactjs.org/blog/2016/07/13/mixins-considered-harmful\n> .html\n\n之后 React 推出了高阶组件的抽离方式，如下：\n\n\n\n在高阶组件中，接收一个组件作为参数，然后在高阶组件中会返回一一个新组件，新组件中会将公共逻辑附加上去，传入的组件一般作为新组件的视图。\n\n下面举个具体例子：\n\n\n\n\n\n上面的代码中，我们有两个子组件，父组件在使用这两个子组件时，一个需要传入name,另一个需要传入age\n\n正常来讲，父组件使用子组件的方式如下:\n\n\n\n但是现在我们新增了一个需求，\n那就是每个子组件需要记录创建和销毁时的日志。很显然，对于每个子组件来讲，日志相关的逻辑都是相同的，也就算是公共逻辑，没有必要在每个组件中引入一份，因此这里我们来\n使用HOC的方式抽离这一段公共逻辑， 如下:\n\n\n\n在上面的高阶组件中，唯一需要注意的就是返回的新组件在接受了props后，一般需要原封不动的传递给原来的组件。\n\n有了这个高阶组件后，我们就可以对原有的子组件进行加强，如下:\n\n\n\n高阶组件还可以进行嵌套操作，比如我有两段公共逻辑，但是这两段公共逻辑写在一个高阶组件中又不太合适，因此我们就可以拆分成两个高阶组件,例如我们新增一个withTi\nmer的高阶组件:\n\n\n\n然后我们在原基础上增加\n\n\n\n\n高阶组件的现状#\n\n高阶组件的出现，解决了组件之间如何横向抽离公共逻辑的问题，因此你也能过在各大生态库中见到高阶组件的身影。\n\n例如在react-redux中的connect用法，这里connect明显返回的就是一个高阶组件， 之后开发者可以传入自己的组件进行组件强化。\n\n> 官网：https://react-redux.js.org/api/connect#connect-returns\n\n高阶组件是为了解决早期类组件公共逻辑抽离的问题，如果你看官网的示例的话\n\n由于React的Hook出现，函数组件占主流，抽离公共逻辑也能够使用自定义Hook 来实现了\n\n因此你可以在Redux官网看到如下，推荐你使用hooks API\n\n","routePath":"/guide/react/advance/第一章/2-高阶组件","lang":"","toc":[{"text":"高阶组件","id":"高阶组件","depth":2,"charIndex":-1},{"text":"高阶组件是一个函数","id":"高阶组件是一个函数","depth":3,"charIndex":152},{"text":"高阶组件要做的事情","id":"高阶组件要做的事情","depth":3,"charIndex":290},{"text":"高阶组件的现状","id":"高阶组件的现状","depth":3,"charIndex":1789}],"domain":"","frontmatter":{},"version":""},{"id":78,"title":"","content":"Ref#\n\n这一讲，我们就来彻底看一下 Ref，包含以下的内容\n\n * 过时 API: String 类型的 Refs\n * createRefAPI\n * Ref 转发\n * useRef 与useImperativeHandle\n\n\n过时 API: String 类型的 Refs#\n\n首先，我们还是需要认识到 Ref 是为了解决什么问题。我们都知道，现代前端框架的一大特点就是响应式，开发人员不需要再去手动操作 DOM 元素，只需要关心和\nDOM 元素绑定的响应式数据即可。\n\n但是有些时候，我们需要操作 DOM 元素，例如官方所列举的这几个场景:\n\n * 管理焦点，文本选择或媒体播放\n * 触发强制动画\n * 集成第三方 DOM 库\n\n在最最早期的时候，React 中 Ref 的用法非常简单，类似于 Vue,给一个字符串类型的值，之后在方法中通过this.refs.x就能够引用到。\n\n示例如下:\n\n\n\n在上面的代码中，我们在 input 上面挂了一个 ref 属性，对应的值为 inputRef,之后查看组件实例，可以看到该组件实例中的 refs 里面就保存了该\ninput 的 DOM 元素。\n\n\n\n然后我们就可以像之前一样进行 DOM 元素的操作了。例如在上面的示例中我们进行了聚焦的操作。\n\n但是这里需要注意两点:\n\n * 避免使用 refs 来做任何可以通过声明式实现来完成的事情\n * 该 API 已经过时，可能会在未来的版本被移除，官方建议我们使用回调函数或 createRef API 的方式来代替(后面还是用 useRef)\n\n> 关于为何被废弃可以看 Github 的 issue 解释\n\n\ncreateRef API#\n\n接下来我们来看用官方后面推出的 createRef API\n\n\n\n在上面的代码中，我们创建 Ref 不再是通过字符串的形式，而是采用的 createRef 这个静态方法创建了一个 Ref 对象，并在组件实例上面\n\n新增了一个 inputRef 属性来保存这个 Ref 对象。\n\n\n\ncreateRef 这个方法本质也很简单，就是返回了一个{current: null}的对象，源码如下\n\n\n\n最后我们把这个对象和 input 进行关联。\n\n如果要获取 DOM 元素，可以通过this.inputRef.current来获取。\n\n除了在 JSX 中关联 Ref,我们还可以直接关联一个类组件， 这样就可以直接调用该组件内部的方法。 例如：\n\n\n\n\n\n> 虽然提供了这个方式，但他是一个反模式，咱们就回到了 jQuery 时代，尽量避免这么做\n\nReact.createRef APl 是在 React 16.3 版本引入的，如果是稍早一点的版本，官方推荐使用回调 Refs,也就是函数的形式。例如:\n\n\n\n你可能会好奇，为什么上面的例子都是使用的类组件，现在不都是使用函数组件了么?这是因为默认情况下，你不能在函数组件上使用 ref\n属性，因为它们没有实例，但是在函数组件内部是可以使用 ref 的，这涉及到后面要说的 useRef.\n\n\nRef 转发#\n\n既然要讲 Ref,咱们就一起把它整个知识点一 起讲完，接下来要介绍的是 Ref 的转发。\n\nRef 转发是一个可选特性，其允许某些组件接收 ref,并将其向下传递(换句话说，\"转发\"它)给子组件。\n\n那么什么时候需要 Ref 的转发呢?往往就在使用高阶组件的时候。\n\n我们先来看一下如果没有 Ref 转发，在高阶组件中使用 Ref 会遇到什么问题。\n\n\n\n在上面的代码中，我们使用了 withLog 这个高阶组件来包裹 ChildCom1 子组件，从而添加日志功能。在使用由高阶组件返回的增强组件时，我们传递了一个\nRef,我们的本意是想要这个 Ref 关联原本的子组件，从而可以触发子组件里面的方法。\n\n但是我们会发现 Ref 关联的是高阶组件中返回的增强组件，而非原来的子组件。\n\n要解决这个问题就会涉及到 Ref 的转发。说直白一点就是 Ref 的向下传递给子组件。\n\n这里 React 官方为我们提供了一个React.forwardRef APl。我们需要修改的仅仅是高阶组件:\n\n\n\n在上面的代码中，React.forwardRef接受一个渲染函数，该函数接收 props 和 ref 参数并返回原本我们直接返回的增强组件。\n\n接下来我们在增强组件的 render 方法中，通过this.props拿到 ref 继续传递给子组件。\n那么React.forwardRef究竟做了啥呢?源码如下:\n\n\n\n可以看到，实际上 forwardRef 这个静态方法实际上也就是返回一个 elementType 的对象而已，该对象包含一个 render\n方法，也就是我们在使用React.forwardRef时传入的渲染函数。\n\n之所以要这么多此一举，是因为该渲染函数会自动传入 props 和 ref，关键点就在这里，拿到 ref 后，后我们就可以将 ref 继续往下面传递。\n\n\nuseRef 与 useImperativeHandle#\n\n关于 Ref 这一块，最后要看一下的就是这两个 Hook。\n\n我们知道，现在整个 React 是函数组件大行其道，那么自然我们会遇到函数组件下如何进行 Ref 的关联。\n\n在函数组件中，官方为我们提供了新的useRef这个 Hook 来进行关联，但是也可以使用createRefAPI，示例如下:\n\n\n\n通过上面的示例我们可以看出，虽然createRef和useRef都是创建 Ref 的，但是还是有一些区别， 主要体现在下面的点:\n\n * useRef是 hooks 的一种，一般用于函数组件，而createRef一般用于类组件\n * 由useRef创建的 ref 对象在组件的整个生命周期内都不会改变，但是由createRef创建的 ref 对象，组件每更新一次，ref\n   对象就会被重新创建\n\n实际上，就是因为在函数式组件中使用createRef创建 ref 时存在弊端，组件每次更新，ref 对象就会被重新创建，所以出现了useRef来解决这个问题。\n\nuseRef 还接受一个初始值，这在用作关联 DOM 元素时通常没什么用，但是在作为存储不需要变化的全局变量时则非常方便。来看下面的例子:\n\n\n\n上面的写法存在一个问题，如果这个 App 组件里有 state 变化或者他的父组件重新 render 等原因导致这个 App 组件重新 render\n的时候，我们会发现，点击停止按钮，定时器依然会不断的在控制台打印，定时器清除事件无效了。\n\n因为组件重新渲染之后，这里的 timer 以及 clearTimer 方法都会重新创建，timer 已经不是存储的之前的定时器的变量了。\n\n此时根据 useRef 在组件的整个生命周期内都不会改变的特性，我们可以将定时器变量存储到 useRef 所创建的对象上面，示例如下:\n\n\n\n最后，我们要看一下另外一个useImperativeHandle这个 Hook。\n\n该 Hook 一般配合React.forwardRef使用，主要作用是父组件传入 Ref 时，自定义要暴露给父组件的实例值。\n\n来看一个具体的示例:\n\n\n\n\n\n在上面的代码中，我们使用了uselmperativeHandle这个 Hook, 该 Hook 的第一个参数是父组件传递进来的 ref,\n第二个回调函数返回一个对象，该对象是个映射关系， 映射关系中的键之后能够暴露给父组件使用，映射关系中的值对应的是对应的方法。\n\n> 但建议少用，毕竟这是 ref","routePath":"/guide/react/advance/第一章/3-Ref","lang":"","toc":[{"text":"Ref","id":"ref","depth":2,"charIndex":-1},{"text":"过时 API: String 类型的 Refs","id":"过时-api-string-类型的-refs","depth":3,"charIndex":118},{"text":"createRef API","id":"createref-api","depth":3,"charIndex":711},{"text":"Ref 转发","id":"ref-转发","depth":3,"charIndex":1296},{"text":"useRef 与 useImperativeHandle","id":"useref-与-useimperativehandle","depth":3,"charIndex":2095}],"domain":"","frontmatter":{},"version":""},{"id":79,"title":"","content":"Context#\n\n有关 Context ，这是一个非常重要的知识点，甚至我们之后在书写 mini-react，mini-react-router、 mini-redux\n时都会用到的一个知识点，所以这一小节，我们就来好好看一下 Context 的相关内容，主要包含以下几个点:\n\n * Context 要解决的问题\n * Context 的用法\n * Context 相关 Hook\n\n\nContext 要解决的问题#\n\n首先来看一下 Context\n要解决的问题。正常来讲，我们单页应用中的组件会形成一个像组件树一样结构，当内部组件和组件之间要进行数据传递时，就免不了一层一层先传递到共同的父组件，然后再一层一\n层传递下去。\n\n\n\n假设 subComA-1 组件的状态数据要传递给 subComB-2 组件，应该怎么做?\n\n根据我们前面所讲的单项数据流的规则，那么数据应该被提升到 App 根组件，然后通过 props 一层一层的传递给下面的子组件，最终 subComA-1\n拿到所需要的数据；如果 subComA-1 组件需要修改传递下来的数据，那么该组件就还需接收从 App 根组件一层一层传递下来的能够修改数据的方法。\n\n官方在\"何时使用 Context 这一小节也举了一个形象的例子：何时使用 Context\n\n因此，简单概括 Context ，就是解决组件之间数据共享的问题，避免一层一层的传递。\n\nContext\n如果直接翻译成中文，会被翻译成\"上下文\"，这其实在软件领域很常见的一个词，比如前面我们也学习过\"执行上下文\"，所谓上下文，往往指的是代码执行时所需的数据环境信息\n。\n\n\nContext 的用法#\n\nReact 官方对于 Context 的用法，分为旧版 API 和新版 API,有关旧版 API 的用法，本文档就不再赘述，如果有需要的同学，可以参阅: 过时的\nContext\n\n新版 API 使用#\n\n这里我们来看一下新版 API 的使用，示例如下:\n\n\n\n首先，使用React.createContext API 创建的一个上下文对象，该对象里面会提供两个组件，分别是 Provider 和 Consumer\n，表示数据的提供者和消费者。\n\n\n\n在根组件 App.jsx 中，我们设置了一个根组件的状态数据 count，然后从 MyContext 中解构出 Provider\n组件来作为数据的提供者，value 属性用来设置要提供的数据。\n\n\n\n在 ChildCom1 子组件中，无需再像中转站一样接受父组件的数据然后又传递给 ChildCom2 和 ChildCom3 组件。\n\n\n\nChildCom2 组件是一个函数组件，函数组件想要获取 Context 上下文中的数据，需要使用 Consumer\n组件，这种方法需要一个函数作为主元素，这个函数接收当前的 context 值，并返回一个 React 节点。\n\n\n\nChildCom3 组件是一个类组件， 类组件当然也可以使用上面 Consumer 的方式来获取上下文中的数据，但对于类组件而言，还可以使用\ncontextType 的方式。挂载在 class 上的 contextType 属性可以赋值为由React createContext()创建的\nContext 对象。\n\n> 最终效果就是点击 ChildCom2 或者 ChildCom3，count 数据都会增加\n\ndisplayName#\n\n如果安装了 React Developer Tools 工具，那么在 components\n选项卡中可以看到如下的组件树结构，默认的名字就为Context.Provider和Context.Consumer\n\n\n\n通过设置 displayName 可以修改显示名字，如下：\n\n\n\n默认值#\n\nContext 上下文环境可以设置默认值，如下：\n\n\n\n此时就不再需要 Provider 组件来提供数据了，子组件可以直接消费上下文环境的默认数据。\n\n多个上下文环境#\n\n在上面的示例中，我们示例的都是一个 Context 上下文环境，这通常也够用了，但是这并不意味着只能提供一个上下文环境，我们可以创建多个上下文环境，示例如下:\n\n\n\n首先，我们导出两个上下文环境，接下来在 App.jsx 中，使用多个 Provider 作为数据的提供者\n\n\n\n之后在 ChildCom2 中同样也可以使用多个 Consumer 来消费不同上下文中的数据\n\n\n\n> 如果重名回调里面 context 参数重名，就会根据最近的 context 读取\n\n\nContext 相关 Hook#\n\n在 React Hook API 中，为我们提供了一个更加方便的useContext钩子函数，该 Hook 接收一个由React.createContext\nAPI 创建的上下文对象，并返回该 context 的当前值。\n\n例如:\n\n\n\nuseContext(MyContext)相当于类组件中的static contextType =\nMyContext或者，但是我们仍然需要在上层组件树中使用来为下层组件提供 context 。","routePath":"/guide/react/advance/第一章/4-Context","lang":"","toc":[{"text":"Context","id":"context","depth":2,"charIndex":-1},{"text":"Context 要解决的问题","id":"context-要解决的问题","depth":3,"charIndex":194},{"text":"Context 的用法","id":"context-的用法","depth":3,"charIndex":699},{"text":"新版 API 使用","id":"新版-api-使用","depth":4,"charIndex":803},{"text":"displayName","id":"displayname","depth":4,"charIndex":1431},{"text":"默认值","id":"默认值","depth":4,"charIndex":1585},{"text":"多个上下文环境","id":"多个上下文环境","depth":4,"charIndex":1667},{"text":"Context 相关 Hook","id":"context-相关-hook","depth":3,"charIndex":1911}],"domain":"","frontmatter":{},"version":""},{"id":80,"title":"","content":"Render Props#\n\n在 React 中，代码复用的最基本单位就是组件，但是如果组件中也出现了重复的代码，该怎么做呢?\n\n那么我们需要通过某种方式将代码中公共的部分抽取出来，这些公共的部分就被称之为横切关注点 (Cross-Cutting Concern)\n\n在 React 中，常见有两种方式来进行横切关注点的抽离:\n\n * 高阶组件(HOC)\n * Render Props\n\nRender Props 实际上本身并非什么新语法，而是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术。\n\n有关Render Props，咱们主要需要掌握以下 2 个点:\n\n * 如何用?\n * 何时用?\n\n\n如何使用 Render Props#\n\n我们首先还是来看一个示例：\n\n\n\n\n\n\n\n在上面的代码中，App 根组件下渲染了两个子组件，这两个子组件一个是显示鼠标的位置，另外一个是根据鼠标位置显示一个跟随鼠标移动的小球。\n\n观察代码，你会发现这两个子组件内部的逻辑基本上是一模一 样的， 只是最终渲染的内容不一样， 此时我们就可以使用 Render Props\n对横切关注点进行一个抽离。\n\n方式也很简单，就是在一个组件中使用一个值为函数的 prop，函数的返回值为要渲染的视图。\n\n\n\n在上面的代码中，我们新创建了个 MouseMove 组件，该组件就封装了之前 ChildCom1 和 ChildCom2 组件的公共逻辑。该组件的 props\n接收一个名为 render 的参数，只不过该参数对应的值为一个函数，我们调用时将对应的状态和处理函数传递过去，该函数的调用结果为 返回一段视图。\n\n\n\n接下来在 App 根组件中，我们使用 MouseMove 组件，该组件上有一个 render 属性，对应的值就是函数，函数返回要渲染的组件。\n\n\n\n\n\n最后就是子组件 ChildCom1 和 ChildCom2 的改写，可以看到这两个子组件就只需要书写要渲染的视图了。公共的逻辑已经被 MouseMove\n抽取出去了。\n\n另外需要说明的是，虽然这个技巧的名字叫做 Render Props，但不是说必须要提供一个名为 render 的属性，事实上，封装公共逻辑的组件(例如上面的\nMouseMove ) 只要能够得到要渲染的视图即可，所以传递的方式可以有多种。\n\n例如:\n\n\n\n上面使用 MouseMove 组件时，并没有传递什么 render 属性，而是通过 props.children 的形式将要渲染的视图传递到了组件内部。\n\n在 MouseMove 组件内部，就不再是执行 render 方法了，而是应该执行 props.children，如下:\n\n\n\n\n何时使用 Render Props#\n\n我们发现上面的例子其实用高阶组件也能实现\n\n> 这里就不列举代码了，你可以自己尝试\n\n那么自然而然疑问就来了，什么时候使用 Render Props ?什么时候使用 HOC ?\n\n一般来讲， Render Props 应用于组件之间功能逻辑完全相同，仅仅是渲染的视图不同。这个时候我们可以通过 Render Props\n来指定要渲染的视图是什么。\n\n而 HOC 一般是抽离部分公共逻辑，也就是说组件之间有一部分逻辑相同，但是各自也有自己独有的逻辑，那么这个时候使用 HOC\n比较合适，可以在原有的组件的基础上做一个增强处理。","routePath":"/guide/react/advance/第一章/5-Render Props","lang":"","toc":[{"text":"Render Props","id":"render-props","depth":2,"charIndex":-1},{"text":"如何使用 Render Props","id":"如何使用-render-props","depth":3,"charIndex":315},{"text":"何时使用 Render Props","id":"何时使用-render-props","depth":3,"charIndex":1145}],"domain":"","frontmatter":{},"version":""},{"id":81,"title":"","content":"Portals#\n\nPortals 被翻译成传送门，它要做的事情实际上也确实和传送门很相似，根据官方的解释：\n\n> Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。\n\n其语法为：\n\n\n\n第一个参数 (child) 是任何可渲染的 React 子元素，第二个参数 (container) 是一个 DOM 元素。\n\n学习一个知识我们仍然是应该从以下 2 个点着手：\n\n * 何时使用？\n * 如何用？\n\n\n什么场景下需要使用 Portals#\n\n首先我们来看一个场景，如下：\n\n\n\n\n\n在上面的示例中，Modal 是一个模态框，在 App 根组件中能够控制该模态框组件是否显示。\n\n\n\n上面的示例，功能倒是没有什么问题，但是从最终渲染出来的 html 结构上来讲，将整个模态框都放在 root 这个 div 中不是那么合适，我们生成的 html\n结构上，这个模态框能够渲染到 modal 那个 div 里面。\n\n\n\n并且一旦父组件上面设置了额外的样式，都会影响这个子组件的渲染，例如：\n\n\n\n我们在 App 组件中添加一条相对定位的样式，此时我们就会发现由于 Modal 是放在整个 root 元素里面的，模态框的位置就会收到影响。\n\n\n\n因此，在这种时候，我们就可以使用 Portals 来解决这个问题。\n\n\n如何使用 Portals#\n\nPortals 的使用方式也非常简单，只需要使用createPortal方法来指定渲染到哪个元素中即可。需要注意的是这是和 React 渲染相关的，所以\ncreatePortal 方法来自于 react-dom 这个库。\n\n\n\n在上面的代码中，我们将要渲染的视图作为createPortal方法的第一个参数，而第二个参数用于指定要渲染到哪个 DOM 元素中。\n\n\n\n可以看到，这一次模态框就被渲染到了 id 为 modal 的 div 中。并且在 root 中所设置的样式都不会影响到模态框的显示。\n\n> 其实根据官方的介绍，Portals 的典型用例是当父组件有 overflow: hidden 或 z-index\n> 样式时，但你需要子组件能够在视觉上\"跳出\"其容器。例如，对话框、悬浮卡以及提示框。\n\n\n通过 Portals 进行事件冒泡#\n\n最后需要注意一下的就是使用 Portal 所渲染的元素在触发事件时的冒泡问题。\n\n以上面的例子为例，看上去模态框已经渲染到了 modal 这个元素里面，但是在 React\n中事件冒泡是按照组件结构来进行冒泡的，我们可以看到即使模态框已经渲染到了 modal 里面，但是在组件树中模态框组件仍然是在根组件中。\n\n\n\n我们也可以书写一个例子来验证一下，例如我们为 App 根组件绑定一个点击事件，如下:\n\n\n\n然后我们点击 Modal，会发现事件也被触发了\n\n> 官方解释：\n> \n> 尽管 portal 可以被放置在 DOM 树中的任何地方，但在任何其他方面，其行为和普通的 React 子节点行为一致。由于 portal 仍存在于\n> React 树，且与 DOM 树中的位置无关，那么无论其子节点是否是 portal,像 context 这样的功能特性都是不变的。\n> \n> 这包含事件冒泡。一个从 portal 内部触发的事件会一直冒泡至包含 React 树的祖先，即便这些元素并不是 DOM 树中的祖先。","routePath":"/guide/react/advance/第一章/6-Portals","lang":"","toc":[{"text":"Portals","id":"portals","depth":2,"charIndex":-1},{"text":"什么场景下需要使用 Portals","id":"什么场景下需要使用-portals","depth":3,"charIndex":218},{"text":"如何使用 Portals","id":"如何使用-portals","depth":3,"charIndex":571},{"text":"通过 Portals 进行事件冒泡","id":"通过-portals-进行事件冒泡","depth":3,"charIndex":942}],"domain":"","frontmatter":{},"version":""},{"id":82,"title":"","content":"错误边界#\n\n部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16引入了一个新的概念——错误边界。\n\n错误边界是一种React组件，这种组件可以捕获发生在其子组件树任何位置的 JavaScript 错 误，并打印这些错误，同时展示降级 UI\n，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。\n\n我们来看一个例子：\n\n\n\n\n\n\n\n\n\n在上面的代码中，我们整个组件树结构如下：\n\n\n\n可以看到，ChildCom1 下面的ChildCom3存在问题，这一个组件的问题会导致整个应用崩溃。\n\n这在某些场景下，实际上是没有必要的，例如有问题的组件是广告、或者些无关紧要的组件， 此时我们就期望渲染出问题组件以外的组件树。\n\n错误边界就是用来解决这个问题的。\n\n> 错误边界是一种 React 组件，这种组件可以捕获发生在其子组件树任何位置的 JavaScript\n> 错误，并打印这些错误，同时展示降级UI，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。\n\n如果一个class组件中定义了static getDerivedStateFromError()或\ncomponentDidCatch()这两个生命周期方法中的任意一个(或两个) 时，那么它就变成一个 错误边界。当抛出错误后，请使用static\ngetDerivedStateFromError()渲染备用UI，使用componentDidCatch()打印错误信息。\n\n\n\n然后我们给 ChildCom3 外面包裹一下这个组件\n\n\n\n然后我们就会发现页面不会崩溃了，ChildCom3的位置出现了我们降级 UI 渲染的东西\n\n\n\n在上面的代码中，我们就创建了一个错误边界组件，该组件有一个 getDerivedStateFromError 静态方法以及 componentDidCatch\n实例方法，这两个方法都会在组件渲染出错时调用，但是略有区别，具体的区别如下:\n\n * getDerivedStateFromError 静态方法\n   * 运行时间点：渲染子组件的过程中，发生错误之后，在更新页面之前（整个应用没有崩溃，直接渲染降级 UI）\n   * 注意：只有子组件发生错误，才会运行该函数\n   * 该函数返回一个对象，React 会将该对象的属性覆盖掉当前组件的 state\n   * 参数：错误对象\n   * 通常，该函数用于改变状态\n * componentDidCatch 实例方法\n   * 运行时间点：渲染子组件的过程中，发生错误，更新页面之后（整个应用已经崩溃，之后再重新渲染整个应用，当然会将有问题的UI渲染成降级UI），由于其运行时间\n     点比较靠后，因此不太会在该函数中改变状态\n   * 通常，该函数用于记录错误信息\n\n> 最佳实践，使用 static getDerivedStateFromError 渲染备用UI，使用 componentDidCatch 打印错误信息。\n\n最后需要注意的是，错误边界组件主要是用来捕获 UI 渲染时的错误，因此如下场景错误无法捕获：\n\n * 事件处理\n * 异步代码（例如 setTimeout 或者 requestAnimationFrame 回调函数\n * 服务端渲染\n * 它自身抛出来的错误(并非它的子组件)\n\n总之，错误边界组件仅能用于处理渲染子组件期间的同步错误。","routePath":"/guide/react/advance/第一章/7-错误边界","lang":"","toc":[{"text":"错误边界","id":"错误边界","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":83,"title":"","content":"组件渲染性能优化#\n\n在本小节，我们将会探讨组件在渲染时，如何优化渲染性能问题。\n\n涉及到的内容会包含 shouldComponentUpdate、PureComnent、 React.memo、 useMemo、 useCallback 等。\n\n\nshouldComponentUpdate 与 PureComnent#\n\nshouldComponentUpdate#\n\nshouldComponentUpdate 与 PureComnent 都与类组件相关，所以下面会以类组件来示例。\n\n\n\n在上面的代码中，我们书写了一个简单的计数器，按钮在点击的时候仍然是设置 counter 的值为 1，不过，虽然 counter\n的值没有变，整个组件仍然是重新渲染了的。显然，这一次渲染是没有必要的。\n\n此时，我们就可以使用 shouldComponentUpdate 来进行优化。\n\n\n\n这边有个功能函数用来浅层比较两个对象是否相等\n\n\n\n这样再次点击控制台就不会输出 App 渲染了\n\n> 官方：此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent\n> 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state\n> 进行浅层比较，并减少了跳过必要更新的可能性。\n\nPureComponent#\n\nReact.PureComponent 与 React.Component 很相似。\n\n两者的区别在于React.Component 并未实现 shouldComponentUpdate()，而React.PureComponent中以浅层对比\nprop 和 state 的方式来实现了该函数。\n\n如果赋予 React 组件相同的 props 和 state，render() 函数会渲染相同的内容，那么在某些情况下使用React.PureComponent\n可提高性能。\n\n同样的示例，只改一个地方\n\n\n\n值得注意的是，React.PureComponent 中的 shouldComponentUpdate()\n仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。\n\n仅在你的 props 和 state 较为简单时，才使用React.PureComponent ，或者在深层数据结构发生变化时调用 forceUpdate()\n来确保组件被正确地更新。你也可以考虑使用 immutable 对象加速嵌套数据的比较。\n\n比如下面的例子\n\n\n\n我点击后 push 了值进去，应该视图上要显示王五，但并没有显示\n\n\n\n通过 React 插件工具查看，发现 push 进去了\n\n\n\n为什么视图没有更新呢？\n\n究其原因，是因为数组的地址并没有发生更改，而是数组内部发生的更改，但是 PureComponent\n是浅比较，会认为数组并没有发生更改，因此不会进行渲染更新。(如果使用 Component 则是没有问题的，因为 React.Component 并未实现\nshouldComponentUpdate)\n\n当然我们可以解决这个问题：返回一个新的数组，而不是把原数组赋值给 stu\n\n\n\n\nReact.memo#\n\nshouldComponentUpdate 与 PureComnent 主要是优化类组件的渲染性能，那么如果是函数组件该怎么办呢?\n\n> 函数组件没有上面类组件中设置 state 为一个值进行重新渲染的问题，这是和类组件的不同，具体的原因在后面再讲解\n\n在 React 中，为我们提供了 React.memo，文档地址：React.memo\n\n这是一个高阶组件，如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo\n中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。\n\n来看一个例子:\n\n\n\n\n\n当我们点击 ChildCom 里的+1 时，两个都渲染，这是对的，因为 ChildCom 用的是 App 里的设置的状态。但我们点击 App 的+1\n时，会发现两个也都渲染，因为 App 整体都渲染，自然包括子组件 ChildCom 了。\n\n但我们只改变了 App 的 counter1，传给 ChildCom 的是 counter2，所以 ChildCom 应该不渲染才对，这里就可以通过\nReact.memo 进行优化了\n\n\n\n之后我们再更新 counter1 时，由于传递给子组件的 counter2 这个 props 属性并没有变化，因此子组件不会更新。\n\n注意：默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。\n\n举个例子：\n\n\n\n\n\n这个例子和我们之前的 PureComponent 所组的例子很相似，由于是在原来的数组上面进行的修改，数组的地址并没有发生变化，因此 React.memo\n返回的组件并不会更新。\n\n> 实际上 React.memo 的源码就是返回一个 PureComponent 组件：\n\n此时要解决这个问题也很简单，和前面一样，直接返回一个新的数组，例如：\n\n\n\n另外，在使用 React.memo 的时候还支持传入第二个自定义的比较函数参数，例如:\n\n\n\n\nuseCallback#\n\n正常情况下，如果组件各自内部维护自己的数据，那么组件更新的时候相互并不会影响，例如: App 根组件对应样式：\n\n\n\nApp 根组件，引入了 ChildCom1 和 ChildCom2 这两个子组件：\n\n\n\n\n\n\n\n在上面的代码中，我们还向两个子组件传入了一个 test 函数，由于每次 App 组件的重新渲染会生成新的 test 函数，所以对于两个子组件来讲传入的 test\n导致 props 不同所以都会重新渲染。\n\n此时就可以使用 useCallback 来解决这个问题，语法如下:\n\n\n\n把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的memoized 版本，该回调函数仅在某个依赖项改变时才会更新。\n\n接下来我们来使用 useCallback 优化上面的问题，对 App.jsx 做如下的修改:\n\n\n\n在上面的代码中，我们对 test 函数做了缓存，从而保证每次传入到子组件的这个 props 和之前是相同的。\n\n> useCallbak 主要就是对函数进行缓存\n\n\nuseMemo#\n\n最后要介绍的是 useMemo，其语法如下：\n\n\n\n主要用于返回一个 memoized 值，文档地址: useMemo\n\n某些时候，组件中某些值需要根据状态进行一个二次计算(类似于 Vue\n中的计算属性)，由于函数组件一旦重新渲染，就会重新执行整个函数，这就导致之前的二次计算也会重新执行一次，例如：\n\n\n\n在上面的示例中，文本框的输入会导致整个 App 组件重新渲染，导致 getNum 函数一直被调用。但是 count 的值是没有改变的，所以 getNum\n这个函数也是没有必要重新执行的。\n\n> 用 useCallback 是没用的，因为每次渲染都要去调用这个函数，所以还是会执行\n\n我们换成 useMemo，来优化它：\n\n\n\n在上面的示例中，我们使用了useMemo 来缓存二次计算的值，并设置了依赖项 count,只有在 count 发生改变时，才会重新执行二次计算。\n\n\nuseMemo 和 useCallback 的区别和使用场景#\n\nuseMemo 和 useCallback 接收的参数都是一样，第一个参数为回调函数，第二个参数为要依赖的数据。\n\n共同的作用：只有依赖的数据发生变化，才会重新计算结果，起到了缓存的效果。\n\n两者的区别：\n\n * useMemo 计算结果是 return 回来的值，主要用于缓存计算结果的值，应用场景如：需要进行二次计算的状态\n * useCallback 计算结果是函数，主要用于缓存函数，应用场景如 需要缓存起来的函数，因为函数式组件每次任何一个 state\n   的变化，整个组件都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能和减少资源浪费。","routePath":"/guide/react/advance/第一章/8-组件渲染性能优化","lang":"","toc":[{"text":"组件渲染性能优化","id":"组件渲染性能优化","depth":2,"charIndex":-1},{"text":"shouldComponentUpdate 与 PureComnent","id":"shouldcomponentupdate-与-purecomnent","depth":3,"charIndex":124},{"text":"shouldComponentUpdate","id":"shouldcomponentupdate","depth":4,"charIndex":162},{"text":"PureComponent","id":"purecomponent","depth":4,"charIndex":612},{"text":"React.memo","id":"reactmemo","depth":3,"charIndex":1397},{"text":"useCallback","id":"usecallback","depth":3,"charIndex":2266},{"text":"useMemo","id":"usememo","depth":3,"charIndex":2737},{"text":"useMemo 和 useCallback 的区别和使用场景","id":"usememo-和-usecallback-的区别和使用场景","depth":3,"charIndex":3139}],"domain":"","frontmatter":{},"version":""},{"id":84,"title":"","content":"前端框架的理解#\n\n> 问题：谈一谈你对前端框架的理解？\n\n什么是前端框架？首先我们需要划定边界：\n\n * React 或者 Vue 究竟是库（library）还是框架（framework）？\n\n实际上，无论是 React 也好，还是 Vue 也好，他们的核心是 \"构建 UI 的库\"，提供了如下的功能：\n\n * 基于状态的声明式渲染\n * 提供组件化开发\n\n比如 React 官方文档的首页就是如图：\n\n\n\n当应用进一步的扩展，从简单的页面升级为了 SPA，此时意味着需要前端要有前端路由方案，React 阵营有 React-router, Vue 阵营有了\nVue-router,有了这些前端路由库。\n\n随着应用复杂度的进一步提升，组件的数量越来越多，状态管理越来越复杂，因此就需要状态管理的库，React 阵营有\nredux、react-redux，zustand，jotai 等，vue 阵营有 vuex、pinia\n\n我们发现，除了上面提到这些功能以外，还有很多其他的功能(构建支持、数据流方案、文档工具)，React 和 Vue 本身其实不支持的，所以说 React 和\nVue 本身只是专注于 UI 的渲染（构建 UI），因此我们可以将\"React 或者 Vue\n本身以及其他附加功能或者说和它相关的生态\"，整个一起的解决方案称之为框架（技术栈）\n\n比如下面的例子：\n\n * UmiJS 是一个框架，基于 React、内置路由、构建、部署等功能\n * NextJS 是一个框架，基于 React、支持 SSR、SSG 两大功能的服务端框架\n\n在平时我们经常能够听到\"React 框架、Vue 框架”这样的说法，这个时候所指的 React 或者 Vue 往往指的是整个 React、Vue\n本身以及它们周边的生态产品，算是一种约定俗成的说法。\n\n现代前端框架至少包含以下几个方面：\n\n * 基于状态的声明式渲染\n * 提供组件化开发（复用）\n * 前端路由方案\n * 状态管理方案\n\n\n问题解答#\n\n问题：谈一谈你对前端框架的理解？\n\n解答：\n\n在早期使用 jQuery 时代，那时的开发人员需要手动的去操作 DOM 节点，那个时候流行的还是 MPA 的模式，各个页面的 JS 代码量还在能够接收的范围。\n\n但是随着单页应用的流行，客户端的 JS 代码量出现井喷，此时如果还是采用传统的手动操作 DOM 的方式，对于开发人员来讲有非常大的心智负担。\n\n此时就出现了能够基于状态声明式渲染以及提供组件化开发模式的库，例如 Vue 和 React。这两者本质上仅仅是构建 UI\n的库，但是随着应用的复杂度的提升，还需要前端路由方案、状态管理方案，所以有了\nvue-router、react-router、vuex、redux、zustand、pinia 等周边生态产品。\n\nVue 或 React 和周边生态产品共同构成了一个技术栈，现在我们会将 React 或者 Vue 称之为框架，这可以算是一种约定俗成的说法。\n\n一款现代前端框架，在它本身以及它的周边生态中，至少要包含以下几个方面:\n\n * 基于状态的声明式渲染\n * 提供组件化开发（复用）\n * 前端路由方案\n * 状态管理方案","routePath":"/guide/react/advance/第二章/1-前端框架的理解","lang":"","toc":[{"text":"前端框架的理解","id":"前端框架的理解","depth":2,"charIndex":-1},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":848}],"domain":"","frontmatter":{},"version":""},{"id":85,"title":"","content":"React 和 Vue 描述页面的区别#\n\n> 问：React 和 Vue 是如何描述 UI 界面的？有一些什么样的区别？\n\n标准且浅显的回答：\n\n> React 中使用的是 JSX，Vue 中使用的是模板来描述界面\n\n前端领域经过长期的发展，目前有两种主流的描述 UI 的方案：\n\n * JSX\n * 模板\n\n\nJSX 历史来源#\n\nJSX 最早起源于 React 团队在 React 中所提供的一种类似于 XML 的 ES 语法糖:\n\n\n\n经过 Babel 编译之后，就会变成：\n\n\n\n无论在 17 版本之前还是 17 版本之后，执行代码会得到一个对象：\n\n\n\n> 这个其实就是虚拟 DOM\n\nReact 团队认为，UI 本质上和逻辑是有耦合部分的：\n\n * 在 UI 上面绑定事件\n * 数据变化后通过 JS 去改变 UI 的样式或者结构\n\n作为一个前端工程师，JS 是用得最多，所以 React 团队思考屏蔽 HTML,整个都用 JS 来描述 UI,因为这样做的话，可以让 UI\n和逻辑配合得更加紧密，所以最终设计出来了类 XML 形式的 JS 语法糖\n\n由于 JSX 是 JS 的语法糖(本质上就是 JS)，因此可以非常灵活的和 JS 语法组合使用，例如:\n\n * 可以在 if 或者 for 当中使用 jsx\n * 可以将 jsx 赋值给变量\n * 可以将 jsx 当作参数来传递，当然也可以在一个函数中返回一段 jsx\n\n\n\n这种灵活性就使得 jsx 可以轻松的描述复杂的 UI，如果和逻辑配合，还可以描述出复杂 UI 的变化。\n\n使得 React\n社区的早期用户可以快速实现各种复杂的基础库，丰富社区生态。又由于生态的丰富，慢慢吸引了更多的人来参与社区的建设，从而源源不断的形成了一个正反馈。\n\n\n模板的历史来源#\n\n模板的历史就要从后端说起。\n\n在早期前后端未分离的时候，最流行的方案就是使用模板引擎，模板引擎可以看作是在正常的 HTML\n上面进行挖坑(不同的模板引擎语法不一样)，挖了坑之后，服务器端会将数据填充到挖了坑的模板里面，生成对应的 html 页面返回给客户端。\n\n所以在那个时期前端人员的工作，主要是 html、css 和一些简单的 js 特效(轮播图、百叶...)， 写好的 html\n是不能直接用的，需要和后端确定用的是哪一个模板引擎，接下来将自己写好的 html 按照对应模板引擎的语法进行挖坑\n\n不同的后端技术对应的有不同的模板引擎，甚至同- 种后端技术，也会对应很多种模板引擎，例如:\n\n * Java (JSP、Thymeleaf、Velocity、Freemarker)\n * PHP (Smarty、Twig、HAML、Liquid、Mustache、Plates)\n * Python (pyTenjin、Tornado.templote、Pylade、Mako、Jinja2)\n * node.js(Jade、Ejs、art-template、handlebars、mustache、swig、doT)\n\n比如 EJS 模板引擎\n\n\n\n这些模板弓|擎对应的模板语法就和 Vue 里面的模板非常的相似。\n\n现在随着前后端分离开发的流行，已经没有再用模板引擎的模式了，\n\n后端开发人员只需要书写数据接口即可。但是如果让一个后端人员来开发前端的代码，那么 Vue 的模板语法很明显对后端来讲更加熟悉\n\n最后我们做一个总结，虽然现在前端存在两种方式: JSX 和模板的形式都可以描述 UI，但是出发点是不同\n\n模板语法的出发点是，既然前端框架使用 HTML 来描述 UI，那么我们就扩展 HTML ，让 HTML 中能够描述一定程度的逻辑，也就是“从 UI 出发，扩展\nUI，在 UI 中能够描述逻辑\"。\n\nJSX 的出发点，既然前端使用 JS 来描述逻辑，那么就扩展 JS，让 JS 也能描述 UI，也就是“从逻辑出发，扩展逻辑，描述 UI\"。\n\n\n问题解答#\n\n问：React 和 Vue 是如何描述 UI 界面的？有一些什么样的区别？\n\n解答：\n\n在 React 中，使用 JSX 来描述 UI。因为 React 团队认为 UI 本质上与逻辑存在耦合的部分，所为前端工程师，JS 是用的最多的，如果同样使用\nJS 来描述 UI，就可以让 UI 和逻辑配合的更密切。\n\n使用 JS 来描述页面，可以更加灵活，主要体现在:\n\n * 可以在 if 语句和 for 循环中使用 JsX\n * 可以将 JSX 赋值给变量\n * 可以把 JSX 当作参数传入，以及在函数中返回 JSX\n\n而模板语言的历史则需要从后端说起。早期在前后端未分离时代，后端有各种各样的模板引擎，其本质是扩展了 HTML，在 HTML\n中加入逻辑相关的语法，之后在动态的填充数据进去。如果单看 Vue 中的模板语法，实际上和后端语言中的各种模板引擎是非常相似的。\n\n总结起来就是:\n\n模板语法的出发点是，既然前端框架使用 HTML 来描述 UI，那么我们就扩展 HTML ，让 HTML 中能够描述一定程度的逻辑，也就是“从 UI 出发，扩展\nUI，在 UI 中能够描述逻辑\"。\n\nJSX 的出发点，既然前端使用 JS 来描述逻辑，那么就扩展 JS，让 JS 也能描述 UI，也就是“从逻辑出发，扩展逻辑，描述 UI\"。\n\n虽然这两者都达到了同样的目的，但是对框架的实现产生了不同的影响。","routePath":"/guide/react/advance/第二章/2-React 和 Vue 描述页面的区别","lang":"","toc":[{"text":"React 和 Vue 描述页面的区别","id":"react-和-vue-描述页面的区别","depth":2,"charIndex":-1},{"text":"JSX 历史来源","id":"jsx-历史来源","depth":3,"charIndex":156},{"text":"模板的历史来源","id":"模板的历史来源","depth":3,"charIndex":756},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":1647}],"domain":"","frontmatter":{},"version":""},{"id":86,"title":"","content":"前端框架的分类#\n\n> 问：现代前端框架不仅仅是React、Vue,还出现了像Svelte、Solid.js 之类的框架，你觉得这些新框架相比React、Vue有什么样的区别?\n\n\n自变量和因变量#\n\n现代前端框架，有一个非常重要的特点，那就是基于状态的声明式渲染。如果要概括的话，可以使用一个公式:\n\n> UI = f (state)\n\n * state：当前视图的一个状态\n * f：框架内部的一个运行机制\n * UI：宿主环境的视图描述\n\nstate的变化会导致最终计算出来的 UI 发生变化，所以 state 是自变量，UI 就是因变量\n\n目前在 React 中有很多 Hook，例如：\n\n\n\n比如上面的代码，我们就是定义了一个自变量\n\n\n\n上面的 useState 这个 hook 可以看作是定义了一个自变量，自变量一变化，就会到导致依赖它的因变量发生变化，在上面的例子中，返回的 jsx 所描述的\nUI 就是因变量。\n\n因变量又可以分为两类：\n\n * 没有副作用的因变量\n * 有副作用的因变量\n\n没有副作用的因变量\n\n在 React 中，useMemo就是定义一个没有副作用的因变量\n\n\n\n在上面的代码中，我们使用 useMemo 定义了一个没有副作用的因变量y，y的值取决于x的值，x的值一变化，y的值也会跟着变化\n\n有副作用的因变量\n\n在 React 中，可以使用 useEffect 来定义一个有副作用的因变量\n\n\n\n上面的代码依赖于自变量x的变化，当x发生变化的时候，会修改页面的标题，这就是一个副作用操作。\n\n那么接下来，我们来总结一下：自变量的变化，会导致三种情况的因变量发生改变:\n\n * 自变量的变化，导致UI因变量变化\n\n\n\n * 自变量的变化，导致无副作用的因变量发生变化\n\n\n\n * 自变量的变化，导致有副作用的因变量发生变化\n\n\n\n\n框架的分类#\n\n上面我们介绍了自变量和因变量，state 实际上就是自变量，自变量的变化直接或者间接的改变了 UI，上面的公式实际上还可以分为两个\n\n * 根据自变量 state 计算出 UI 的变化\n * 根据 UI 的变化执行具体的宿主环境的 API\n\n以前端工程师最熟悉的浏览器为例，那么第二个步骤就是执行DOM相关API，对于这个步骤来讲，不同的框架实际上实现基本是相同的，这个步骤不能作为框架分类的依据，差别\n主要体现在步骤一上面。所以步骤一也是针对各大框架的一个分类依据\n\n前端框架需要关注自变量和x (UI、\n组件、应用)的对应关系，随着x的抽象层级不断下降，自变量到UI变化的路径条数就会增多。路径越多，则意味着前端框架在运行时消耗在“寻找自变量与UI对应关系\"上面的\n时间越少。\n\n根据上面的特点，就可以对现代前端框架分为三大类：\n\n * 元素级框架\n * 组件级框架\n * 应用级框架\n\n以常见的前端框架React为例，它属于应用级框架，Vue属于组件级框架，而新的Svelte、Solid.js属于元素级别框架\n\n\n问题解答#\n\n题目：现代前端框架不仅仅是React、Vue,还出现了像Svelte、Solid.js 之类的框架，你觉得这些新框架相比React、Vue有什么样的区别?\n\n解答：\n\n所有的现代前端框架，都有一个非常重要的特点，那就是“基于状态的声明式渲染”。概括成一个公式的话，那就是UI = f (state)\n\n这里有一点类似于自变量与因变量之间的关系。例如在上面的公式中，state 就是一个自变量，state 的变化会导致 UI 这个因变量发生变化。\n\n不同的框架，在根据自变量(state) 的变化计算出UI的变化这一步骤有所区别，自变量和x (应用、 组件、UI)\n的对应关系，随着x抽象的层级不断下降，\"自变量到UI变化”的路径则不断增多。路径越多，则意味着前端框架在运行时消耗在寻找”自变量与 UI\n的对应关系\"上的时间越少。\n\n以“与自变量建立对应关系的抽象层级\"可以作为其分类的依据，按照这个标准，前端框架可以分为以下三类:\n\n * 元素级框架\n * 组件级框架\n * 应用级框架\n\n以常见的前端框架为例，React 属于应用级框架，Vue属于组件级框架，Svelte、 Solid.jis 属于元素级框架。","routePath":"/guide/react/advance/第二章/3-前端框架的分类","lang":"","toc":[{"text":"前端框架的分类","id":"前端框架的分类","depth":2,"charIndex":-1},{"text":"自变量和因变量","id":"自变量和因变量","depth":3,"charIndex":90},{"text":"框架的分类","id":"框架的分类","depth":3,"charIndex":785},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":1254}],"domain":"","frontmatter":{},"version":""},{"id":87,"title":"","content":"虚拟 DOM#\n\n> 什么是虚拟DOM？其优点有哪些？\n\n虚拟DOM 最早是由React团队提出来的，因此React团队在对虚拟DOM的定义上有着如下\n\n> 官网：虚拟DOM\n\nVirtual DOM是一种编程概念。在这个概念里，UI 以一种理想化的，或者说\"虚拟的\"表现形式被保存于内存中。\n\n也就是说，只要我们有一种方式，能够将真实DOM的层次结构描述出来，那么这就是一个虚拟DOM。\n\n在React中，React 团队使用的是 JS 对象来对DOM结构进行一个描述。但是很多人会直接把JS对象和虚拟DOM划等号，这种理解是不太准确的，比较片面的。\n\n虛拟DOM和JS对象之间的关系：前者是一种思想，后者是一种思想的具体实现\n\n\n为什么需要虚拟 DOM#\n\n使用虚拟 DOM 主要有两个方面的优势：\n\n * 相较于 DOM 的体积优势和速度优势\n\n> 这里的速度优势并不全面，因为虚拟DOM是通过比较差异来减少对实际DOM的访问，以提高性能，在一些场景中其实直接操作DOM更高效，但在复杂UI变化中，心智负担\n> 严重\n\n * 多平台的渲染抽象能力\n\n相较于 DOM 的体积优势和速度优势\n\n首先我们需要明确一个点，JS 层面的计算速度要比DOM层面的计算要快:\n\n * DOM对象最终要被浏览器渲染出来之前，浏览器会有很多工作要做(浏览器的渲染原理)\n * DOM对象上面的属性也非常非常多\n\n比如这两行代码，可以直接浏览器控制台运行一下看看：\n\n\n\n操作JS对象的时间和操作DOM对象的时间是完全不一样的。\n\nJS层面的计算速度要高于DOM层面的计算速度。\n\n\n\n此时有一个问题：虽然使用了 JS 对象来描述 UI，但是最终不还是要用原生 DOM API 去操作 DOM 么?\n\n虛拟 DOM在第一次渲染页面的时候， 并没有什么优势，速度肯定比直接操作原生 DOM API 要慢一些，虚拟 DOM真正体现优势是在更新阶段。\n\n根据React团队的研究，在更新页面时，相比使用原生 DOM API，开发人员更加倾向于使用 innerHTML\n\n\n\n\n\n因此在使用 innerHTML 的时候，就涉及到了两个层面的计算:\n\n * JS 层面：解析字符串\n * DOM 层面：创建对应的 DOM 节点\n\n接下来我们加入虚拟 DOM 来进行对比\n\n           INNERHTML      虚拟 DOM\nJS 层面计算    解析字符串          创建 JS 对象\nDOM 层面计算   创建对应的 DOM 节点   创建对应的 DOM 节点\n\n虚拟 DOM 真正发挥威力的时候，是在更新阶段\n\ninnerHTML进行更新的时候，要全部重新赋值，这意味着之前创建的DOM节点需要全部销毁掉，然后重新进行创建，但是虚拟DOM只需要更新必要的DOM节点即可\n\n           INNERHTML        虚拟 DOM\nJS 层面计算    解析字符串            创建 JS 对象\nDOM 层面计算   销毁原来所有的 DOM 节点   修改必要的 DOM 节\nDOM 层面计算   创建对应的 DOM 节点     \n\n多平台的渲染抽象能力\n\n虚拟 DOM 只是多真实 UI 的一个描述，根据不同的宿主环境，可以执行不同的渲染代码：\n\n * 浏览器、Node.js宿主环境使用 ReactDOM 包\n\n * Native宿主环境使用 ReactNative 包\n\n * Canvas, SVG或者VML (IE8) 宿主环境使用 ReactArt 包\n\n * ReactTest包用于渲染出 JS 对象，可以很方便地测试\"不隶属于任何宿主环境的通用功能\"\n\n\nReact 中的虚拟 DOM#\n\n在 React 中通过 JSX 来描述 UI, JSX最终会被转为一个叫做 createElement 方法的调用，调用该方法后就会得到虚拟DOM对象。\n\n经过 Babel 编译过后结果如下：在线Babel工具地址\n\n\n\n在源码中 createElement 方法如下：\n\n\n\n在上面的代码中，最终返回的element对象就是我们所说的虚拟DOM对象。在官方文档中，官方更倾向于将这个对象称之为React元素\n\n\n问题解答#\n\n问：什么是虚拟DOM？其优点有哪些？\n\n答：\n\n虚拟 DOM 最初是由 React 团队所提出的概念，这是一种编程的思想，指的是针对真实UI DOM 的一种描述能力。\n\n在React中，使用了 JS 对象来描述真实的 DOM 结构。虚拟 DOM 和 JS 对象之间的关系：前者是一种思想，后者是这种思想的具体实现。\n\n使用虚拟DOM有如下的优点:\n\n * 相较于DOM的体积和速度优势\n\n * 多平台渲染的抽象能力\n\n相较于 DOM 的体积和速度优势\n\n * JS 层面的计算的速度， 要比DOM层面的计算快得多 。DOM对象最终要被浏览器显示出来之前，浏览器会有很多工作要做(浏览器渲染原理)\n   。DOM上面的属性也是非常多的\n * 虚拟DOM发挥优势的时机主要体现在更新的时候，相比较innerHTML要将已有的DOM节点全部销毁，虚拟DOM能够做到针对DOM节点做最小程度的修改\n\n多平台渲染的抽象能力\n\n * 浏览器、Node.js宿主环境使用 ReactDOM 包\n\n * Native宿主环境使用 ReactNative 包\n\n * Canvas、 SVG或者VML (IE8) 宿主环境使用 ReactArt 包\n\n * ReactTest包用于渲染出JS对象，可以很方便地测试\"不隶属于任何宿主环境的通用功能”\n\n在React中，通过JSX来描述UI, Jsx 仅仅是个语法糖， 会被Babel 编译为createElement 方法的调用。\n该方法调用之后会返回一个JS对象，该对象就是虚拟DOM对象，官方更倾向于称之为一个React 元素。","routePath":"/guide/react/advance/第二章/4-虚拟DOM","lang":"","toc":[{"text":"虚拟 DOM","id":"虚拟-dom","depth":2,"charIndex":-1},{"text":"为什么需要虚拟 DOM","id":"为什么需要虚拟-dom","depth":3,"charIndex":316},{"text":"React 中的虚拟 DOM","id":"react-中的虚拟-dom","depth":3,"charIndex":1548},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":1772}],"domain":"","frontmatter":{},"version":""},{"id":88,"title":"","content":"React 整体架构#\n\n> 问：是否了解过 React 的新架构？新的 Fiber 架构相较于之前的 Stack 架构有什么优势？\n\n浅显的回答：\n\n> Stack架构在进行虚拟DOM树比较的时候，采用的是递归，计算会消耗大量的时间，新的Fiber架构采用的是链表，可以实现时间切片，防止JS的计算占用过多的时\n> 间从而导致浏览器出现丢帧的现象。\n\nReact v15 以及之前的架构称之为 Stack 架构，从 v16 开始，React 重构了整体的架构，新的架构被称之为 Fiber\n架构，新的架构相比旧架构有一个最大的特点就是能够实现时间切片。\n\n * 旧架构的问题？\n * 新架构的解决思路\n\n\n旧架构的问题#\n\n> React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式\n\n有哪些情况会导致我们的Web应用无法快速响应?\n\n总结起来，实际上有两大类场景会限制快速响应:\n\n * 当你需要执行大量计算或者设备本身的性能不足的时候，页面就会出现掉帧、卡顿的现象，这个本质上是来自于 CPU 的瓶颈\n * 进行 I/O 的时候，需要等待数据返回后再进行后续操作，等待的过程中无法快速响应，这种情况实际上是来自于 I/O 的瓶颈\n\nCPU 瓶颈#\n\n平时我们在浏览网页的时候，这张网页实际上是由浏览器绘制出来的，就像一个画家画画一样\n\n平时我们所浏览的网页，里面往往会有一些动起来的东西，比如轮播图、百叶窗之类的，本质其实就是浏览器不停的在进行绘制。\n\n目前，大多数设备的刷新频率为60FPS,意味着1秒钟需要绘制60次，1000ms / 60= 16.66ms，也就是说浏览器每隔 16.66ms\n就需要绘制一帧。\n\n浏览器在绘制一帧画面的时候，实际上还有很多的事情要做（浏览器渲染原理）\n\n\n\n绘制画面的任务被称之为“渲染流水线”，每次执行流水线的时候，大致是需要如上的一些步骤，但是并不是说每一次所有的任务都需要全部执行：\n\n * 当通过 JS 或者 CSS 修改 DOM 元素的几何属性(比如长度、 宽度)时，会触发完整的渲染流水线，这种情况称之为重排(回流)\n * 当修改的属性不涉及几何属性(比如字体、颜色)时，会省略掉流水线中的Layout、Layer 过程，这种情况称之为重绘\n * 当修改\"不涉及重排、重绘的属性(比如 transform\n   属性)\"时，会省略流水线中Layout、Layer、Print过程，仅执行合成线程的绘制工作，这种情况称之为合成\n\n按照性能高低进行排序的话：合成>重绘>重排\n\n前面说过，浏览器绘制的频率是16.66ms 一帧，但是执行 JS\n与渲染流水线实际上是在同一个线程上面执行，也就意味着如果JS执行的时间过长，不能够及时的渲染下一帧，也就意味着页面掉帧，表现出来的现象就是页面卡顿\n\n在React v15 之前就存在这个问题，JS 代码执行的时间过长。在 React 中，需要去计算整颗虚拟 DOM 树，虽然说是 JS 层面的计算，相比直接操作\nDOM，节省了很多时间，但是每次重新去计算整颗虚拟 DOM 树，会造成每一帧的 JS\n代码的执行时间过长，从而导致动画、还有一些实时更新得不到及时的响应，造成卡顿的视觉效果。\n\n在 React v16 版本之前，进行两颗虚拟 DOM\n树的对比的时候，需要涉及到遍历上面的结构，这个时候只能使用递归，而且这种递归是不能够打断的，一条路走到黑，从而造成了 JS 执行时间过长。\n\n这样的架构模式，官方就称之为 Stack 架构模式，因为采用的是递归，会不停的开启新的函数栈。\n\nI/O 瓶颈#\n\n对于前端开发来讲，最主要的 I/O 瓶颈就是网络延迟。\n\n网络延迟是一种客观存在的现象，那么如何减少这种现象对用户的影响呢? React团队给出的答案是:将人机交互的研究成果整合到UI中。\n\n用户对卡顿的感知是不一样的，输入框哪怕只有轻微的延迟，用户也会认为很卡，假设是加载一个列表，哪怕 loading 好几秒，用户也不会觉得卡顿\n\n对于React来讲，所有的操作都是来自于自变量的变化导致的重新渲染，我们只需要针对不同的操作赋予不同的优先级即可。\n\n具体来说，主要包含以下三个点:\n\n * 为不同操作造成的\"自变量变化\"赋予不同的优先级\n * 所有优先级统一调度，优先处理\"最高优先级的更新\"\n * 如果更新正在进行(进入虚拟DOM 相关工作)，此时有\"更高优先级的更新\"产生的话，中段当前的更新，优先处理高优先级更新\n\n要实现上面的这三个点，就需要 React 底层能实现:\n\n * 用于调度优先级的调度器\n * 调度器对应的调度算法\n * 支持可中断的虚拟 DOM 的实现\n\n所以不管是解决 CPU 的瓶颈还是 I/O 的瓶颈，底层的诉求都是需要实现 time slice(时间切片)\n\n\n新架构的解决思路#\n\n解决 CPU 瓶颈#\n\n从 React v16 开始，官方团队正式引用了 Fiber 的概念，这是一种通过链表来描述 UI 的方式，本质上你也可以看作是一种虚拟 DOM的实现\n\n> 与其将\"Virtual\n> DOM\"视为一种技术，不如说它是一种模式，一种编程概念。人们提到它时经常是要表达不同的东西。在React的世界里，术语\"Virtual\n> DOM\"通常与React元索关联在一起，因为它们都是代表了用户界面的对象。而React也使用一个名为\"fibers\"的内部对象来存放组件树的附加信息。上述二\n> 者也被认为是React中\"Virtual DOM\"实现的一部分。\n\nFiber 本质上也是一个对象，但是和之前 React 元素不同的地方在于对象之间使用链表的结构串联起来，child 指向子元素，sibling\n指向兄弟元素，return 指向父元素。\n\n如下图：\n\n\n\n使用链表这种结构，有一个最大的好处就是在进行整颗树的对比(reconcile) 计算时，这个过程是可以被打断。\n\n在发现一帧时间已经不够，不能够再继续执行JS,需要渲染下一帧的时候，这个时候就会打断 JS 的执行，优先渲染下一帧。渲染完成后再接着回来完成上一次没有执行完的\nJS 计算。\n\n官方还提供了一个 Stack 架构和 Fiber 架构的对比示例: 对比实例网址\n\n两个案例打开后你会发现 Stack 架构一卡一卡的，而 Fiber 非常流畅\n\n下面是 React 源码中创建 Fiber 对象的相关代码：\n\n\n\n解决 I/O 瓶颈#\n\n从React v16 开始引入了 Scheduler (调度器)，用来调度任务的优先级。\n\nReact v16之前：\n\n * Reconciler (协调器) : vdom的实现，根据自变量的变化计算出UI的变化\n * Renderer (渲染器) ：负责将UI的变化渲染到宿主环境\n\n从Reactv16开始，多了一个组件：\n\n * Scheduler (调度器) :调度任务的优先级，高优先级的任务会优先进入到Reconciler\n * Reconciler (协调器) : vdom的实现，根据自变量的变化计算出UI的变化\n * Renderer (渲染器) :负责将UI的变化渲染到宿主环境\n\n新架构中，Reconciler 的更新(计算)流程也从之前的递归变成了\"可中断的循环过程\"。\n\n\n\n每次循环都会调用 shouldYield 判断当前的时间切片是否有足够的剩余时间，如果没有足够的剩余时间，就暂停 reconciler\n的执行，将主线程还给渲染流水线，进行下一帧的渲染操作，渲染工作完成后，再等待下一个宏任务进行后续代码的执行。\n\n\n问题解答#\n\n问：是否了解过 React 的架构?新的 Fiber 架构相较于之前的 Stack 架构有什么优势?\n\n答：\n\nReact v15及其之前的架构：\n\n * Reconciler (协调器) : VDOM 的实现，负责根据自变量变化计算出UI变化\n * Renderer (渲染器) :负责将UI变化渲染到宿主环境中\n\n这种架构称之为 Stack 架构，在 Reconciler 中，mount 的组件会调用mountComponent，update 的组件会调用\nupdateComponent，这两个方法都会递归更新子组件，更新流程一旦开始，中途无法中断。\n\n但是随着应用规模的逐渐增大，之前的架构模式无法再满足\"快速响应\"这一需求， 主要受限于如下两个方面:\n\n * CPU瓶颈：由于 VDOM 在进行差异比较时，采用的是递归的方式，JS计算会消耗大量的时间，从而导致动画、还有一些需要实时更新的内窗产生视觉上的卡顿。\n * I/O瓶颈：由于各种基于\"自变量”\"变化而产生的更新任务没有优先级的概念，因此在某些更新任务(例如文本框的输入)有稍微的延迟，对于用户来讲也是非常敏感的，\n   会让用户产生卡顿的感觉。\n\n新的架构称之为 Fiber 架构:\n\n * Scheduler (调度器) :调度任务的优先级，高优先级任务会优先进入到Reconciler\n * Reconciler (协调器) : VDOM的实现，负责根据自变量变化计算出UI变化\n * Renderer (渲染器) :负责将UI变化渲染到宿主环境中\n\n首先引入了 Fiber 的概念，通过一个对象来描述一个 DOM 节点，但是和之前方案不同的地方在于，每个Fiber对象之间通过链表的方式来进行串联。通过\nchild 来指向子元素，通过 sibling 指向兄弟元素，通过 return 来指向父元素。\n\n在新架构中，Reconciler 中的更新流程从递归变为了\"可中断的循环过程\"。每次循环都会调用 shouldYield 判断当前的 TimeSlice\n是否有剩余时间，没有剩余时间则暂停更新流程，将主线程还给渲染流水线，等待下一个宏任务再继续执行。这样就解决了CPU的瓶颈问题。\n\n另外在新架构中还引入了 Scheduler 调度器用来调度任务的优先级，从而解决了 I/O 的瓶颈问题。","routePath":"/guide/react/advance/第二章/5-React 整体架构","lang":"","toc":[{"text":"React 整体架构","id":"react-整体架构","depth":2,"charIndex":-1},{"text":"旧架构的问题","id":"旧架构的问题","depth":3,"charIndex":303},{"text":"CPU 瓶颈","id":"cpu-瓶颈","depth":4,"charIndex":534},{"text":"I/O 瓶颈","id":"io-瓶颈","depth":4,"charIndex":1507},{"text":"新架构的解决思路","id":"新架构的解决思路","depth":3,"charIndex":2015},{"text":"解决 CPU 瓶颈","id":"解决-cpu-瓶颈","depth":4,"charIndex":2026},{"text":"解决 I/O 瓶颈","id":"解决-io-瓶颈","depth":4,"charIndex":2680},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":3167}],"domain":"","frontmatter":{},"version":""},{"id":89,"title":"","content":"React 渲染流程#\n\n> 问：是否了解过 React 的整体渲染流程？里面主要有哪些阶段？\n\n现代前端框架都可以总结为一个公式：\n\n> UI = f (state)\n\n上面的公式还可以进行一个拆分：\n\n * 根据自变量 (state) 的变化计算出 UI 的变化\n * 根据 UI 的变化执行具体的宿主环境的 API\n\n对应的公式：\n\n\n\n对应到 React 里面就两大阶段：\n\n * render 阶段： 调合虚拟 DOM，计算出最终要渲染出来的虚拟 DOM\n * commit 阶段：根据上一步计算出来的虚拟 DOM，渲染具体的 UI\n\n每个阶段对应不同的组件：\n\n\n\n * 调度器 (Scheduler) ：调度任务，为任务排序优先级，让优先级高的任务先进入到 Reconciler\n * 协调器 (Reconciler) ：生成 Fiber 对象，收集副作用，找出哪些节点发生了变化，打上不同的 flags，著名的 Diff\n   算法也是在这其中执行的\n * 渲染器 (Renderer) ：根据协调器计算出来的虚拟 DOM 同步地渲染节点到视图上\n\n接下来我们来看一个例子：\n\n\n\n当用户点击按钮时，首先是由 Scheduler 进行任务的调度，排序任务优先级，render 阶段的工作流程是可以随时被以下原因中断：\n\n * 有其他更高优先级的任务需要执行\n * 当前的 time slice（时间切片）没有剩余的时间\n * 发生了其他错误\n\n注意上面的 render 阶段是在内存中进行的，不会更新宿主环境 UI，因此这个阶段即使工作流程反复被中断，用户也不会看到更新不完整的 UI\n\n当 Scheduler 调度完成后，将任务交给 Reconciler，Reconciler 需要计算出新的 UI，最后就由 Renderer 同步进行渲染更新\n\n如下图所示：\n\n\n\n\n调度器#\n\n在 React v16 版本之前，采用的是 Stack 架构，所有任务只能同步进行，无法被打断，这就导致浏览器可能会出现丢帧的现象，表现出卡顿。React\n为了解决这个问题，从 v16 版本开始从架构上面进行了两大更新：\n\n * 引入了 Fiber\n * 新增了 Scheduler\n\nScheduler 在浏览器的原生 API 中实际上是有类似的实现的，这个API就是 requestIdleCallback\n\nrequestIdleCallback#\n\n尝试一下：\n\n\n\n查看控制台：\n\n\n\n我们会发现有些时间有 50ms 或者接近 50ms，为什么呢？\n\n虽然每一帧绘制的时间约为16.66ms，但是如果屏幕没有刷新，那么浏览器会安排长度为 50ms 左右的空闲时间\n\n为什么是 50ms 呢？\n\n根据研究报告表明，用户操作之后，100ms 以内的响应给用户的感觉都是瞬间发生，也就是说不会感受到延迟感，因此将空闲时间设置为 50ms，浏览器依然还剩下\n50ms 可以处理用户的操作响应，不会让用户感到延迟。\n\n我们可以通过 requestIdleCallback 来模拟一下 Scheduler 的工作流程\n\n\n\n然后我们查看一下控制台：\n\n\n\n类似机制#\n\n虽然浏览器有类似的 API，但是 React 团队并没有使用该API，因为该 API 存在兼容性问题。因此 React\n团队自己实现了一套这样的机制，这个就是调度器 Scheduler。\n\nReact 团队单独发行了 Scheduler，这意味着调度器不仅仅只能在 React 中使用，凡是有涉及到任务调度需求的项目都可以使用 Scheduler\n\n\n协调器#\n\n协调器是 render 阶段的第二阶段工作，类组件或者函数组件本身就是在这个阶段被调用的。\n\n协调器起点和流程#\n\n根据 Scheduler 调度结果的不同，协调器起点可能是不同的\n\n * performSyncWorkOnRoot（同步更新流程）\n\n\n\n * performConcurrentWorkOnRoot（并发更新流程）\n\n\n\n新的架构使用 Fiber (对象) 来描述 DOM 结构，最终需要形成一颗 Fiber tree，不过这棵树是通过链表的形式串联在一起的，流程如下\n\n * workInProgres 代表的是当前的 FiberNode\n * performUnitOfWork 方法会创建下一个 FiberNode，并且还会将已创建的 FiberNode 连接起来(通过\n   child、return、sibling)，从而形成一个链表结构的 Fiber tree\n * 如果 workInProgres 为 null，说明已经没有下一个 FiberNode，也就是说明整棵 Fiber tree 树已经构建完毕\n * 上面两个方法唯一的区别就是是否调用了 shouldYield 方法，该方法表明了是否可以中断。\n\nperformUnitOfWork 工作流程#\n\nperformUnitOfWork 在创建下一个 FiberNode 的时候，整体上的工作流程可以分为两大块：\n\n * 递阶段\n * 归阶段\n\n递阶段#\n\n递阶段会从 HostRootFiber 开始向下，以深度优先的原则进行遍历，遍历到的每一个 FiberNode 执行 beginWork\n方法。该方法会根据传入的 FiberNode 创建下一级的 FiberNode，此时可能存在两种情况：\n\n * 下一级只有一个元素，beginWork 方法会创建对应的 FiberNode，并与 workInProgress 连接\n   \n   \n   \n   这里就会创建 li 对应的 FiberNode，类似如下：\n   \n   \n\n * 下一级有多个元素，这时 beginWork 会依次创建所有的子 FiberNode 并且通过 sibling 连接到一起，每个子 FiberNode\n   也会和 workInProgress 连接\n   \n   \n   \n   此时会创建3个 li 对应的 FiberNode，连接情况类似如下：\n   \n   \n\n由于采用的是深度优先的原则，因此无法再往下走的时候，会进入到归阶段。\n\n归阶段#\n\n归阶段会调用 completeWork 方法来处理 FiberNode，做一些副作用的收集\n\n当某个 FiberNode 执行完了 completeWork 方法后，如果存在兄弟元素，就会进入到兄弟元素的递阶段，如果不存在兄弟元素，就会进入父\nFiberNode 的归阶段\n\n\n\n最后我们来看一个图：\n\n\n\n\n渲染器#\n\nRenderer 工作的阶段被称之为 commit 阶段。该阶段会将各种副作用 commit 到宿主环境的 UI 中。\n\n相较于之前的 render 阶段可以被打断，commit 阶段一旦开始就会同步执行直到完成渲染工作。\n\n整个渲染器渲染过程中可以分为三个子阶段：\n\n * BeforeMutation 阶段\n * Mutation 阶段\n * Layout 阶段\n\n\n\n\n问题解答#\n\n问：是否了解过 React 的整体渲染流程？里面主要有哪些阶段？\n\n答：\n\nReact 整体的渲染流程可以分为两大阶段，分别是 render 阶段和 commit 阶段。\n\n * render 阶段里面会经由调度器和协调器处理，此过程是在内存中运行，是异步可中断的。\n\n * commit 阶段会由渲染器进行处理，根据副作用进行UI的更新，此过程是同步不可中断的，否则会造成UI和数据显示不一致。\n\nReact 整体架构分为调度器，协调器，渲染器\n\n * 调度器\n\n调度器的主要工作就是调度任务，让所有的任务有优先级的概念，这样的话紧急的任务可以优先执行。\n\nScheduler 实际上在浏览器的 API 中是有原生实现的，这个 API 叫做 requestIdleCallback，但是由于兼容性问题，React\n放弃了使用这个API，而是自己实现了一套这样的机制，并且把 Scheduler 这个包单独的进行发布，变成一个独立的包。\n\n这就意味Scheduler 不仅仅是只能在React 中使用，后面如果有其他的项目涉及到了任务调度的需求，都可以使用这个Scheduler。\n\n * 协调器\n\n协调器是 Render 的第二阶段工作。该阶段会采用深度优先的原则遍历并且创建一个一个的\nFiberNode，并将其串联在一起，在遍历时分为了\"递\"与\"归\"两个阶段。\n\n在\"递\"阶段会执行 beginWork 方法，该方法会根据传入的 FiberNode 创建下一级 FiberNode。\n\n在\"归\"阶段则会执行 completeWork 方法，做一些副作用的收集\n\n * 渲染器\n\n渲染器的工作主要就是将各种副作用(flags 表示) commit 到宿主环境的UI中。\n\n整个阶段可以分为三个子阶段，分别是 BeforeMutation 阶段、Mutation 阶段和 Layout 阶段。","routePath":"/guide/react/advance/第二章/6-React 渲染流程","lang":"","toc":[{"text":"React 渲染流程","id":"react-渲染流程","depth":2,"charIndex":-1},{"text":"调度器","id":"调度器","depth":3,"charIndex":793},{"text":"requestIdleCallback","id":"requestidlecallback","depth":4,"charIndex":1006},{"text":"类似机制","id":"类似机制","depth":4,"charIndex":1326},{"text":"协调器","id":"协调器","depth":3,"charIndex":1509},{"text":"协调器起点和流程","id":"协调器起点和流程","depth":4,"charIndex":1562},{"text":"performUnitOfWork 工作流程","id":"performunitofwork-工作流程","depth":4,"charIndex":2037},{"text":"渲染器","id":"渲染器","depth":3,"charIndex":2738},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":2932}],"domain":"","frontmatter":{},"version":""},{"id":90,"title":"","content":"","routePath":"/guide/react/advance/第二章/7-Fiber双缓冲","lang":"","toc":[{"text":"Fiber双缓冲","id":"fiber双缓冲","depth":2,"charIndex":-1},{"text":"对 Fiber 的理解","id":"对-fiber-的理解","depth":3,"charIndex":-1},{"text":"Fiber 双缓冲","id":"fiber-双缓冲","depth":3,"charIndex":-1},{"text":"**mount阶段**","id":"mount阶段","depth":4,"charIndex":-1},{"text":"**update阶段**","id":"update阶段","depth":4,"charIndex":-1},{"text":"问题解答","id":"问题解答","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":91,"title":"","content":"给 port1 发消息 给 port2 发消息","routePath":"/guide/react/advance/第二章/8-MessageChannel","lang":"","toc":[{"text":"MessageChannel","id":"messagechannel","depth":2,"charIndex":-1},{"text":"回顾事件循环","id":"回顾事件循环","depth":3,"charIndex":-1},{"text":"MessageChannel 以及为什么选择它","id":"messagechannel-以及为什么选择它","depth":3,"charIndex":-1},{"text":"为什么不选择 setTimeout","id":"为什么不选择-settimeout","depth":4,"charIndex":-1},{"text":"为什么没有选择 requestAnimationFrame","id":"为什么没有选择-requestanimationframe","depth":4,"charIndex":-1},{"text":"为什么没有选择包装成一个微任务？","id":"为什么没有选择包装成一个微任务","depth":4,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":92,"title":"","content":"React 入门篇#\n\n这是接下来入门篇的学习目标\n\n\n第一章#\n\n * React核心概念\n   * React基本介绍\n   * React中的组件\n   * 组件状态传递\n   * 事件\n   * 生命周期\n   * 表单\n * Hooks\n   * Hooks介绍\n   * useState\n   * useEffect\n\n\n第二章#\n\n * React-Router-Dom v6\n   * v6 版本 router的基本使用\n   * 完成学生管理系统\n * React-redux\n   * redux核心概念\n   * react-redux的基本使用\n   * 完善学生管理系统\n\n\n第三章#\n\n * Coder Station项目介绍\n * 完成Coder Station前台项目\n\n\n第四章#\n\n * dva的基本使用\n * antd和antdpro\n * Umi4 基本介绍\n * 完成Coder Station后台项目","routePath":"/guide/react/base/","lang":"","toc":[{"text":"React 入门篇","id":"react-入门篇","depth":2,"charIndex":-1},{"text":"第一章","id":"第一章","depth":3,"charIndex":27},{"text":"第二章","id":"第二章","depth":3,"charIndex":167},{"text":"第三章","id":"第三章","depth":3,"charIndex":301},{"text":"第四章","id":"第四章","depth":3,"charIndex":353}],"domain":"","frontmatter":{},"version":""},{"id":93,"title":"","content":"React 基本介绍#\n\n本章主要包含以下内容：\n\n * React基本介绍\n * React特点\n * 搭建开发环境\n\n\nReact 基本介绍#\n\nReact起源于Facebook的内部项目，因为该公司对市场上所有JavaScript MVC框架都不满意，就决定自己写-套，用来架设Instagram的网站。\n\nReact的实质其实是一个用于构建用户界面的JavaScript库。React 主要用于构建Ul。React\n于2013年5月开源，由于拥有较高的性能，代码逻辑简单，越来越多的人已开始关注和使用它。\n\n> UI = fn(state)\n\n由于React的设计思想极其独特，属于革命性创新，性能出众，所以，越来越多的人开始关注和使用，认为它可能是将来Web开发的主流工具。\n\n这个项目本身也越滚越大，从最早的UI引擎变成了-整套前后端通吃的Web App解决方案。\n\nReact 官网：英文网, 中文网\n\nReact 从诞生到现在，一直带给我们惊喜，如全新的Hooks概念等，从2015年开始，每年都会举行 React Conf\n大会，介绍React本年度所更新的新特性有哪些\n\n> React Conf官网：https://conf.react.dev/\n\n介绍React几个重要版本的更新：\n\n * React 16：出现了 Fiber，弃用了 Stack 架构，整个更新变的可中断、可分片、具有优先级\n * React 16.8：推出了 Hooks，标志着从类组件正式转为函数组件\n * React 17：过渡版本，没有添加任何面向开发人员的新功能，主要侧重升级简化 React 本身\n * React 18\n   * transition\n   * Suspense\n   * 新的 Hooks\n   * Offscreen\n   * .......\n\n\nReact 特点#\n\n在React官网，罗列了3个特点\n\n * 声明式\n * 组件化\n * 一次学习，跨平台编写\n\n除此之外，React还具有以下特点：\n\n * 单项数据流\n * 虚拟DOM\n * Diff算法\n\n\n搭建开发环境#\n\n虽然官方提供了通过CDN引入React的方式：https://zh-hans.legacy.reactjs.org/docs/cdn-links.html\n\n但实际开发肯定使用React的脚手架工具来搭建，如之前提供的React官方脚手架工具https://create-react-app.dev/docs/gett\ning-started/\n\n快速开始\n\n\n\n官网的新站点现在最近推荐通过Nextjs开始，但这是服务端渲染框架，不建议先从这开始，我们也可以通过Vite来搭建，根据提示选择即可\n\n\n\n> create-react-app：通过webpack搭建\n\n进去后，只留public下的favicon.ico和index.html，src下的App.js和index.js即可，这样简洁，有报错一般就是引入没了，删除就\n行","routePath":"/guide/react/base/第一章/1-React基本介绍","lang":"","toc":[{"text":"React 基本介绍","id":"react-基本介绍","depth":2,"charIndex":61},{"text":"React 基本介绍","id":"react-基本介绍-1","depth":3,"charIndex":-1},{"text":"React 特点","id":"react-特点","depth":3,"charIndex":787},{"text":"搭建开发环境","id":"搭建开发环境","depth":3,"charIndex":895}],"domain":"","frontmatter":{},"version":""},{"id":94,"title":"","content":"JSX 基础语法#\n\n本章主要包括以下内容：\n\n * JSX 基础语法\n * createElement 方法\n\n\nJSX 基础语法#\n\n在 React 中，使用JSX来描述页面。\n\n\n\n你可以把类似于 HTML 的代码单独提取出来，例如：\n\n\n\n\n\n注意这种类似于 HTML 的语法在 React 中称之为 JSX,这是一种 JavaScript 的语法扩展。在 React 中推荐使用 JSX\n来描述用户界面。JSX 乍看起来可能比较像是模版语言，但事实上它完全是在 JavaScript 内部实现的。\n\n使用 JSX 来描述页面时，有如下的一些语法规则：\n\n * 根元素只能有一个 如下，这样会报错，需要在两个 div 外面包裹一个标签\n\n> <></>也可以用来包裹，表示空标签，这样不会显示在 DOM 中\n\n\n\n * JSX 中使用 Javascript 表达式。表达式写在花括号{}中\n\n\n\n * 属性值指定为字符串字面量，或者在属性值中插入一个 Javascript 表达式\n\n\n\n * style 对应样式对象，class 要写作 className，且要驼峰命名写样式\n\n\n\n * 注释需要写在花括号，指的是 jsx 里面的注释\n\n\n\n * JSX 允许在模板中插入数组，数组会自动展开所有成员\n\n\n\n> 可以装 vscode 插件：搜索 React，可自行选择喜欢的插件，如 ES7 React/Redux/React-Native snippets for\n> es6/es7\n\n\ncreateElement 方法#\n\n如果你输出到了 arr2，会发现 arr2 输出的其实是一段不一样的，而且 JSX 是一种 Javascript 的语法扩展，它是通过 Babel\n会把JSX转译成一个名为 React.createElement 函数调用。\n\n\n\n参数说明：\n\n * type：创建的 React 元素类型（可选的值有：标签名字符串、React 组件）。\n * props（可选）：React 元素的属性。\n * children（可选）：React 元素的子元素。\n\n例如：下面两种代码的作用完全是相同的：\n\n\n\n这些对象被称为\"React 元素\"。它们描述了你希望在屏幕上看到的内容。\n\n可以看出，JSX 的本质其实就是 React.createElement 方法的一种语法糖\n\n> React 就是为了方便书写，所以才使用 JSX 来书写","routePath":"/guide/react/base/第一章/2-JSX基础语法","lang":"","toc":[{"text":" 基础语法","id":"-基础语法","depth":2,"charIndex":-1},{"text":" 基础语法","id":"-基础语法-1","depth":3,"charIndex":-1},{"text":"createElement 方法","id":"createelement-方法","depth":3,"charIndex":651}],"domain":"","frontmatter":{},"version":""},{"id":95,"title":"","content":"组件与事件绑定#\n\n本章包含以下内容：\n\n * React 中的组件\n * 为组件绑定事件\n * this 的指向\n * 向事件处理程序传递参数\n\n\nReact 中的组件#\n\n在 React 中，可以使用类的方式来声明一个组件。\n\n\n\n除了类组件，React 中还支持使用函数来创建组件，同样需要返回一段 JSX，来表示这个组件的 UI 是什么样的。\n\n\n\n早期的函数组件被称之为无状态组件，一般仅仅用来做纯 UI 的展示，里面不会有复杂的逻辑。 但是从 React 16.8 推出 Hooks\n后，现在更多的是使用函数组件了。 这不仅仅是语法的改变，同时也代表着整个 React 编程思想的一种转变。\n\n\n为组件绑定事件#\n\n在 React 中绑定事件的写法如下：\n\n\n\n在 React 中无法通过 return false 来阻止默认行为，所以只有使用e.preventDefault的方式来阻止默认行为。\n\n\n\n如果是类组件，那么事件处理函数写作一个类方法。\n\n\n\n在 React 的事件处理函数中所传入的事件对象，是一个合成事件对象。 React 也提供了访问原生事件对象的方式。如下:\n\n\n\n\nthis 的指向#\n\n由于 JS 中 this 的特殊性，事件处理函数中的 this 并不会指向当前的组件，这就需要我们自行对 this 进行指向的修正。\n\n这里介绍 3 种解决方式:\n\n * 将事件处理函数修改为箭头函数\n * 将事件绑定修改为箭头函数\n * 使用 bind 方法来强制绑定 this 的指向\n\n\n\n> this 的修正，只针对类组件，函数组件不需要用到 this\n\n\n向事件处理程序传递参数#\n\n另外还有一个非常重要的问题，就是如何向事件处理程序传递参数。\n\n如果要传递参数，可以使用下面的两种方式来进行传参:\n\n * 通过 bind 方法在绑定 this 指向时向事件处理函数进行传参\n * 绑定事件时，通过书写箭头函数的形式来传参\n\n\n\n> 上面只包括类组件，函数组件的传参很容易，如下\n\n","routePath":"/guide/react/base/第一章/3-组件与事件绑定","lang":"","toc":[{"text":"组件与事件绑定","id":"组件与事件绑定","depth":2,"charIndex":-1},{"text":"React 中的组件","id":"react-中的组件","depth":3,"charIndex":74},{"text":"为组件绑定事件","id":"为组件绑定事件","depth":3,"charIndex":303},{"text":"this 的指向","id":"this-的指向","depth":3,"charIndex":501},{"text":"向事件处理程序传递参数","id":"向事件处理程序传递参数","depth":3,"charIndex":695}],"domain":"","frontmatter":{},"version":""},{"id":96,"title":"","content":"React 前言#\n\n本章你将从入门开始，了解 React 的基本概念，并使用 React 进行开发。\n\n\n学习目标#\n\n * 入门篇\n * 进阶篇\n * 源码篇\n\n个人实现的手写 React: suReact","routePath":"/guide/react/","lang":"","toc":[{"text":"React 前言","id":"react-前言","depth":2,"charIndex":-1},{"text":"学习目标","id":"学习目标","depth":3,"charIndex":53}],"domain":"","frontmatter":{},"version":""},{"id":97,"title":"","content":"React 源码篇#\n\n本章你将从源码开始","routePath":"/guide/react/senior/","lang":"","toc":[{"text":"React 源码篇","id":"react-源码篇","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":98,"title":"","content":"Scheduler 调度普通任务#\n\nScheduler 的核心源码位于 package/scheduler/src/forks/Scheduler.js，如下：\n\n\n\n\nSchedulerCallback#\n\n该函数的主要目的就是用调度任务，该方法的分析如下:\n\n\n\n该方法主要注意以下几个关键点：\n\n * 关于任务队列有两个，一个 taskQueue，另一个是 timerQueue，taskQueue 存放普通任务，timerQueue\n   存放延时任务，任务队列内部用到了小顶堆的算法，保证始终放进去 (push) 的任务能够进行正常的排序，回头通过 peek\n   取出任务时，始终取出的是时间优先级最高的那个任务\n * 根据传入的不同的priorityLevel，会进行不同的 timeout 的设置，任务的 timeout\n   时间也就不一样了，有的比当前时间还要小，这个代表立即需要执行的，绝大部分时间比当前时间大。\n * 不同的任务，最终调用的函数不一样\n   * 普通任务调用 requestHostCallback\n   * 延时任务调用 requestHostTimeout\n\n\nrequestHostCallback#\n\n该方法主要就是调用 schedulePerformWorkUntilDeadline 方法\n\n\n\n\nschedulePerformWorkUntilDeadline#\n\n该方法一开始是 undefined，根据不同的环境选择不同生成宏任务的方式(一般就是 MessageChannel)\n\n\n\n\nperformWorkUntilDeadline#\n\n该方法主要就是在调用\nflushWork，调用之后返回一个布尔值，根据布尔值来判断是否还有剩余的任务，如果还有，就是用messageChannel进行一个宏任务的包装，\n放入到任务队列里面\n\n\n\n\nflashWork#\n\n核心就是调用 workLoop 函数\n\n\n\n\nworkLoop#\n\n\n\n首先有一个 while 循环，该while循环保证了能够从任务队列中不停的取任务出来\n\n\n\n当然，不是说一直从任务队列里面取任务出来执行就完事，每次取出一个任务后，我们还需要一系列的判断\n\n\n\n * currentTask.expirationTime > currentTime 表示任务还没有过期\n * shouldYieldToHost 任务是否应该暂停，归还主线程\n * 如果进入if，说明因为某些原因不能再执行任务，需要立即归还主线程，那么我们就跳出while\n\n\nshouldYieldToHost#\n\n首先计算 timeElapsed，然后判断是否超时，没有的话就返回 false，表示不需要归还，否则就返回 true，表示需要归还\n\nframeInterval 默认设置是 5ms\n\n\n\n\nadvanceTimers#\n\n该方法就是遍历整个 timerQueue，查看是否有已经过期的方法，如果有，不是直接执行，而是将这个过期的方法添加到 taskQueue\n\n","routePath":"/guide/react/senior/第一章/1-Scheduler 调度普通任务","lang":"","toc":[{"text":"Scheduler 调度普通任务","id":"scheduler-调度普通任务","depth":2,"charIndex":-1},{"text":"SchedulerCallback","id":"schedulercallback","depth":3,"charIndex":85},{"text":"requestHostCallback","id":"requesthostcallback","depth":3,"charIndex":503},{"text":"schedulePerformWorkUntilDeadline","id":"scheduleperformworkuntildeadline","depth":3,"charIndex":575},{"text":"performWorkUntilDeadline","id":"performworkuntildeadline","depth":3,"charIndex":673},{"text":"flashWork","id":"flashwork","depth":3,"charIndex":799},{"text":"workLoop","id":"workloop","depth":3,"charIndex":834},{"text":"shouldYieldToHost","id":"shouldyieldtohost","depth":3,"charIndex":1085},{"text":"advanceTimers","id":"advancetimers","depth":3,"charIndex":1200}],"domain":"","frontmatter":{},"version":""},{"id":99,"title":"你不知道的 CSS 之包含块","content":"This is text in the first paragraph...\n\nThis is text in the second paragraph.","routePath":"/guide/studyBase/css/CSS包含块","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":100,"title":"CSS 属性计算过程","content":"这是一个h1标题","routePath":"/guide/studyBase/css/CSS属性计算过程","lang":"","toc":[{"text":"确定声明值","id":"确定声明值","depth":2,"charIndex":-1},{"text":"层叠冲突","id":"层叠冲突","depth":2,"charIndex":-1},{"text":"比较源的重要性","id":"比较源的重要性","depth":3,"charIndex":-1},{"text":"比较优先级","id":"比较优先级","depth":3,"charIndex":-1},{"text":"比较次序","id":"比较次序","depth":3,"charIndex":-1},{"text":"使用继承","id":"使用继承","depth":2,"charIndex":-1},{"text":"使用默认值","id":"使用默认值","depth":2,"charIndex":-1},{"text":"一道面试题","id":"一道面试题","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":101,"title":"","content":"表格标签#\n\n * 表格主要作用：用于显示数据，展示数据\n\n * 相关定义和用法\n   \n   * 标签用于定义表格\n   * 标签用于定义表格中的行,必须嵌套在标签中\n   * 标签用于定义表格中的单元格,必须嵌套在标签中\n   * 标签用于表示表格中的表头部分,加粗居中显示\n\n * 表格属性\n   \n   属性名           属性值                 描述\n   align         left、center、right   规定表格相对周围元素的对齐方式\n   border        1 或\"\"               规定表格单元格是否拥有边框，默认为\"\",表示没有边框\n   cellpadding   像素值                 规定单元边沿与其内容之间的空白，默认 1 像素\n   cellspacing   像素值                 规定单元格之间的空白，默认 2 像素\n   width         像素值或百分比             规定表格的宽度\n\n * 表格结构标签\n   \n   * 标签表示表格的头部区域\n   * 标签表示表格的主体区域\n   \n   \n\n * 合并单元格\n   \n   * 跨行合并：rowspan=\"合并单元格的个数\" 最上侧单元格为目标单元格，写合并代码\n   * 跨列合并：colspan=\"合并单元格的个数\" 最左侧单元格为目标单元格，写合并代码\n\n\n列表标签#\n\n * 三类：无序列表，有序列表，自定义列表\n\n * 无序列表\n   \n   \n   \n   > 无序列表的各个列表项之间没有顺序级别之分，是并列的，中只能嵌套,在其中输入其他标签或文字是不允许的(规范) 可以放任何元素\n   > \n   > 无序列表自带属性，在 css 中改变\n\n * 有序列表\n   \n   \n   \n   > 列表排序以数字来显示\n\n * 自定义列表\n   \n   \n   \n   > 里面只能包含\n   > \n   > 个数没有限制，经常是一个对应多个\n\n\n表单标签#\n\n为了收集用户信息 一个完整的表单由表单域，表单控件(表单元素)，提示信息三部分组成\n\n * 表单域\n   \n   标签用于定义表单域，会将范围内的表单元素提交给服务器\n   \n   属性       属性值        作用\n   action   url 地址     用于指定接受并处理表单数据的服务器程序的 url 地址\n   method   get/post   用于设置表单数据的提交方式，取值为 get/post\n   name     名称         用于指定表单的名称，以区分同一个页面中的多个表单域\n\n * 表单控件\n   \n   * 输入，用于收集用户信息\n     \n     TYPE 属性值   描述\n     button     定义可点击按钮(多数情况下，用于通过 JavaScript 启动脚本)\n     checkbox   定义复选框\n     file       定义输入字段和\"浏览\"按钮，供文件上传\n     hidden     定义隐藏的输入字段\n     image      定义图像形式的提交按钮\n     password   定义密码字段。该字段中的字符被掩码\n     radio      定义单选按钮\n     reset      定义重置按钮。重置按钮会清除表单中的所有数据\n     submit     定义提交按钮。提交按钮会把表单数据发送到服务器\n     text       定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符\n   \n   * input 属性\n     \n     属性          属性值       描述\n     name        用户自定义     定义 input 元素的名称\n     value       用户自定义     规定 input 元素的值\n     checked     checked   规定此 input 元素首次加载时应该被选中\n     maxlength   正整数       规定输入字段中的字符的最大长度\n     \n     > name 和 value 主要给后台人员使用 name 表单名字要求复选框和单选框要有相同的 name 值\n   \n   * 为 input 标签定义标注(标签)\n     \n     \n     \n     > lable 的 for 属性要与相关元素的 id 属性相同\n   \n   * 下拉菜单 元素\n     \n     \n     \n     > 在中定义selected= \"selected\"时即默认选中项\n   \n   * 用于定义多行文本输入的控件\n     \n     ","routePath":"/guide/studyBase/html/html_down","lang":"","toc":[{"text":"表格标签","id":"表格标签","depth":2,"charIndex":-1},{"text":"列表标签","id":"列表标签","depth":2,"charIndex":640},{"text":"表单标签","id":"表单标签","depth":2,"charIndex":888}],"domain":"","frontmatter":{},"version":""},{"id":102,"title":"","content":"","routePath":"/guide/studyBase/html/html_up","lang":"","toc":[{"text":"1 HTML语法规范","id":"1-html语法规范","depth":3,"charIndex":-1},{"text":"1.1 基本语法概述","id":"11-基本语法概述","depth":4,"charIndex":-1},{"text":"1.2 标签关系","id":"12-标签关系","depth":4,"charIndex":-1},{"text":"2 HTML基本结构标签","id":"2-html基本结构标签","depth":3,"charIndex":-1},{"text":"骨架标签","id":"骨架标签","depth":4,"charIndex":-1},{"text":"3 网页开发","id":"3-网页开发","depth":3,"charIndex":-1},{"text":"3.1 文档类型声明标签","id":"31-文档类型声明标签","depth":4,"charIndex":-1},{"text":"3.2 lang语言种类","id":"32-lang语言种类","depth":4,"charIndex":-1},{"text":"3.3 字符集","id":"33-字符集","depth":4,"charIndex":-1},{"text":"4 HTML常用标签","id":"4-html常用标签","depth":3,"charIndex":-1},{"text":"4.1 标题标签`<h1>`-`<h6>`","id":"41-标题标签h1-h6","depth":4,"charIndex":-1},{"text":"4.2 段落标签和换行标签","id":"42-段落标签和换行标签","depth":4,"charIndex":-1},{"text":"4.3 文本格式化标签","id":"43-文本格式化标签","depth":4,"charIndex":-1},{"text":"4.4 `<div>`和`<span>`标签","id":"44-div和span标签","depth":4,"charIndex":-1},{"text":"4.5 图像标签和路径","id":"45-图像标签和路径","depth":4,"charIndex":-1},{"text":"4.6 超链接标签","id":"46-超链接标签","depth":4,"charIndex":-1},{"text":"5 HTML中的注释和特殊字符","id":"5-html中的注释和特殊字符","depth":3,"charIndex":-1},{"text":"音频标签","id":"音频标签","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":103,"title":"","content":"基础学习#\n\n本章你将学习 HTML,CSS,JS 的内容。","routePath":"/guide/studyBase/","lang":"","toc":[{"text":"基础学习","id":"基础学习","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":104,"title":"","content":"interface 和 type 的区别#\n\n比如下面这段代码\n\n\n\n从上面我们看到了 interface 缺失了索引签名, 那我们加上, 发现不报错了\n\n\n\n所以解决方案是加上索引签名\n\n那么产生的原因是什么呢\n\n把 interface 赋值 Record 的时候需要明确 interface 的属性,那我们明确了呀,为什么还会报错, 因为 interface\n会进行声明合并,如下,同名的 interface 都可以合并\n\n\n\n所以我们需要明确索引签名才能保证 Record 的正确性,但使用 type 就没有这个问题了,因为 type 不会进行声明合并,重名的会报错","routePath":"/guide/tips/1-interface和type的区别","lang":"","toc":[{"text":"interface 和 type 的区别","id":"interface-和-type-的区别","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":105,"title":"","content":"小知识#","routePath":"/guide/tips/","lang":"","toc":[{"text":"小知识","id":"小知识","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":106,"title":"","content":"V8 引擎#\n\n本章你将学习到 V8 引擎的原理","routePath":"/guide/v8/0-V8引擎前言","lang":"","toc":[{"text":"V8 引擎","id":"v8-引擎","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":107,"title":"","content":"V8引擎编译原理#\n\n\n什么是V8#\n\nV8是谷歌的开源高性能JavaScript和WebAssembly引擎，用C++编写。它被用于Chrome和Node.js等。它实现ECMAScript和Web\nAssembly，并在Windows 7或更高版本、macOS\n10.12+以及使用x64、IA-32、ARM或MIPS处理器的Linux系统上运行。V8可以独立运行，也可以嵌入到任何C++应用程序中。\n\nV8官网 v8.dev/\n\n\n宏观图#\n\n\n\n\n扫描器Scanner#\n\n\n\nBlink（谷歌浏览器的渲染引擎，基于webkit分支开发）主要负责HTML DOM CSS\n渲染，嵌入V8引擎，执行js，计算样式和布局，嵌入合成器，绘制图形。\n\nBlink 拿到html代码分析，找到script代码交给V8引擎解析，注意Blink是通过流的形式传给V8的。\n\n> 通过以流的形式传输数据，Blink可以逐步接收和处理来自网络的字节流，并在需要时将相应的数据传递给V8引擎执行。这种流式处理方式使得浏览器可以在数据到达的同\n> 时并行处理不同的任务，提高了页面的加载速度和用户体验\n\nScanner（扫描器）首先会进行词法分析\n\n摘抄自V8部分源码 Scanner\n\n> 位于V8/src/parsing/scanner-inl.h文件第347行开始\n\n\n\n 1. 首先获取当前字符c0_的值，并设置token为初始值。\n 2. 判断c0_是否是ASCII字符，如果是，则根据c0_的值来确定token的类型，并返回相应的Token。\n 3. 对于一些特殊情况，如条件运算符、字符串、小于号、大于号、等号、逻辑非、加号、减号、乘号、取模、除号、按位与、按位或等，根据当前字符和后续字符的组合来确定\n    token的类型，并返回相应的Token。\n 4. 如果c0_不是ASCII字符，或者不满足以上条件，则判断c0_是否是标识符的起始字符，如果是，则调用ScanIdentifierOrKeyword()函\n    数来获取标识符或关键字的Token。\n 5. 如果c0_是HTML注释的结束符'-'，则调用SkipSingleHTMLComment()函数来跳过整个HTML注释。\n 6. 如果扫描到文件末尾，则返回Token::EOS。\n 7. 否则，如果遇到空白字符，则调用SkipWhiteSpace()函数来跳过连续的空白字符，并继续扫描下一个Token。\n 8. 最后，返回扫描到的Token。\n\n举个例子 词法分析 解析为如下格式\n\n\n\n 1. Token::VAR：表示关键字\"var\"。\n 2. Token::WHITESPACE：表示空格字符。\n 3. Token::IDENTIFIER：表示标识符\"suzhenghui\"。\n 4. Token::WHITESPACE：表示空格字符。\n 5. Token::ASSIGN：表示赋值符号\"=\"。\n 6. Token::WHITESPACE：表示空格字符。\n 7. Token::STRING：表示字符串\"'szh'\"。\n\n词法分析结束后我们的js代码就会变成tokens 接下来进行语法分析\n\n\n解析器parser#\n\nparser 的作用就是将 tokens 转化为 AST 抽象语法树\n\n\n\n\n预解析PreParser#\n\nPreParser是预解析器，它的作用是在 JavaScript 代码执行之前对代码进行可选的预处理。预解析器的存在是为了提高代码的执行效率。\n\nV8 引擎采用了延迟解析（Lazy\nParsing）的策略，它的原理是只解析当前需要的内容，而把其他内容推迟到函数被调用时再进行解析。这样可以减少不必要的解析工作，提高网页的运行效率。\n\n例如，在一个函数 outer 内部定义了另一个函数 inner，那么 inner 函数就会进行预解析。这意味着在函数 outer 被调用之前，只会对 outer\n函数的内容进行解析，而对于 inner 函数的解析会在 outer 函数调用到 inner 函数时才进行。\n\n通过延迟解析的方式，V8 引擎可以避免解析和编译未被执行的函数，节省了不必要的时间和资源开销，提高了 JavaScript\n代码的执行效率。这种优化策略在大型复杂的 JavaScript 应用程序中尤为重要，可以帮助提升整体性能和用户体验。\n\n\n解释器Ignition#\n\n解释器的作用主要就是将AST 抽象语法树 转化成 字节码(bytecode)\n\n问？为什么要转成字节码而不是直接转成机器码\n\n 1. 跨平台执行：不同的硬件架构和操作系统有不同的机器码格式。通过将代码转换为字节码，可以使得同一份字节码在不同的平台上都能执行，实现跨平台的能力。\n 2. 快速启动和解析：将代码转换为字节码可以比直接生成机器码更快速地进行启动和解析。字节码通常具有更简单的格式和结构，可以更快地被引擎加载和解释执行。\n 3. 动态优化：现代的JavaScript引擎通常具有即时编译（JIT）功能，可以将热点代码编译成高效的机器码。通过首先将代码转换为字节码，引擎可以更好地进行\n    动态优化和编译，根据实际执行情况生成最优的机器码。这种方式可以在运行时根据代码的实际执行情况进行优化，而不需要提前生成固定的机器码。\n 4. 代码安全性：字节码作为中间表示形式，可以提供一定的代码安全性。字节码相对于源代码或机器码来说更难以理解和修改，可以提供一定程度的代码保护。\n\n示例 以下代码会被转成 字节码\n\n\n\n转化之后\n\n\n\n * PushString \"'szh'\"：将字符串字面量 \"'szh' \"推入堆栈（栈帧）。在这个例子中，它将字符串 \"'szh' \"推入堆栈。\n * StoreVar \"suzhenghui\"：将栈顶的值存储到变量 \"suzhenghui\" 中。在这个例子中，它将栈顶的字符串值存储到变量\n   \"suzhenghui\"\n\n\n编译器TurboFan#\n\n编译器就是将字节码也可以叫中间代码 最后 转换成 机器码 能让我们的CPU识别\n\n但是我们的CPU有不同的架构 ARM X86\n\n示例 我们的 字节码 转换成机器码例如 X86\n\n\n\nX86机器码\n\n\n\nARM机器码\n\n","routePath":"/guide/v8/1-V8引擎编译原理","lang":"","toc":[{"text":"V8引擎编译原理","id":"v8引擎编译原理","depth":2,"charIndex":-1},{"text":"什么是V8","id":"什么是v8","depth":3,"charIndex":11},{"text":"宏观图","id":"宏观图","depth":3,"charIndex":218},{"text":"扫描器Scanner","id":"扫描器scanner","depth":3,"charIndex":227},{"text":"解析器parser","id":"解析器parser","depth":3,"charIndex":1337},{"text":"预解析PreParser","id":"预解析preparser","depth":3,"charIndex":1388},{"text":"解释器Ignition","id":"解释器ignition","depth":3,"charIndex":1829},{"text":"编译器TurboFan","id":"编译器turbofan","depth":3,"charIndex":2478}],"domain":"","frontmatter":{},"version":""},{"id":108,"title":"","content":"V8引擎如何存储对象#\n\n\n在V8中对象的结构#\n\n主要分为三个指针构成的，分别是隐藏类，properties(常规属性)，elements（排序属性）\n\n我们先了解 常规属性 和 排序属性\n\n\n\n输出如下\n\n\n\n由此我们发现了一个神奇的现象，数字从小到大排列，但字符串还是按原顺序排列\n\n事实上，这是为了满足ECMA规范要求所进行的设计。按照规范中的描述，可索引的属性应该按照索引值大小升序排列，而命名属性根据创建的顺序升序排列。\n\n这里我们把对象中的数字属性称之为排列属性，在V8中被称为 elements，字符串属性就 被称为常规属性，在 V8 中被称为 properties。\n\n\n\n打开浏览器，控制台选择内存，堆快照，然后找到foo，可以发现 elements 但是没有看到 properties\n\n\n\n\n快属性和慢属性#\n\nV8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，我们把这称为对象内属性 (in-object properties)\n\n快属性\n\n对象内属性就是直接把属性挂到该对象上，查找的只需要一次 foo.A foo.B\n因此被称为快属性，但是注意，快属性容量是10个，超出之后就会添加到properties里面，称为慢属性。因此V8 采取了两种存储策略\n\n如图\n\n\n\n慢属性\n\n比如执行 Foo.property10这个语句来查找 property10 的属性值， 那么在 V8 会先查找出 properties 属性所指向的对象\nproperties，然后再在 properties 对象中查找 property10\n属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率,这就是慢属性。\n\n","routePath":"/guide/v8/2-V8引擎如何存储对象","lang":"","toc":[{"text":"V8引擎如何存储对象","id":"v8引擎如何存储对象","depth":2,"charIndex":-1},{"text":"在V8中对象的结构","id":"在v8中对象的结构","depth":3,"charIndex":13},{"text":"快属性和慢属性","id":"快属性和慢属性","depth":3,"charIndex":357}],"domain":"","frontmatter":{},"version":""},{"id":109,"title":"","content":"V8引擎隐藏类#\n\n上一章我们讲了V8如何存储的对象，其中提到了隐藏类，这一章我们来看看隐藏类到底做了什么\n\n隐藏类是V8引擎在运行时自动生成和管理的数据结构，用于跟踪对象的属性和方法，隐藏类的思想借鉴了静态语言的结构\n\n\n\nC++\n\n\n\n首先在JavaScript运行时，例如su.age 去查询 age 上节课我们讲过他会通过快慢属性 去找而且整个过程非常耗时。\n\n而C++就不同了，C++在声明一个对象之前需要定义该对象的结构，c++ 代码在执行之前是需要被编译的，编译的时候对象都是固定的，也就是代码执行的时候\n对象的形状是无法被改变的。\n\n所以V8就引入了 隐藏类的概念\n\n\n隐藏类 (Hiden Class)#\n\n隐藏类就是把JavaScript的对象也进行静态化，我们假设这个对象不会删除和新增，这样形状就固定了\n\n满足条件之后V8就会创建隐藏类，在这个隐藏类会创建对象的基础属性\n\n在V8引擎中，每个隐藏类都有一个编号（map id），用于唯一标识该隐藏类\n\n举个例子，假设我们有以下两个对象：\n\n\n\n这两个对象具有相同的形状，即都有属性name和age，但obj2还额外有一个属性address。V8会为它们生成两个不同的隐藏类\n\n\n\n可以看到，隐藏类1包含属性name和age，没有过渡表；而隐藏类2包含属性name、age和address，其中属性name和age的过渡表指向隐藏类1，属性a\nddress没有过渡表，表示该属性是新添加的\n\n\n如果两个对象属性一样呢？#\n\n如果两个对象具有相同的属性，它们将共享同一个隐藏类。具体来说，当两个对象的属性顺序和类型都相同时，V8会为它们生成一个共享的隐藏类。\n\n举个例子，假设我们有以下两个对象：\n\n\n\n这两个对象具有相同的形状，即都有属性name和age，且属性的顺序和类型完全一致。V8会为它们生成一个共享的隐藏类，如下所示：\n\n\n\n可以看到，隐藏类1包含属性name和age，没有过渡表，而且两个对象都共享这个隐藏类。\n\n> 这种共享隐藏类的机制可以节省内存空间，因为不同的对象可以共享相同的隐藏类结构。","routePath":"/guide/v8/3-V8引擎隐藏类","lang":"","toc":[{"text":"V8引擎隐藏类","id":"v8引擎隐藏类","depth":2,"charIndex":-1},{"text":"隐藏类 (Hiden Class)","id":"隐藏类-hiden-class","depth":3,"charIndex":292},{"text":"如果两个对象属性一样呢？","id":"如果两个对象属性一样呢","depth":3,"charIndex":632}],"domain":"","frontmatter":{},"version":""},{"id":110,"title":"","content":"准备工作#\n\n\n安装#\n\n * 运用 script 标签导入本地下载的 vue.js 或者 CDN 导入\n   \n   * 分为开发版本和生产版本，开发包含警告和调试，生产版本则压缩并将其警告等删除\n   * 利用下方代码可引入 CDN 的 vue.js，版本为 Vue2\n\n\n\n * 利用 npm 命令安装\n\n\n\n> 下面所有例子在 html 中进行编写，默认引入了vue\n\n\n安装 Vue Devtools#\n\n点击下方进入 github 官网，去谷歌应用商店安装，可以利用魔法或者查询别人发布的压缩包\n\nhttps://github.com/vuejs/devtools#vue-devtools\n\n\n消除生成提示#\n\n在开始前可以将 Vue 的 productionTip 设置为 false 来阻止 Vue 在启动时生成生产提示\n\n","routePath":"/guide/vue/1-vue2基础/1-准备工作","lang":"","toc":[{"text":"准备工作","id":"准备工作","depth":2,"charIndex":-1},{"text":"安装","id":"安装","depth":3,"charIndex":7},{"text":"安装 Vue Devtools","id":"安装-vue-devtools","depth":3,"charIndex":189},{"text":"消除生成提示","id":"消除生成提示","depth":3,"charIndex":303}],"domain":"","frontmatter":{},"version":""},{"id":111,"title":"","content":"条件渲染#\n\n使用v-show做条件渲染,如下 v-show通过改变 css 的display属性来决定是否显示\n\n\n\n使用v-if做条件渲染,如下v-if如果为 false 会直接让该 DOM 元素移除\n\n> 一般变化很频繁的话使用 v-show，如果不是很多一般用 v-if\n\n\n\n小案例：n 为不同值时显示不同标签 n 同为 1 时显示多个标签\n\n\n\n总结\n\n * v-if\n   * 写法：\n     * v-if=\"表达式\"\n     * v-else-if=\"表达式\"\n     * v-else=\"表达式\"\n   * 适用于：切换频率较低的场景\n   * 特点：不展示的 DOM 元素直接被移除\n   * 注意：v-if可以和v-else-if、v-else一起使用，但要求结构不能断掉\n * v-show\n   * 写法：v-show=\"表达式\"\n   * 适用于：切换频率较高的场景\n   * 特点：不展示的 DOM 元素未被移除，仅仅是使用样式隐藏掉\n * 备注：使用v-if时，元素可能无法获取到，而使用v-show一定可以获取到","routePath":"/guide/vue/1-vue2基础/10-条件渲染","lang":"","toc":[{"text":"条件渲染","id":"条件渲染","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":112,"title":"","content":"列表渲染#\n\n\nv-for 指令#\n\n * 用于展示列表数据\n\n * 语法：v-for=\"(item, index) in xxx\" :key=\"yyy\" (key 很重要需要写)\n\n * 可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）\n\n\n\n\nkey 的原理与作用#\n\n如果用索引 index 作为 key，如果每个后面的 input 框都输入值，将新数据添加到前面的时候 diff 算法只会根据不同改变，导致错误\n\n\n\n但如果用 id 作为 key 值的话，就不会出现错误\n\n\n\n> 如果不写 key，会默认用索引作为 key\n\n\n\n总结：\n\nReact 和 Vue 中的 key 有什么作用？（key 的内部原理）\n\n * 虚拟 DOM 中 key 的作用：\n   \n   * key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据【新数据】生成【新的虚拟 DOM】, 随后 Vue 进行【新虚拟\n     DOM】与【旧虚拟 DOM】的差异比较，比较规则如下：\n\n * 对比规则：\n   \n   * 旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：\n     \n     * 若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM\n     \n     * 若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM\n   \n   * 旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key\n     \n     * 创建新的真实 DOM，随后渲染到到页面。\n\n * 用 index 作为 key 可能会引发的问题：\n   \n   * 若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实 DOM 更新 ==> 界面效果没问题, 但效率低\n   \n   * 如果结构中还包含输入类的 DOM： 会产生错误 DOM 更新 ==> 界面有问题\n\n * 开发中如何选择 key:\n   \n   * 最好使用每条数据的唯一标识作为 key, 比如 id、手机号、身份证号、学号等唯一值\n   * 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的。\n\n\n列表过滤#\n\n\n\n\n列表排序#\n\n\n\n\n更新时的一个问题#\n\n需求：我们需要点击之后改变马冬梅的信息，但如果是用this.persons[0] = {id: '001', name: '马老师', age: 69,\nsex: '男'}就会发现页面并没有改变信息，但如果通过浏览器控制台输出会发现其实已经是改变的。\n\n原因：Vue 没有监测到数据的改变，具体在下面一小节解释\n\n\n\n\nVue 监测数据的原理_对象#\n\nVue 是通过 setter 和 getter 来监测数据的\n\n以下是一个简单的源码复现\n\n\n\n\nVue.set()方法#\n\n我想以后在 Student 里添加性别的属性，可以在浏览器控制台输入如下来添加响应式数据\n\nVue.set(vm._data.student,'sex','男')\n\n当然 vm 的一个方法和上面的方法一样\n\nvm.$set(vm._data.student,'sex','男')\n\n自然可以简化数据 因为vm._data.student === vm.student为 true 这是数据代理\n\nvm.$set(vm.student,'sex','男')\n\n在代码中通过 button 实现\n\n> 缺点：向响应式对象中添加属性，但该对象不能是 Vue 实例或 Vue 实例的根数据对象\n> \n> 即 vm.$set(vm._data,'leader','校长') 是错误的\n\n\n\n\nVue 监测数据的原理_数组#\n\n浏览器控制台如果输入vm._data会发现 hobby 是数组，但没有 getter 和 setter，但如果 hobby 是对象就会有\n\n所以如果是通过索引如vm._data.student.hobby[0] = '学习'可以修改但页面无法响应\n\n但通过数组的方法如push、shift等方法就可以改变并让页面的数据一块响应\n\n但这些方法不是 Array 原型对象上的方法，在浏览器控制台输入如下会输出false\n\nvm_data.student.hobby.push === Array.prototype.push\n\n> Vue 官方解释：Vue 将被侦听的数组的变更方法进行了包装，它们将会触发视图更新\n> \n> 当然 set 方法也可以改变，不过不建议这样使用\n\n\n\n\n总结 Vue 监视数据#\n\n把之前的都练习一遍，总结要点在下面\n\n\n\nVue 监视数据的原理：\n\n * Vue 会监视 data 中所有层次的数据\n * 如何监测对象中的数据\n   * 通过 setter 实现监视，且要在 new Vue 时就传入要监测的数据\n   * 对象中后追加的属性，Vue 默认不做响应式处理\n   * 如需给后添加的属性做响应式，需要使用如下 API\n     * Vue.set(target, propertyName/index, value)\n     * vm.$set(target, propertyName/index, value)\n * 如何监测数组中的数据\n   * 通过包裹数组更新元素的方法实现，本质就是做了两件事\n     * 调用原生对应的方法对数组进行更新\n     * 重新解析模板，进而更新页面\n * 在 Vue 修改数组中的某个元素一定要用如下方法\n   * 使用 API：push()、pop()、shift()、unshift()、splice()、sort()、reverse()\n   * 使用Vue.set()或vm.$set()\n   * 如果需要使用过滤filter()等方法则需要将数组替换\n * 特别注意：Vue.set()和vm.$set()不能给 vm 或 vm 的根数据对象添加属性","routePath":"/guide/vue/1-vue2基础/11-列表渲染","lang":"","toc":[{"text":"列表渲染","id":"列表渲染","depth":2,"charIndex":-1},{"text":"v-for 指令","id":"v-for-指令","depth":3,"charIndex":7},{"text":"key 的原理与作用","id":"key-的原理与作用","depth":3,"charIndex":129},{"text":"列表过滤","id":"列表过滤","depth":3,"charIndex":956},{"text":"列表排序","id":"列表排序","depth":3,"charIndex":966},{"text":"更新时的一个问题","id":"更新时的一个问题","depth":3,"charIndex":976},{"text":"Vue 监测数据的原理_对象","id":"vue-监测数据的原理_对象","depth":3,"charIndex":1147},{"text":"Vue.set()方法","id":"vueset方法","depth":3,"charIndex":1213},{"text":"Vue 监测数据的原理_数组","id":"vue-监测数据的原理_数组","depth":3,"charIndex":1568},{"text":"总结 Vue 监视数据","id":"总结-vue-监视数据","depth":3,"charIndex":1925}],"domain":"","frontmatter":{},"version":""},{"id":113,"title":"","content":"账号：\n\n密码：\n\n年龄：\n\n性别： 男 女\n\n爱好： 学习 打游戏 吃饭\n\n所属校区 请选择校区 北京 上海 深圳 武汉\n\n其他信息：\n\n阅读并接受《用户协议》 提交","routePath":"/guide/vue/1-vue2基础/12-收集表单数据(v-model)","lang":"","toc":[{"text":"收集表单数据(v-model)","id":"收集表单数据v-model","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":114,"title":"","content":"显示格式化后的时间\n\n\n现在是：{{fmtTime}}\n\n\n现在是：{{getFmtTime()}}\n\n\n现在是：{{time | timeFormater}}\n\n\n现在是：{{time | timeFormater('YYYY_MM_DD') | mySlice}}\n\n\nVue\n\n\n{{msg | mySlice}}","routePath":"/guide/vue/1-vue2基础/13-过滤器","lang":"","toc":[{"text":"过滤器","id":"过滤器","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":115,"title":"","content":"内置指令#\n\n我们学过的指令\n\n * v-bind : 单向绑定解析表达式, 可简写为 :xxx\n\n * v-model : 双向数据绑定\n\n * v-for : 遍历数组/对象/字符串\n\n * v-on : 绑定事件监听, 可简写为@\n\n * v-if : 条件渲染（动态控制节点是否存存在）\n\n * v-else : 条件渲染（动态控制节点是否存存在）\n\n * v-show : 条件渲染 (动态控制节点是否展示)\n\n\nv-text 指令#\n\n * 作用：向其所在的节点中渲染文本内容。\n * 与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。\n\n\n\n\nv-html 指令#\n\n * 作用：向指定节点中渲染包含 html 结构的内容\n * 与插值语法的区别：\n   * v-html会替换掉节点中所有的内容，{{xx}}则不会。\n   * v-html可以识别 html 结构。\n * 严重注意：v-html有安全性问题\n   * 在网站上动态渲染任意 HTML 是非常危险的，容易导致XSS攻击。\n   * 一定要在可信的内容上使用v-html，永远不要用在用户提交的内容上\n\n\n\n\nv-cloak 指令#\n\n * 本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉v-cloak属性\n * 使用 css 配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题\n\n\n\n\nv-once 指令#\n\n * v-once所在节点在初次动态渲染后，就视为静态内容了\n * 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能\n\n\n\n\nv-pre 指令#\n\n * 跳过其所在节点的编译过程\n * 可利用它跳过没有使用指令语法、没有使用插值语法的节点，会加快编译\n\n","routePath":"/guide/vue/1-vue2基础/14-内置指令","lang":"","toc":[{"text":"内置指令","id":"内置指令","depth":2,"charIndex":-1},{"text":"v-text 指令","id":"v-text-指令","depth":3,"charIndex":211},{"text":"v-html 指令","id":"v-html-指令","depth":3,"charIndex":289},{"text":"v-cloak 指令","id":"v-cloak-指令","depth":3,"charIndex":505},{"text":"v-once 指令","id":"v-once-指令","depth":3,"charIndex":608},{"text":"v-pre 指令","id":"v-pre-指令","depth":3,"charIndex":692}],"domain":"","frontmatter":{},"version":""},{"id":116,"title":"","content":"自定义指令#\n\n\n自定义指令_函数式#\n\n需求1：定义v-big指令，和v-text类似，但会把绑定数据放大10倍\n\n\n\n\n自定义指令_对象式#\n\n需求2：定义v-fbind指令，和v-bind类似，但可以让其所绑定的input元素默认获取焦点\n\n\n\n> 定义全局指令\n\n\n自定义指令总结#\n\n * 定义语法\n   \n   * 局部指令\n     \n     \n   \n   * 全局指令\n     \n     Vue.directive(指令名,配置对象)或Vue.directive(指令名,回调函数)\n\n * 配置对象中常用的3个回调\n   \n   * bind：指令与元素成功绑定时调用\n   * inserted：指令所在元素被插入页面时调用\n   * update：指令所在模板结构被重新解析时调用\n\n * 备注\n   \n   * 指令定义时不加v-，但使用时要加v-\n   * 指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名","routePath":"/guide/vue/1-vue2基础/15-自定义指令","lang":"","toc":[{"text":"自定义指令","id":"自定义指令","depth":2,"charIndex":-1},{"text":"自定义指令_函数式","id":"自定义指令_函数式","depth":3,"charIndex":8},{"text":"自定义指令_对象式","id":"自定义指令_对象式","depth":3,"charIndex":61},{"text":"自定义指令总结","id":"自定义指令总结","depth":3,"charIndex":136}],"domain":"","frontmatter":{},"version":""},{"id":117,"title":"","content":"生命周期#\n\n\n引出生命周期#\n\n生命周期：\n\n * 又名：生命周期回调函数、生命周期函数、生命周期钩子。\n\n * 是什么：Vue 在关键时刻帮我们调用的一些特殊名称的函数。\n\n * 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\n\n * 生命周期函数中的 this 指向是 vm 或 组件实例对象。\n\n\n\n\n生命周期图示#\n\n\n\n\n生命周期_挂载流程#\n\n根据图示，在第一步初始化的时候无法通过 vm 访问data和method，我们可以通过beforeCreate()来查看\n\n打开控制台查看 vm 会发现 vm 中没有data数据和method方法\n\n> 开控制台然后刷新可以进入断点\n\n\n\n接下来我们查看第二步，在beforeCreate()后添加created()，此时就会发现 vm 中有data和method了\n\n\n\n第三步将解析模板，生成虚拟 DOM，进入beforeMount()，在这里任何 DOM 最终不会生效\n\n第四步将内存中的虚拟 DOM 转为真实 DOM，然后进入mounted()，页面中呈现的是经过 Vue 编译的 DOM，对 DOM\n的操作均有效，至此初始化过程结束，一般在这进行：开启网络请求，开启定时器等初始化操作\n\n一个 Vue 属性template，使用它可以把root里的标签放入其中，但是需要所有标签只有一个根节点标签，即用一个div包裹一下，但现在我们是 html\n结构，所以后面使用\n\n\n\n\n生命周期_更新流程#\n\n在点击 n+1 后，进入更新流程，先到beforeUpdate()，此时数据更新了但页面没有更新\n\n随后根据新数据，生成新的虚拟 DOM，随后与旧的虚拟 DOM 比较，最终完成页面更新\n\n即完成了 Model➡View 的更新，进入到updated()此时数据更新了页面也更新了\n\n\n\n\n生命周期_销毁流程#\n\n当调用vm.$destroy()时进入销毁流程，触发后续钩子\n\n先进入beforeDestroy()，此时vm中所有的data、methods、指令等都处于可用状态，马上要执行销毁过程，一般在此阶段关闭定时器、取消订阅消息等\n收尾操作\n\n> 虽然在这可以调用 methods，如add()，但无法触发更新\n\n最后进入destroy()表示销毁结束\n\n\n\n\n总流程代码#\n\n\n\n\n总结生命周期#\n\n * 常用的生命周期钩子：\n   \n   * mounted: 发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等初始化操作\n   \n   * beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等收尾工作\n\n * 关于销毁 Vue 实例\n   \n   * 销毁后借助 Vue 开发者工具看不到任何信息\n   \n   * 销毁后自定义事件会失效，但原生 DOM 事件依然有效\n   \n   * 一般不会在beforeDestroy操作数据，即便操作数据，也不会再触发更新流程了\n\n上面的透明度变化例子\n\n","routePath":"/guide/vue/1-vue2基础/16-生命周期","lang":"","toc":[{"text":"生命周期","id":"生命周期","depth":2,"charIndex":-1},{"text":"引出生命周期","id":"引出生命周期","depth":3,"charIndex":7},{"text":"生命周期图示","id":"生命周期图示","depth":3,"charIndex":165},{"text":"生命周期_挂载流程","id":"生命周期_挂载流程","depth":3,"charIndex":177},{"text":"生命周期_更新流程","id":"生命周期_更新流程","depth":3,"charIndex":631},{"text":"生命周期_销毁流程","id":"生命周期_销毁流程","depth":3,"charIndex":787},{"text":"总流程代码","id":"总流程代码","depth":3,"charIndex":977},{"text":"总结生命周期","id":"总结生命周期","depth":3,"charIndex":988}],"domain":"","frontmatter":{},"version":""},{"id":118,"title":"","content":"组件#\n\n * 组件：实现应用中局部功能代码和资源的集合\n\n * 作用：复用编码，简化项目编码，提高运行效率\n\n * 非单文件组件：一个文件中包含有 n 个组件\n\n * 单文件组件：一个文件只包含有 1 个组件\n\n\n非单文件组件#\n\n基本使用#\n\nVue 中使用组件的三大步骤：定义、注册、编写\n\n * 如何定义一个组件？\n   \n   * 使用Vue.extend(options)创建，其中options和new\n     Vue(options)时传入的options几乎一样，但也有区别，区别如下：\n     \n     * el不写，因为最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器\n     \n     * data必须写成函数，为了避免组件被复用时，数据存在引用关系\n   \n   * 备注：使用template可以配置组件结构。\n\n * 如何注册组件？\n   \n   * 局部注册：靠new Vue的时候传入components选项\n   \n   * 全局注册：靠Vue.component('组件名',组件)\n\n * 编写组件标签：\n\n代码示例\n\n\n\n注意点#\n\n * 关于组件名:\n   \n   * 一个单词组成：\n     \n     * 第一种写法(首字母小写)：school\n     \n     * 第二种写法(首字母大写)：School\n   \n   * 多个单词组成：\n     \n     * 第一种写法(kebab-case 命名)：my-school\n     \n     * 第二种写法(CamelCase 命名)：MySchool (需要 Vue 脚手架支持)\n\n * 备注：\n   \n   * 组件名尽可能回避 HTML 中已有的元素名称，例如：h2、H2都不行\n   \n   * 可以使用 name 配置项指定组件在开发者工具中呈现的名字\n\n * 关于组件标签:\n   \n   * 第一种写法：\n   \n   * 第二种写法：\n   \n   * 备注：不用使用脚手架时，会导致后续组件不能渲染\n\n * 一个简写方式：\n   \n   const school = Vue.extend(options)可简写为：const school = options\n\n组件嵌套#\n\n需求：在school里包含student，school和hello外面包裹app\n\n\n\n关于 VueComponent#\n\n * 组件本质是一个名为VueComponent的构造函数，是Vue.extend生成的。\n\n * 我们只需写或，Vue 解析时会帮我们创建school组件的实例对象，Vue 帮我们执行的：new VueComponent(options)\n\n * 特别注意：每次调用Vue.extend，返回的都是一个全新的 VueComponent\n\n * 关于 this 指向：\n   \n   * 组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this 均是VueComponent\n     实例对象\n   \n   * new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this\n     均是Vue 实例对象\n\n * VueComponent 的实例对象，简称 vc（另称：组件实例对象）\n\n * Vue 的实例对象，简称 vm\n\n重要内置关系#\n\n前置知识：原型，简单例子\n\n\n\n重要的关系：\n\nVueComponent.prototype.__proto__ === Vue.prototype\n\n让组件实例化对象（vc）可以访问到 Vue 原型上的属性、方法\n\n\n\n\n\n\n单文件组件#\n\n创建xxx.vue文件，该组件有如下标签\n\n\n\n所以上面的 school 组件的例子就可以改为下面，student 可以自己试试\n\n\n\n创建App.vue组件汇总所有的组件\n\n\n\n创建main.js文件，创建 Vue 实例\n\n\n\n最终在 html 中引入main.js即可练习使用单文件组件\n\n\n\n> 后续我们会用到脚手架来创建 vue 项目，就无需通过script引入vue.js等文件","routePath":"/guide/vue/1-vue2基础/17-组件","lang":"","toc":[{"text":"组件","id":"组件","depth":2,"charIndex":-1},{"text":"非单文件组件","id":"非单文件组件","depth":3,"charIndex":107},{"text":"基本使用","id":"基本使用","depth":4,"charIndex":116},{"text":"注意点","id":"注意点","depth":4,"charIndex":496},{"text":"组件嵌套","id":"组件嵌套","depth":4,"charIndex":963},{"text":"关于 VueComponent","id":"关于-vuecomponent","depth":4,"charIndex":1014},{"text":"重要内置关系","id":"重要内置关系","depth":4,"charIndex":1465},{"text":"单文件组件","id":"单文件组件","depth":3,"charIndex":1588}],"domain":"","frontmatter":{},"version":""},{"id":119,"title":"","content":"初识 Vue#\n\n\nHello 小案例#\n\n 1. 想让 Vue 工作，就必须创建一个 Vue 实例，且要传入一个配置对象\n 2. root 容器里的代码依然符合 html 规范，不过混入了一些特殊的 Vue 语法\n 3. root 容器里的代码被称为 Vue 模版\n\nhtml 代码如下\n\n\n\n\n分析 Hello 小案例#\n\n * 如果有两个容器 root 绑定，一个 Vue 实例只会解析一个\n\n\n\n * 如果有两个 Vue 实例解析一个容器，第一个实例接管了 root，第二个实例没有作用\n\n\n\n * 容器和实例的关系为一对一，不能一对多或者多对一\n\n> 在{{}}里面写的是 JS 表达式\n> \n> 注意区分：JS 表达式和 JS 代码(语句)\n> \n>  1. 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：\n>     \n>     (1). a\n>     \n>     (2). a+b\n>     \n>     (3). demo(1)\n>     \n>     (4). x === y ? 'a' : 'b'\n> \n>  2. JS 代码(语句)\n>     \n>     (1). if(){}\n>     \n>     (2). for(){}\n\n 1. 真实开发中只有一个 Vue 实例，并且会配合着组件一起使用\n 2. 在{{xxx}}中 xxx 可以自动读取到 data 中的所有属性\n 3. 一旦 data 中的数据发生改变，那么页面中用到该数据的地方也会自动更新","routePath":"/guide/vue/1-vue2基础/2-初识Vue","lang":"","toc":[{"text":"初识 Vue","id":"初识-vue","depth":2,"charIndex":-1},{"text":"Hello 小案例","id":"hello-小案例","depth":3,"charIndex":9},{"text":"分析 Hello 小案例","id":"分析-hello-小案例","depth":3,"charIndex":148}],"domain":"","frontmatter":{},"version":""},{"id":120,"title":"","content":"模板语法#\n\n\n插值语法#\n\n\n\n\n\n\n指令语法#\n\n * 功能：用于解析标签（包括：标签属性，标签体内容，绑定事件...）\n * 备注：Vue 有很多的指令，且形式都是：v-??? ,此处仅以v-bind举例\n\n> v-bind:href=\"xxx\" 可以简写为 :href=\"xxx\" 可以动态绑定 data 里面的 xxx\n> \n> xxx 同样要写 js 表达式\n\n","routePath":"/guide/vue/1-vue2基础/3-模板语法","lang":"","toc":[{"text":"模板语法","id":"模板语法","depth":2,"charIndex":-1},{"text":"插值语法","id":"插值语法","depth":3,"charIndex":7},{"text":"指令语法","id":"指令语法","depth":3,"charIndex":19}],"domain":"","frontmatter":{},"version":""},{"id":121,"title":"","content":"数据绑定#\n\n\n单向数据绑定#\n\n> 单向绑定（v-bind）：数据只能从 data 流向页面\n\n\n\n\n双向数据绑定#\n\n> 双向绑定（v-model）：数据不仅能从 data 流向页面，还可以从页面流向 data\n> \n> 备注：\n> \n> 1.双向绑定一般都使用在表单类元素（如：input，select 等）\n> \n> 2.v-model：value 可以简写为 v-model，因为 v-model 默认收集的就是 value 值\n\n\n\n\nel 和 data 的两种写法#\n\n * el 另一种写法为\n\n\n\n * data 的另一种写法 ✔ 组件中必须使用函数式\n\n\n\n> Vue 管理的函数不用箭头函数，使用后 this 将不指向 Vue 实例","routePath":"/guide/vue/1-vue2基础/4-数据绑定","lang":"","toc":[{"text":"数据绑定","id":"数据绑定","depth":2,"charIndex":-1},{"text":"单向数据绑定","id":"单向数据绑定","depth":3,"charIndex":7},{"text":"双向数据绑定","id":"双向数据绑定","depth":3,"charIndex":51},{"text":"el 和 data 的两种写法","id":"el-和-data-的两种写法","depth":3,"charIndex":223}],"domain":"","frontmatter":{},"version":""},{"id":122,"title":"","content":"MVVM 模型#\n\n> M : 模型（Model）：对应 data 中的数据\n> \n> V：视图（View）：模板\n> \n> VM：视图模型（ViewModel）：Vue 实例对象\n\nVue 的设计借鉴了 MVVM 模型\n\n\n\n>  1. data 中所有的属性，最后都出现在了 vm 身上\n>  2. vm 身上所有的属性及 Vue 原型上的所有属性，在 Vue 模板中都可以直接使用","routePath":"/guide/vue/1-vue2基础/5-MVVM模型","lang":"","toc":[{"text":"MVVM 模型","id":"mvvm-模型","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":123,"title":"","content":"数据代理#\n\n> 通过一个对象代理对另一个对象中属性的操作即数据代理\n\n\nObject.defineProperty 方法#\n\n> 在 Vue 中数据代理类似这个方法\n\n在 js 中输入如下代码\n\n\n\n> 利用该方法生成的属性是不被枚举的(即不能被遍历)\n\n\nVue 中的数据代理#\n\n * Vue 中的数据代理：\n   \n   * 通过 vm 对象来代理 data 对象中属性的操作（读/写）\n\n * Vue 中数据代理的好处：\n   \n   * 更加方便的操作 data 中的数据\n\n * 基本原理：\n   \n   * 通过Object.defineProperty()把 data 对象中所有属性添加到 vm 上\n   * 为每一个添加到 vm 上的属性，都指定一个getter/setter\n   * 在getter/setter内部去操作（读/写）data 中对应的属性\n\n","routePath":"/guide/vue/1-vue2基础/6-数据代理","lang":"","toc":[{"text":"数据代理","id":"数据代理","depth":2,"charIndex":-1},{"text":"Object.defineProperty 方法","id":"objectdefineproperty-方法","depth":3,"charIndex":36},{"text":"Vue 中的数据代理","id":"vue-中的数据代理","depth":3,"charIndex":129}],"domain":"","frontmatter":{},"version":""},{"id":124,"title":"","content":"事件#\n\n\n事件处理#\n\n * 事件的基本使用\n   * 使用v-on:xxx 或 @xxx 绑定事件，其中 xxx 是事件名\n   * 事件的回调需要配置在 methods 对象中，最终会在 vm 上\n   * methods中配置的函数，不要用箭头函数，否则 this 指向就不将是 vm\n   * methods中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或组件实例对象\n   * @click=\"demo\"和@click=\"demo($event)\"效果一致，但后者可以传参\n\n> v-on:click 指令：当点击 button 时会找到 showInfo 的函数执行\n\n\n\n\n事件修饰符#\n\n * Vue 中的事件修饰符\n   \n   * prevent：阻止默认事件（常用）\n   \n   * stop：阻止事件冒泡（常用）\n   \n   * once：事件只触发一次（常用）\n   \n   * capture：使用事件的捕获模式\n     \n     \n     \n     > 当 div1 使用了 capture，表示 div1 在捕获阶段就处理了事件，即使我们点击的是 div2，但还是先输出了 1 然后才是 2\n   \n   * self：只有event.target是当前操作的元素时才会触发事件\n   \n   * passive：事件的默认行为立即执行，无需等待事件回调执行完毕\n     \n     > 修饰符可以连着写：@click.prevent.stop 即阻止默认事件和事件冒泡\n\n下面对 prevent 和 stop 说明，其他可以自己根据代码尝试\n\n以 prevent 举例，原本点击 a 后会弹出对话框然后会跳转到百度，但因为 prevent 阻止了默认事件，所以对话框结束后不会跳转\n\n以 stop 举例，原本点击 button 后应该只弹出一次对话框，但由于事件冒泡会多弹出一次，加了 stop 之后就发现多出的一次消失了，阻止了事件冒泡\n\n\n\n\n键盘事件#\n\n * Vue 中常用的按键别名\n   \n   > enter 也可以写为 Enter 其余同理，不过为了方便就全小写了\n\n按键操作   别名\n回车     enter\n删除     delete(捕获“删除”和“退格”键)\n退出     esc\n空格     space\n换行     tab(特殊：tab 自带切换焦点，必须配合 keydown 使用)\n上      up\n下      down\n左      left\n右      right\n\n * Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case(短横线命名)\n   \n   > 如@keyup.caps-lock 原本为 CapsLock 但要改为如上形式\n\n * 系统修饰键(用法特殊)：Ctrl 键，Alt 键，Shift 键，Meta 键(Windows 即 Win 键)\n   \n   * 配合 keyup 使用：按下修饰键的同时再按下其他键，随后释放其他键，事件才被触发\n   \n   * 配合 keydown 使用：正常触发事件\n     \n     > 可以通过连续写法来指定快捷键：@keyup.ctrl.y 只有用 Ctrl 键+Y 键才能触发\n\n * 可以使用 keyCode 去指定具体的按键（不推荐）\n\n * Vue.config.keyCodes.自定义键名 = 键码，可以定制按键别名\n\n","routePath":"/guide/vue/1-vue2基础/7-事件","lang":"","toc":[{"text":"事件","id":"事件","depth":2,"charIndex":-1},{"text":"事件处理","id":"事件处理","depth":3,"charIndex":5},{"text":"事件修饰符","id":"事件修饰符","depth":3,"charIndex":306},{"text":"键盘事件","id":"键盘事件","depth":3,"charIndex":860}],"domain":"","frontmatter":{},"version":""},{"id":125,"title":"","content":"计算属性与监视(侦听)属性#\n\n\n姓名案例-引出计算属性-computed#\n\n效果：两个输入框，一个输入姓，一个输入名，最后一个 span 显示全名，需要实时更改\n\n * 使用插值语法实现\n\n\n\n * 使用 methods 实现\n\n\n\n * 计算属性 computed✔\n   * 定义：要用的属性不存在，需要通过已有属性计算得来\n   * 原理：底层借助Object.defineproperty方法提供的 getter 和 setter\n   * get 函数什么时候执行\n     * 初次读取时会执行一次\n     * 当依赖的数据发生改变时会再次执行\n   * 优势：与 methods 相比，内部有缓存机制（复用），效率高且调试方便\n   * 备注：\n     * 计算属性最终会出现在绑定的 Vue 实例 vm 上，直接读取使用即可\n     * 如果计算属性要被修改，必须写 set 函数去响应修改，且 set 中要引起依赖数据发生变化\n\n\n\n💬 如果只需读取不修改，可以简写为下面形式(即直接一个函数)\n\n\n\n\n天气案例-引出监视属性-watch#\n\n效果：页面一个按钮，点击切换页面中的天气(文字)，今天天气很凉爽(炎热)\n\n * 以之前的学的知识的写法\n\n\n\n * 监视属性 watch✔(侦听属性)\n   * 当监视属性变化时，回调函数自动调用，进行相关操作\n   * 监视的属性必须存在才能进行监视\n   * 监视的两种写法\n     * new Vue时传入 watch 配置\n     * 通过vm.$watch监视\n   * 深度监视-deep\n     * Vue 中的 watch 默认不监测对象内部值的改变(一层)\n     * 配置deep:true可以监测对象内部值改变(多层)\n     * 备注：\n       * Vue 自身可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以\n       * 使用 watch 时根据数据的具体结构，决定是否采用深度监视\n\n\n\n💬 如果无需immediate:true和deep:true就可以简写为如下\n\n\n\n\ncomputed 和 watch 的区别#\n\n * computed 能完成的功能，watch 都可以完成\n * watch 能完成的功能，computed 却不一定能，如 watch 可以在数据变化时执行异步的操作时\n * 小原则\n   * 所有被 Vue 管理的函数，写成普通函数，这样 this 指向为 Vue 组件实例对象\n   * 所有不被 Vue 管理的函数，如定时器的回调函数，Ajax 的回调函数等，写成箭头函数，这样 this 指向不会被干扰，最终指向为 Vue\n     组件实例对象","routePath":"/guide/vue/1-vue2基础/8-计算属性与监视(侦听)属性","lang":"","toc":[{"text":"计算属性与监视(侦听)属性","id":"计算属性与监视侦听属性","depth":2,"charIndex":-1},{"text":"姓名案例-引出计算属性-computed","id":"姓名案例-引出计算属性-computed","depth":3,"charIndex":16},{"text":"天气案例-引出监视属性-watch","id":"天气案例-引出监视属性-watch","depth":3,"charIndex":466},{"text":"computed 和 watch 的区别","id":"computed-和-watch-的区别","depth":3,"charIndex":910}],"domain":"","frontmatter":{},"version":""},{"id":126,"title":"","content":"{{name}}\n\n\n{{name}}\n\n\n{{name}}\n\n\n{{name}}\n\n\n{{name}}","routePath":"/guide/vue/1-vue2基础/9-Class与Style绑定","lang":"","toc":[{"text":"Class 与 Style 绑定","id":"class-与-style-绑定","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":127,"title":"","content":"创建 Vue 脚手架#\n\n安装 vue 脚手架Vue CLI\n\n> 现在官方推荐使用 create-vue 来创建基于 Vite 的新项目，本文档使用 Vue CLI，该脚手架是基于 webpack 的\n\n\n\n创建一个项目，选择 Vue2 项目\n\n\n\n等到安装完后，切换启动\n\n","routePath":"/guide/vue/2-vue2进阶/1-创建Vue脚手架","lang":"","toc":[{"text":"创建 Vue 脚手架","id":"创建-vue-脚手架","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":128,"title":"","content":"浏览器本地存储#\n\n> 如果对这块内容熟悉可以跳过\n\n\nlocalStorage#\n\n一些网站在搜索过后会有搜索历史，那么这是如何存储的呢？一般就是通过localStorage来存储的，打开控制台，点击应用可以看到本地存储空间\n\n\n\n新建一个 HTML 文件，如下\n\n\n\n\nsessionStorage#\n\nsessionStorage特点：浏览器一关闭就没有了\n\n新建 HTML 文件，代码几乎和上面一样\n\n\n\n\n总结 WebStorage#\n\n 1. 存储内容大小一般支持 5MB 左右（不同浏览器可能还不一样）\n\n 2. 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制\n\n 3. 相关 API：\n    \n    * xxxxxStorage.setItem('key', 'value');\n      该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值\n    \n    * xxxxxStorage.getItem('person');\n    \n    该方法接受一个键名作为参数，返回键名对应的值\n    \n    * xxxxxStorage.removeItem('key');\n    \n    该方法接受一个键名作为参数，并把该键名从存储中删除\n    \n    * xxxxxStorage.clear()\n    \n    该方法会清空存储中的所有数据\n\n 4. 备注：\n    \n    * SessionStorage 存储的内容会随着浏览器窗口关闭而消失。\n    \n    * LocalStorage 存储的内容，需要手动清除才会消失。\n    \n    * xxxxxStorage.getItem(xxx)如果 xxx 对应的 value 获取不到，那么 getItem 的返回值是 null。\n    \n    * JSON.parse(null)的结果依然是 null。\n\n\nTodoList_本地存储#\n\n我们之前的数据是写死的，刷新后新添加的就没了，所以将数据放入localStorage来持久化\n\n在App.vue中添加watch来监视，此处只改变script，这里要开启深度监视，因为如果不开启，改变对象里面的值，watch是不监视的\n\n","routePath":"/guide/vue/2-vue2进阶/10-浏览器本地存储","lang":"","toc":[{"text":"浏览器本地存储","id":"浏览器本地存储","depth":2,"charIndex":-1},{"text":"localStorage","id":"localstorage","depth":3,"charIndex":27},{"text":"sessionStorage","id":"sessionstorage","depth":3,"charIndex":136},{"text":"总结 WebStorage","id":"总结-webstorage","depth":3,"charIndex":207},{"text":"TodoList_本地存储","id":"todolist_本地存储","depth":3,"charIndex":866}],"domain":"","frontmatter":{},"version":""},{"id":129,"title":"","content":"We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly\nwithout JavaScript enabled. Please enable it to continue.\n","routePath":"/guide/vue/2-vue2进阶/2-分析脚手架结构","lang":"","toc":[{"text":"分析脚手架结构","id":"分析脚手架结构","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":130,"title":"","content":"render 函数#\n\n之前我们在main.js中出现了一个我们不认识的render函数，这地方我们不认识，如果我们使用之前的方法\n\n\n\n会发现出现报错，因为该处引入的是 Vue 是一个残缺的，它缺少了模板解析器，具体到vue/dist/vue.runtime.esm.js，在 dist 目录下的\nvue.js 才是无缺的，其他都是为了精简产生的\n\n想要解决该报错，第一个解决方法是引入无缺的vue.js\n\n\n\n第二个解决方法就是使用render函数\n\n\n\n但由于没有用到 this，且只有一行，然后我们创建的是App组件，就可以简化为下面\n\n\n\n\n关于不同版本的 Vue#\n\n * vue.js与vue.runtime.xxx.js的区别：\n   \n   * vue.js是完整版的 Vue，包含核心功能和模板解析器\n   \n   * vue.runtime.xxx.js是运行版的 Vue，只包含核心功能，没有模板解析器\n\n * 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数\n   去指定具体内容\n\n\n配置文件#\n\n如果需要自定义脚手架的配置，则需要在根目录下创建vue.config.js文件\n\n\n\n 1. 在终端输入vue inspect > output.js查看 Vue 脚手架的默认配置\n 2. 使用vue.config.js对脚手架进行个性化定制\n\n> 详情见：https://cli.vuejs.org/zh","routePath":"/guide/vue/2-vue2进阶/3-render函数","lang":"","toc":[{"text":"render 函数","id":"render-函数","depth":2,"charIndex":-1},{"text":"**关于不同版本的 Vue**","id":"关于不同版本的-vue","depth":3,"charIndex":-1},{"text":"配置文件","id":"配置文件","depth":3,"charIndex":508}],"domain":"","frontmatter":{},"version":""},{"id":131,"title":"","content":"ref 属性#\n\n想要获取 dom 元素，可以采用ref属性\n\n * 被用来给元素或子组件注册引用信息（id 的替代者）\n\n * 应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象（vc）\n\n * 使用方式：\n   \n   * 打标识：\n     \n     \n     .....\n     \n     或\n   \n   * 获取：this.$refs.xxx\n\n","routePath":"/guide/vue/2-vue2进阶/4-ref属性","lang":"","toc":[{"text":"ref 属性","id":"ref-属性","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":132,"title":"","content":"props 配置项#\n\n * 功能：让组件接收外部传过来的数据\n\n * 传递数据：\n\n * 接收数据：\n   \n   * 第一种方式（只接收）：props:['name']\n   \n   * 第二种方式（限制类型）：props:{name:String}\n   \n   * 第三种方式（限制类型、限制必要性、指定默认值）：\n     \n     \n\n> 备注：props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props\n> 的内容到 data 中一份，然后去修改 data 中的数据。\n\nApp.vue文件，传入学生信息\n\n\n\nStudent.vue接收参数\n\n","routePath":"/guide/vue/2-vue2进阶/5-props配置项","lang":"","toc":[{"text":"props 配置项","id":"props-配置项","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":133,"title":"","content":"mixin(混入)#\n\n * 功能：可以把多个组件共用的配置提取成一个混入对象\n\n * 使用方式：\n   \n   * 第一步定义混合：\n   \n   \n   \n   * 第二步使用混入：\n     \n     全局混入：Vue.mixin(xxx) 局部混入：mixins:['xxx']\n\n需求：需要将共用的配置提取出来\n\nSchool.vue文件\n\n\n\nStudent.vue文件\n\n\n\n创建mixin.js文件，在main.js文件的同级目录下\n\n\n\n上面我将局部引入给注释，下面在main.js中可以进行全局引入\n\n","routePath":"/guide/vue/2-vue2进阶/6-mixin(混入)","lang":"","toc":[{"text":"mixin(混入)","id":"mixin混入","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":134,"title":"","content":"插件#\n\n * 功能：用于增强 Vue\n * 本质：包含install方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据\n * 定义插件，如下\n\n在 src 文件夹下创建plugins.js文件\n\n\n\n * 使用插件：Vue.use()\n   \n   在main.js文件使用插件，可以自己在 Student 组件和 School 组件尝试插件\n\n","routePath":"/guide/vue/2-vue2进阶/7-插件","lang":"","toc":[{"text":"插件","id":"插件","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":135,"title":"","content":"scoped 样式#\n\n * 作用：让样式在局部生效，防止冲突\n * 写法：\n   \n   在Student组件写样式，中间 script 部分省略，这里加上了lang=\"less\"表示使用 less\n   \n   > 此时会报错，需要下载less-loader，在终端输入如下代码安装\n   \n   这里两个类名一样冲突了，School 的背景色变为粉色，因为在 App 中我们后引入 Student\n   \n   但是如果我们在 style 中加上scoped，因为scoped让样式在局部生效，就会发现不冲突了\n   \n   \n   \n   在App组件中写样式，中间 script 部分省略\n   \n   ","routePath":"/guide/vue/2-vue2进阶/8-scoped样式","lang":"","toc":[{"text":"scoped 样式","id":"scoped-样式","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":136,"title":"","content":" * xxxxx 删除\n * yyyy 删除\n\n已完成0 / 全部2 清除已完成任务","routePath":"/guide/vue/2-vue2进阶/9-Todo-list案例","lang":"","toc":[{"text":"Todo-list 案例","id":"todo-list-案例","depth":2,"charIndex":-1},{"text":"拆分组件和功能描述","id":"拆分组件和功能描述","depth":3,"charIndex":-1},{"text":"静态组件撰写","id":"静态组件撰写","depth":3,"charIndex":-1},{"text":"初始化列表","id":"初始化列表","depth":3,"charIndex":-1},{"text":"添加","id":"添加","depth":3,"charIndex":-1},{"text":"勾选","id":"勾选","depth":3,"charIndex":-1},{"text":"删除","id":"删除","depth":3,"charIndex":-1},{"text":"底部统计","id":"底部统计","depth":3,"charIndex":-1},{"text":"底部交互","id":"底部交互","depth":3,"charIndex":-1},{"text":"总结案例","id":"总结案例","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":137,"title":"","content":"学习结构#\n\n本章你将学习到如下知识\n\n","routePath":"/guide/vue/","lang":"","toc":[{"text":"学习结构","id":"学习结构","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":138,"title":"","content":"从零手写 create-react-app#\n\n前置知识：\n\n * yarn包管理\n * workspace工作区知识概念\n * Monorepo知识概念\n\n\n初始化#\n\n一些知识科普讲解\n\n * Lerna 是一个用于管理具有多个包（packages）的 JavaScript 项目的工具。在一个大型 JavaScript\n   项目中，通常会有多个独立的模块或包，这些包可能相互依赖，或者需要一起发布。\n\n * 工作区（Workspace）通常是指在一个项目中，可以同时处理多个相关联的子项目（packages，modules等），而不需要将它们分别作为独立的项目来\n   处理。在软件开发领域，工作区通常是指一个包含了多个子项目的项目容器，这些子项目可以共享一些配置、依赖关系和构建流程。\n\n * Monorepo是\n   \"单一代码仓库\"（Monorepository）的缩写，它是一种软件开发的组织结构模式，其中所有项目或者库的代码都放在一个单一的版本控制仓库中。通常，这种\n   仓库包含了多个相关的项目、库或者组件，这些项目可能共享某些代码、依赖关系或者配置。\n\n全局安装 lerna\n\n\n\n输入如下检测是否安装成功\n\n\n\n在要创建的文件夹，打开终端，输入如下初始化\n\n\n\n打开后，这里我用 yarn管理，终端输入\n\n\n\n两个作用：安装lerna和它的依赖，在根目录的node_modules里面创建软链接，链向各个packages中的各个包\n\n> yarn 支持workspace npm只有在7版本以上支持\n> \n> yarn workspace VS lerna\n> \n> yarn重点在于包管理、处理依赖和软链\n> \n> lerna重点在于多个项目管理和发布\n\n然后创建 packages 文件夹（workspace），最终形成的初始文件目录如下\n\n\n\n\n创建 package#\n\n创建 create-react-app#\n\n在终端输入,然后在协议(license)改为 MIT，入口(main)改为index.js其它不变\n\n\n\n然后进入，把一些无用的删除，最终形成如下\n\n\n\n创建react-scripts#\n\n终端输入\n\n\n\n创建cra-template#\n\n终端输入\n\n\n\n查看工作包#\n\n终端输入\n\n\n\n\n\n最终形成的结构图如下\n\n\n\n\n添加依赖#\n\n在添加之前记得要设置为淘宝源，不然可能会安装很慢\n\n安装如下依赖\n\n\n\n>  * chalk: chalk 是一个用于在终端中添加颜色和样式的库。它允许你在命令行界面中使用不同的颜色和样式来输出文本，使得输出更加清晰和易读。\n>  * cross-spawn: cross-spawn 是一个用于跨平台（Windows、Linux、Mac\n>    等）运行子进程的库。它解决了在不同操作系统下创建子进程的差异性，使得在 Node.js 环境中能够一致地运行子进程。\n>  * fs-extra: fs-extra 是 Node.js 的文件系统模块（fs\n>    模块）的扩展，提供了更多的功能和便捷的方法，使得文件和目录的操作更加容易和灵活。\n>  * --ignore-workspace-root-check:这是 yarn add 命令的一个选项。当你在一个使用 Yarn\n>    工作区（Workspace）的项目中执行 yarn add 命令时，默认情况下 Yarn\n>    会检查你是否在工作区的根目录（root）中运行该命令。如果你使用了 --ignore-workspace-root-check 选项，Yarn\n>    将忽略这个检查，允许你在工作区的任意位置执行 yarn add 命令。\n\n在lerna里面，packages里面的各个会在node_modules里面形成符号链接即软链，这样可以在别的package中访问另一个package\n\n\n\n然后可以根据工作空间安装如下依赖\n\n\n\n> commander 是一个用于构建命令行界面（CLI）的 Node.js\n> 框架。它可以帮助开发者轻松地构建复杂和易用的命令行工具，提供了处理命令行参数、解析用户输入、显示帮助信息等功能\n\n\ncreateReactApp.js文件#\n\n在根目录package.json添加脚本命令\n\n\n\n在packages中的create-react-app文件夹的index.js文件更改\n\n\n\n在create-react-app文件夹中新建createReactApp.js文件\n\n> 由于接下来我们需要用到刚刚安装的依赖，我们可以快速学习一下\n\n\n\ninit函数#\n\n然后我们开始写createReactApp.js文件\n\n\n\n如果报错等，可以修改package.json文件的chalk，高版本可能有错\n\n\n\n在终端运行如下测试是否成功\n\n> -- 后面代码传参\n\n\n\n此处我们传入项目名，最终终端会输出 myApp\n\n\n\ncreateApp函数#\n\n然后在createReactApp.js中创建createApp函数，在init中添加，并修改init为async\n\n\n\n> 这里用到了path模块和fs-extra模块\n\n\n\n在终端执行,就会生成一个文件夹myApp并有一个package.json文件了\n\n\n\n\n\n> 扩展 JSON.stringify\n> \n> 如下代码\n> \n> \n> \n> 打印结果如下\n\nrun函数#\n\n在createApp函数最后加上执行run函数\n\n\n\n创建run函数\n\n\n\ninstall函数#\n\n> 这里用到了cross-spawn模块，记得导入\n\n创建install函数\n\n\n\n> cross-spawn 是一个用于跨平台（Windows、Linux 和 macOS）的 Node.js 包，用于跨平台地启动子进程。\n> \n> \n> \n> 换成这个就熟悉了吧\n\nexecuteNodeScript函数#\n\n> 拷贝模板的文件\n\n在run函数中补充\n\n\n\n创建executeNodeScript函数\n\n\n\n> 上述简化的意思是通过node执行脚本\n> \n> 即把data里面的数据放到了node后面\n> \n> 如下，执行出来就是输出aaa\n> \n> \n> \n> process.argv是一个包含命令行参数的数组\n> \n> \n> \n> 如下输出 就会发现上面abc也带入了\n\n此时基本完成，我们在终端输入\n\n\n\n安装上述的四个模块\n\n\n\n拷贝模板文件到bbb文件夹下\n\n\n\n然后会删除cra-template模块因为拷贝完了\n\n\n\n最终安装成功，cd bbb切换到bbb文件夹，输入yarn start查看是否启动成功\n\n\n\n查看bbb文件目录，发现和我们平时用cra创建的一样\n\n\n\n至此手写create-react-app已完成\n\n\n手写react-scripts编译#\n\n> create-react-app流程\n> \n>  * 执行命令\n>  * 创建了一个React项目\n>  * 安装依赖包\n>  * 初始化git，拷贝模板，安装模板依赖\n>  * 移除模板，成功\n\n\n\nreact-scripts.js#\n\n初始化#\n\n在package.json中配置\n\n\n\n在根目录的package.json配置\n\n\n\n在react-scripts文件夹创建bin文件夹，并创建react-scripts.js文件\n\n\n\n终端执行npm run build，输出done证明成功\n\n书写#\n\n在react-scripts文件夹下新建scripts文件夹，并创建build.js文件\n\n\n\n书写react-scripts.js文件\n\n\n\n根目录终端输入npm run build，输出build.js证明成功\n\nbuild.js#\n\n在react-scripts文件夹下新建config文件夹，并创建webpack.config.js文件和path.js文件\n\n> 在根目录下缺少什么依赖就安装什么依赖，如@babel/preset-react\n\n\n\n\n\n书写build.js文件\n\n\n\n在react-scripts目录随意创建public和src，public创建index.html并添加id为root的div，src创建index.js并输入\n如下\n\n\n\n在react-scripts中修改package.json,并安装\n\n\n\n随后终端输入npm run build，成功打包，生成build目录里面有所创建的压缩文件\n\nstart命令#\n\n根目录package.json配置,与build一样\n\n\n\n在在react-scripts的config里新建webpackDevServer.config.js\n\n\n\n在react-scripts的scripts里新建start.js\n\n\n\n在终端输入npm run start就会看到我们上面创建index.js所要显示的Hello World\n\n至此build和start命令我们都完成了，下面有源码讲解，如果上面有点吃力，建议再加深知识后来查看。\n\n\n源码解析#\n\n\nreact-scripts.js源码#\n\n\n\n\nbuild.js#\n\n\n\n\nenv.js#\n\n\n\n\nwebpack.config.js#\n\n展现部分代码，源代码配置等过多\n\n","routePath":"/handwriting/create-react-app/","lang":"","toc":[{"text":"从零手写 create-react-app","id":"从零手写-create-react-app","depth":2,"charIndex":-1},{"text":"初始化","id":"初始化","depth":3,"charIndex":79},{"text":"创建 package","id":"创建-package","depth":3,"charIndex":788},{"text":"添加依赖","id":"添加依赖","depth":3,"charIndex":984},{"text":"createReactApp.js文件","id":"createreactappjs文件","depth":3,"charIndex":1751},{"text":"init函数","id":"init函数","depth":4,"charIndex":1925},{"text":"createApp函数","id":"createapp函数","depth":4,"charIndex":2063},{"text":"run函数","id":"run函数","depth":4,"charIndex":2260},{"text":"install函数","id":"install函数","depth":4,"charIndex":2306},{"text":"executeNodeScript函数","id":"executenodescript函数","depth":4,"charIndex":2452},{"text":"手写react-scripts编译","id":"手写react-scripts编译","depth":3,"charIndex":2839},{"text":"react-scripts.js","id":"react-scriptsjs","depth":4,"charIndex":2962},{"text":"build.js","id":"buildjs","depth":4,"charIndex":3225},{"text":"start命令","id":"start命令","depth":4,"charIndex":3534},{"text":"源码解析","id":"源码解析","depth":2,"charIndex":3774},{"text":"react-scripts.js源码","id":"react-scriptsjs源码","depth":3,"charIndex":3782},{"text":"build.js","id":"buildjs-1","depth":3,"charIndex":3806},{"text":"env.js","id":"envjs","depth":3,"charIndex":3820},{"text":"webpack.config.js","id":"webpackconfigjs","depth":3,"charIndex":3832}],"domain":"","frontmatter":{},"version":""},{"id":139,"title":"","content":"学习结构#\n\n","routePath":"/handwriting/","lang":"","toc":[{"text":"学习结构","id":"学习结构","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":141,"title":"学习路线","content":"#\n\n\n基础阶段#\n\n * HTML：HTML4到HTML5，一些新特性要了解，比如contenteditable属性\n * CSS：CSS方面比较关键，分几个节点\n   * 第一个阶段：熟悉基本语法到CSS3\n   * 第二个阶段：学会运用预处理器如Less，Sass，学会CSS Module（普通实习够了）\n   * 第三个阶段：学会原子化 CSS 如TailwindCSS，UnoCSS（进阶）\n   * 第四个阶段：学会运用后处理器PostCSS，运用各个插件（进阶）\n * JavaScript：JavaScript主要为如下\n   * 基本语法，操作 DOM，BOM 等\n   * ES6+后的语法\n   * 正则表达式\n   * 设计模式（发布订阅模式建议学好，很常用，其他如单例模式了解即可）\n   * TypeScript：JS 的超集，我的建议是在学完 js 后就先了解好 ts 的基本语法，对以后有帮助\n   * Canvas（可选，有 2D 和 3D）\n * 数据结构和算法：学好这个对后面的源码部分有帮助\n   * 数组：队列，链表，哈希表等等\n   * 排序：双指针，二分（比较重要）等等\n * 数据交互：这块就是和后端交流最多的地方了，也分阶段\n   * （基本）Ajax：学好最基础的交互方法\n   * （基本）Axios：Ajax 的封装常用库，分几个小阶段\n     * 掌握基本用法\n     * 进阶就是你用 Ajax 自己封装出一个简单的 Axios\n     * 更进一步就是二次封装 axios，这点在项目中很多\n   * （基本）Fetch：建议掌握\n   * （进阶）WebSocket，SSE\n   * （必备）网络模式，HTTP 协议，TCP 三次握手四次挥手等，就是计算机网络部分，部分大公司很看重\n\n\n提升阶段#\n\n * 包管理工具，目前较多，基本只需了解命令，进阶的话需要了解工作区等概念\n   * npm（node 官方）\n   * cnpm（不推荐了现在）\n   * yarn（一般）\n   * pnpm（推荐，在速度方面很快且在后续的 Monorepo 项目中运用多）\n * 工程化：即构建工具一类，目前来说你想学深必须学好这里，如果很急的话暂时可以跳过，但不急的话建议先学懂这块再去学框架会更好\n   * Webpack：老牌常用的工具，进阶就是会定制插件\n   * Vite：新生代，构建很快，进阶就是会定制插件\n   * Gulp：不推荐了\n   * EsBuild：可选\n   * SWC：可选\n   * Babel：让我们使用新语法和 api，babel 会在编译中转为目标环境的支持的语法（进阶必学）\n * 项目管理：Git，学会多提交 github 代码，这里不多表述\n * 框架：主要分几个\n   * React：生态丰富，主要学好hooks，函数式编程已成主流，基本的库如下\n     * React-Router：路由\n     * Redux：状态管理，也有其替代如Zustand也用的多\n     * Antd：UI 库，我的建议是学的时候可以自己尝试用原生写一个类似的组件，因为企业中的需求很多不一样，需要自己定制一些 UI 组件库（后面 UI\n       库单独列一下）\n     * 进阶的一些如动画库 react-transition-group，可以根据需求寻找\n   * Vue：生态丰富，现在 Vue2 版本虽然停止维护，但还是建议学，很多面试会问 Vue2 和 Vue3 的区别\n     * Vue-Router：路由\n     * Vuex：状态管理，有Pinia替换\n   * Angular：老牌，但国内用的少，需要掌握 Rxjs\n   * Solid：新生，国内用的少\n * UI 组件库单独：\n   * PC 端\n     * Element UI\n     * Ant Design\n     * IView\n   * H5 端\n     * Vant（用的最多）\n     * Muse UI\n   * 小程序：（一般来说大前端包括小程序）\n     * Vant 和 iview\n\n\n进阶阶段#\n\n一般来说你学会前面的时候，运用好框架做好项目就可以实习了，这时候只要基础好基本没问题\n\n下面的内容就是进阶部分了，一般来说在实习不会问，源码方面大公司问的多，普通实习的同学了解即可\n\n * SSR服务器渲染：有利于 SEO 搜索引擎优化，一般是进阶学习\n   \n   * NuxtJS（运用在 Vue 框架）\n   * NextJS（运用在 React 框架）\n\n * 小程序：大部分公司都是前端写小程序，所以有必要还是学一下，实习的话一般不需要\n   \n   * 原生小程序（不推荐）\n   * Uniapp\n   * Taro\n\n * 跨端：如安卓，iOS\n   \n   * Uniapp：用的挺多\n   * Flutter：这个可选，因为需要学习一门新的语言 dart，所以难度较高\n   * HTML5 Plus：挺常用的\n   * Hybrid：很常用，可以嵌入到原生安卓和 ios 开发\n   * ReactNative：React 的跨端，学过 react 的话上手难度很低，很不错\n\n * 源码：这块很多问的大多都是框架的底层，很多大公司会问，建议多看网上八股和看源代码\n   \n   * Vue：如 v2 和 v3 底层实现，diff 算法等等\n   * React：如 fiber 架构，hooks 的区别等\n\n * 可视化：可选，一些公司用，技术如 Echarts，DataV，Ucharts 等\n\n * 微前端：可选，进阶学，大公司一般有用\n   \n   * 乾坤（阿里）\n   * macro APP（京东）\n   * 无界（腾讯）\n\n * 服务器：想要进阶的必备\n   \n   * Linux 的基础\n   * Nginx 基础，Nginx 的插件，lua 语言\n   * Pm2: 很常用的服务器库，进阶必备\n\n * 技术方案：各个需求的整合\n   \n   * 主题切换：如白天黑夜\n   \n   * 数据埋点和服务监控：大公司非常常用！\n   \n   * 性能监控和指标分析：作为高级工程师必须考虑好性能问题\n   \n   * monorepo：该项目想要用到另一个项目的东西，就需要这个技术了，目前 pnpm 方案很不错\n     \n     > 很大一部分你所熟知的项目都是该架构，如 React 框架\n   \n   * 国际化：如果需要发布在外国，就需要该技术的支持了\n\n * NodeJS：它是贯穿整个项目的基石，各个包各个库都是通过 node 来运作，作为 JavaScript 的运行时，它的重要性无可置疑\n   \n   * 包管理工具，上面已有概述\n   \n   * 核心模块：如 process，child_process，net，os，util 等\n   \n   * Express：前端变全栈的基石\n     \n     * Koa：集成框架，流行度高\n     * Egg：不推荐，毕竟该项目业务团队都没了\n     * Nest：很流行的框架，尤其在国外用的很多\n   \n   * Mysql：学会数据库才知道后端，所用技术为mysql2\n   \n   * ORM：调用数据库的集成框架\n     \n     * Knex：新手上手\n     * Prisma：最常用的框架，集成了多种数据库\n   \n   * Redis：内存数据结构存储系统，很常用，使用技术为ioredis\n   \n   * lua：一种轻量级、高效、可嵌入的脚本语言，在自动化方面很常用\n   \n   * serverLess：无服务器架构模式，建议学\n   \n   * 爬虫：没想到吧，node 也可以做爬虫相关的，所用技术为puppeteer\n   \n   * 学无止境，node 还有定制脚手架，定制命令行交互，甚至可以做嵌入式！\n\n\n学无止境阶段#\n\n这个阶段一般来说就是选择自己感兴趣的了，学习的路线远不止这些，各类技术层不出穷\n\n我只介绍一部分仅供扩展视野\n\n * SSG 技术：静态站点生成\n   \n   * VitePress：很常用的 SSG 技术框架\n   * Next：支持 SSG\n   * Rspress：字节开源的基于 rust 的 ssg 框架\n\n * 桌面开发：\n   \n   * Electron：常用的跨桌面端开发框架\n   * NW.js：以前常用的框架\n   * Tarui + Rust：新生代构建\n\n * Web系列：目前来说很多地方都有用，但只有用到的时候才学\n   \n   * WebGL：专门做图形绘制和渲染的\n     \n     * three.js框架：3D 渲染\n     * openGL：需要学着色器语言，学习图形学\n     * 数学：做图形绘制需要用到数学的向量、矩阵、三角函数等等\n   \n   * WebRTC：该技术主要用于音视频通话，浏览器录屏等\n   \n   * Web Socket：主要用于聊天室等等\n   \n   * Web Worker：允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js\n     操作多线程的能力。\n   \n   * Web SQL、IndexDB：存储大量客户端数据，推荐 IndexDB\n   \n   * Web Components：用于构建可复用用户组件的技术\n   \n   * Web Assembly：简称 wasm，一种通用字节码技术，它可以将其他编程语言（如 Go、Rust、C/C++\n     等）的程序代码编译为可在浏览器环境直接执行的字节码程序。\n     \n     > 想不到吧，浏览器也可以跑 C 和 C++这种代码\n   \n   * Web GPU：用于在 Web 应用程序中访问 GPU 的功能，js 也能调硬件！\n   \n   * Web View：跨端中为什么 h5 可以做呢，就是运用它，可以在原生中通过网络引入 h5 从而嵌入\n   \n   * Web AR：通过传感器等实现智能交互等\n   \n   * Web Serial：允许网站从串行设备通过脚本读取和写入的方式微控制器、3D 打印机和其他串行设备等设备进行通信的一套\n     API，通过它我们就可以和单片机通信了！神奇不！\n   \n   * Web Containers：基于 wasm 的系统，可在浏览器端启动nodejs环境！\n\n * JavaScript 运行时：新生代有bun包子技术\n\n * 区块链：Web3JS 技术\n\n * 游戏开发：Cocos，虚幻五\n\n * 嵌入式开发：Ruff js\n\n * 人工智能：TensorFlow 和 face-api\n\n学习的路线永无止境，加油吧同志们！","routePath":"/study","lang":"","toc":[{"text":"基础阶段","id":"基础阶段","depth":2,"charIndex":3},{"text":"提升阶段","id":"提升阶段","depth":2,"charIndex":780},{"text":"进阶阶段","id":"进阶阶段","depth":2,"charIndex":1755},{"text":"学无止境阶段","id":"学无止境阶段","depth":2,"charIndex":3348}],"domain":"","frontmatter":{},"version":""}]