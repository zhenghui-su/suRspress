## 前端框架的分类

> 问：现代前端框架不仅仅是React、Vue,还出现了像Svelte、Solid.js 之类的框架，你觉得这些新框架相比React、Vue有什么样的区别?

### 自变量和因变量

现代前端框架，有一个非常重要的特点，那就是基于状态的声明式渲染。如果要概括的话，可以使用一个公式:

> UI = f (state)

+ state：当前视图的一个状态
+ f：框架内部的一个运行机制
+ UI：宿主环境的视图描述

state的变化会导致最终计算出来的 UI 发生变化，所以 state 是自变量，UI 就是因变量

目前在 React 中有很多 Hook，例如：

```jsx
const [x, setX] = useState(0);
```

比如上面的代码，我们就是定义了一个自变量

```jsx
function App(){
    const [x, setX] = useState(0);
    return <div onClick={() => setX(x+1)}>{x}</div>
}
```

上面的 useState 这个 hook 可以看作是定义了一个自变量，自变量一变化，就会到导致依赖它的因变量发生变化，在上面的例子中，返回的 jsx 所描述的 UI 就是因变量。

因变量又可以分为两类：

+ 没有副作用的因变量
+ 有副作用的因变量

**没有副作用的因变量**

在 React 中，useMemo就是定义一个没有副作用的因变量

```jsx
const y = useMemo(() => x * 2 + 1, [x]);
```

在上面的代码中，我们使用 useMemo 定义了一个没有副作用的因变量y，y的值取决于x的值，x的值一变化，y的值也会跟着变化

**有副作用的因变量**

在 React 中，可以使用 useEffect 来定义一个有副作用的因变量

```jsx
useEffect(() => document.title = x, [x]);
```

上面的代码依赖于自变量x的变化，当x发生变化的时候，会修改页面的标题，这就是一个副作用操作。

那么接下来，我们来总结一下：自变量的变化，会导致三种情况的因变量发生改变:

+ 自变量的变化，导致UI因变量变化

```jsx
function Count() {
    const [num, setNum] = useState(0);
    return(
    	<div onClick={() => setNum(num+1)}>{num}</div>
    )
}
```

+ 自变量的变化，导致无副作用的因变量发生变化

```jsx
function Count() {
    const [num, setNum] = useState(0);
    const fiexedNum = useMemo(() => num.toFiexed(2), {num});
    return(
    	<div onClick={() => setNum(num+1)}>{fiexedNum}</div>
    )
}
```

+ 自变量的变化，导致有副作用的因变量发生变化

```jsx
function Count() {
    const [num, setNum] = useState(0);
	useEffect(() => document.title=num, [num]);
    return(
    	<div onClick={() => setNum(num+1)}>{num}</div>
    )
}
```

### 框架的分类

上面我们介绍了自变量和因变量，state 实际上就是自变量，自变量的变化直接或者间接的改变了 UI，上面的公式实际上还可以分为两个

+ 根据自变量 state 计算出 UI 的变化
+ 根据 UI 的变化执行具体的宿主环境的 API

以前端工程师最熟悉的浏览器为例，那么第二个步骤就是执行DOM相关API，对于这个步骤来讲，不同的框架实际上实现基本是相同的，这个步骤不能作为框架分类的依据，差别主要体现在步骤一上面。所以步骤一也是针对各大框架的一个分类依据

前端框架需要关注自变量和x (UI、 组件、应用)的对应关系，随着x的抽象层级不断下降，自变量到UI变化的路径条数就会增多。路径越多，则意味着前端框架在运行时消耗在“寻找自变量与UI对应关系"上面的时间越少。

根据上面的特点，就可以对现代前端框架分为三大类：

+ 元素级框架
+ 组件级框架
+ 应用级框架

以常见的前端框架React为例，它属于应用级框架，Vue属于组件级框架，而新的Svelte、Solid.js属于元素级别框架

### 问题解答

题目：现代前端框架不仅仅是React、Vue,还出现了像Svelte、Solid.js 之类的框架，你觉得这些新框架相比React、Vue有什么样的区别?

解答：

所有的现代前端框架，都有一个非常重要的特点，那就是“基于状态的声明式渲染”。概括成一个公式的话，那就是UI = f (state)

这里有一点类似于自变量与因变量之间的关系。例如在上面的公式中，state 就是一个自变量，state 的变化会导致 UI 这个因变量发生变化。

不同的框架，在根据自变量(state) 的变化计算出UI的变化这一步骤有所区别，自变量和x (应用、 组件、UI) 的对应关系，随着x抽象的层级不断下降，"自变量到UI变化”的路径则不断增多。路径越多，则意味着前端框架在运行时消耗在寻找”自变量与 UI 的对应关系"上的时间越少。

以“与自变量建立对应关系的抽象层级"可以作为其分类的依据，按照这个标准，前端框架可以分为以下三类:

+ 元素级框架
+ 组件级框架
+ 应用级框架

以常见的前端框架为例，React 属于应用级框架，Vue属于组件级框架，Svelte、 Solid.jis 属于元素级框架。