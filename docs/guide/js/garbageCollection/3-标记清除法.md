# 标记清除法

由于引用计数法无法处理循环引用的问题，早期浏览器经常出现内存泄漏的问题。

为了解决它，后面浏览器引入了标记清除法来解决这个问题。

## 原理

标记-清除法，该算法分为两个阶段，**标记阶段**和**清除阶段**：

- 标记阶段：从根（root）出发（根是全局对象），遍历所有的可达对象，在遍历的过程中，给所有找到的、从根出发可以访问到的对象标记上活动对象（reachable/alive）的标记

- 清除阶段：垃圾回收器会再次遍历所有的对象，对于没有标记过"存活"的对象，进行回收

其中可达对象，就是说我们通过一些方式能够到达这个对象，比如一个对象作为函数的参数，在函数的内部就可以访问到，或者一个对象作为另一个对象的属性，我们可以通过引用链找到它。

我们可以举个代码例子，来说明谁被标记：

```js
// 全局变量可以被视为根，所以可达
let globalVariable = {
    name: "我是全局变量"
}
// 函数的参数和内部变量在函数内部可以访问，所以可达
function fn(some) {
    let funVariable = {
        name: "我是函数内部的变量"
    }
    console.log(some, funVariable)
}
fn(globalVariable)
// 对象的属性可以通过对象引用链从根访问，所以可达
let obj1 = {
    objProperty: {
        name: "我是对象内部的属性"
    }
}
console.log(obj1.objProperty)
```

- `globalVariable`是全局变量，因此只要不关浏览器，它就会一直存在，标记存活
- `some`和`funVariable`是函数内部的变量，它的存活周期是在函数`fn`执行的时候存在，在函数执行的时候，标记存活，在执行完毕之后，不标记，将其作为垃圾回收
- `obj1`是全局变量，一直存在，标记存活，而`objProperty`通过`obj1`可以访问，由于`obj1`一直存在，所以`objProperty`也就存在，标记存活

## 解决

根据上面的例子，刚刚的循环引用问题就被解决了，还是刚刚的代码：

```js
function test() {
	let obj1 = { name: "obj1" }
	let obj2 = { name: "obj2" }

	obj1.otherObject = obj2
	obj2.otherObject = obj1
}
test()
```

在标记清除法中，我们通过根节点出发访问，在函数执行完毕后，我们无法通过根节点，即`window`访问到它，因此它没有被标记，就正常被当做垃圾回收了。

所以即使出现循环引用，也因为无法从根节点访问到它，就无法被标记存活，从而回收。

## 缺点

那么标记清除法有什么缺点呢？就是会出现内存碎片，我们来看一个图：

![image-20240821201742398](https://chen-1320883525.cos.ap-chengdu.myqcloud.com/img/image-20240821201742398.png)

由于在清除结束之后，剩余的对象内存位置是不变的，这就导致空闲的内存空间是**不连续的**，这就出现了内存碎片，由于它不是一个整体，而是不同大小内存组成的内存列表，会出现内存分配的问题。

假设我们需要分配一个大小为 size 的内存空间，应该如何寻找它呢？

![image-20240821202042428](https://chen-1320883525.cos.ap-chengdu.myqcloud.com/img/image-20240821202042428.png)

一般情况下，我们会有三种策略：

- `First-fit`，一个个试，找到大于等于 size 的内存块就立即返回
- `Best-fit`，遍历整个空闲内存列表，返回大于等于 size 的最小分块
- `Worst-fit`，遍历整个空闲内存列表，找到最大的分块，然后分割成两部分，一部分为 size 大小，并将该部分返回

但无论是哪一个算法，都有着下面的缺点：

- **内存碎片化**：空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块
- **分配速度慢**：即使使用`First-fit`策略，它的时间复杂度仍是`O(n)`，最坏的情况是每次都要遍历到最后，同时因为碎片化导致大对象的分配速度会更加缓慢。

## 标记整理法

归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了

而 **标记整理（Mark-Compact）算法** 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）

![image-20240821203033266](https://chen-1320883525.cos.ap-chengdu.myqcloud.com/img/image-20240821203033266.png)

各家的浏览器都在标记清除法的基础上进行改进，下一节我们看看 V8 的垃圾回收。