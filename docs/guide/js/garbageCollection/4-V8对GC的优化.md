# V8 对 GC 的优化

我们前面讲过，现在大多数浏览器都基于标记清除法进行改进，V8 自然也对其进行了优化

> 下面的 GC 就是垃圾回收，垃圾回收英文单词：garbage collection

## 分代式垃圾回收

试想一下，我们前面的算法每次回收的时候都需要检查内存中的所有对象，这样有不好的地方：

- 一些大、老、存活时间长的对象，需要时间长，且不需要频繁进行清除
- 一些小、新、存活时间短的对象则相反

为了优化这个点，V8 引入了分代式垃圾回收

### 新老生代

V8 将堆内存分为**新生代**和**老生代**两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收

新生代的对象为**存活时间较短**的对象，简单来说就是新产生的对象，通常只支持 `1～8M` 的容量

老生代的对象为存活时间较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大

V8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）

![image-20240821203559778](https://chen-1320883525.cos.ap-chengdu.myqcloud.com/img/image-20240821203559778.png)

对于这两块区域，V8 采用了两个垃圾回收器管控，我们暂用新老生代垃圾回收器代称。

### 新生代垃圾回收

新生代区域中的对象，通过一个名为`Scavenge`的算法进行垃圾回收，它主要采用一种复制式的方法即`Cheney`算法来实现。

`Cheney`算法将堆内存一分为二，一个是处于闲置状态的空间我们暂称**空闲区**，一个是处于使用状态的空间我们暂称**使用区**，如下图：

![image-20240821203949652](https://chen-1320883525.cos.ap-chengdu.myqcloud.com/img/image-20240821203949652.png)

其中新加入的对象都会进入使用区，在使用区快要满了之后，就会执行一次垃圾回收操作。

当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记之后，将使用区的活动对象**复制到**空闲区并进行排序（这里其实就是整理操作，避免内存碎片），随后进入垃圾清理阶段，清除使用区数据对象。最后进行**角色互换**，把原来的使用区变为空闲区，原来的空闲区变为使用区。

当一个对象**多次复制后依旧存活**，就被认定为存活时间长的对象，将其移动到老生代空间区域中。

还有一种情况，即复制某个对象到空闲区的时候，空闲区空间占用超过了 25%，那么该对象会直接移动到老生代空间区域中。设置 25% 的原因是，当完成垃圾回收后，空闲区将角色互换为使用区，然后继续进行对象内存分配，如果一个对象占比过大，会影响后续的内存分配

### 老生代垃圾回收

相比于新生代，老生代的垃圾回收比较容易，上面我们已经知道，老生代中，要么是存活时间长的对象，要么是内存比较大的对象，如果用新生代那样不停复制然后互换会非常耗费时间。

因此老生代就采用了上一节的标记清除算法。它会从根节点出发，标记可达对象，然后清除没有标记的对象，但会产生内存碎片，所以 V8 也使用了上节的标记整理算法来优化这个问题

### 为什么需要分代式

为什么 V8 需要分代式，它有什么优点呢？

分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，它不同于老生代的标记清除法，由于频率高，将垃圾回收机制的效率也提高了。

所以分代式它就是为了优化标记清除法的效率问题。

## 并行回收

在介绍这个之前，我们需知一个概念即**全停顿**，我们知道 JS 是一个单线程语言，它运行在主线程上，在进行垃圾回收的时候会阻塞 JS 的执行，需要等待垃圾回收完毕后才能恢复，这个行为就是全停顿。

比如如果一次垃圾回收 GC 需要 600ms 的时候，那么我们的系统应用就会暂停 600ms，当一次 GC 的时间过长就会造成页面卡顿等问题。

既然存在一次 GC 比较耗时的情况，就如同写一个系统一样，我们可以招多个员工来一起写，换到程序就是可以引入多个**辅助线程**来同时处理。为了解决这个问题，V8 引入了并行回收机制

所谓并行，就是同时执行的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个**辅助线程**，同时执行同样的回收工作

![image-20240821205722785](https://chen-1320883525.cos.ap-chengdu.myqcloud.com/img/image-20240821205722785.png)

简单来说，原本主线程一个人干需要 3 秒，现在叫上了 2 个辅助线程和主线程一块干活，那三个人一块干一个人干 1 秒就完事了，考虑到主线程协同辅助线程也需要一定时间，再加上个 0.5 秒，那么原本主线程需要 3 秒，现在只需要 1.5 秒，直接大大缩短了时间。

不过虽然缩短了，但这个时间内，主线程依旧需要阻塞 JS 执行，但由于该过程中无需考虑内存中的对象引用关系，只需要考虑协同辅助线程，因此实现就比较简单。

在新生代的对象空间中，它就采用了并行回收策略，在执行垃圾回收的时候，会启动多个线程来负责新生代中的垃圾清理操作，这些线程将对象空间数据移动到空闲区，该过程中由于数据地址发生改动，所以还需要同步更新这些对象的地址，这就是需要协同的时间了。

### 增量标记与惰性清理

上面说到的并行回收虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但由于它还会产生全停顿，对于老生代中一些大的对象在 GC 时候，依旧可能会消耗大量时间

为了减少全停顿时间，2011 年 V8 对老生代的标记进行了优化，从全停顿标记切换到增量标记

#### 什么是增量

增量就是将一次 GC 标记的过程，分成了很多小步骤，每次执行完一小步，就让 JS 执行一会，这样交替进行多次之后，完成一轮 GC 标记，如图：

![image-20240821211019900](https://chen-1320883525.cos.ap-chengdu.myqcloud.com/img/image-20240821211019900.png)

那么这个过程会产生几个问题：

- 每一小次 GC 标记执行完之后如何暂停去执行 JS 逻辑，然后又如何恢复这个步骤
- 在一次完整的 GC 标记分块暂停后，JS 中又修改了内存中已经被标记好的对象引用关系，如何知道

可以看到，这里问题的复杂性上升了，为了解决它们，V8 的解决方案是 三色标记法与写屏障

#### 三色标记法（暂停与恢复）

我们之前学到了老生代采用了标记清除法，也就是说，在没有采用增量之前，我们标记数据可以只采用黑色和白色来区分，它会遍历所有对象，可达对象标记为黑色，表示存活，然后清除白色的垃圾

而如果使用黑白的标记策略，使用增量执行了一小段 GC 标记，暂停后去启动主线程执行 JS，然后再次启动，此时内存中黑白都有，我们不知道下一步应该去哪里。

为了解决它，V8 采用了一种特殊标记：**三色标记法**

三色标记法，就是使用每个对象的两个标记位和一个标记工作表来实现标记，有三个颜色 白、黑、灰

- 白色：指没有被标记的对象
- 灰色：指自身被标记，成员变量（该对象的引用对象）没有被标记
- 黑色：指自身和成员变量都没有被标记

![image-20240821212003296](https://chen-1320883525.cos.ap-chengdu.myqcloud.com/img/image-20240821212003296.png)

我们用上面的图做解释，最初所有对象都是白色，意味着垃圾回收器还没有回收它们，然后从根对象 root 开始，先将 root 标记为灰色并推入标记工资表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色。

一直走下去，直到没有灰色标记的对象，即没有可达对象了，剩下的白色对象都是无法到达的，回收

通过三色标记法，我们在恢复执行时就可以通过当前内存中有没有灰色节点来判断整个标记是否完成，没有灰色就可以进入清理阶段，如果还有灰色，就从灰色的节点开始继续执行即可。

三色标记法的 mark 操作可以渐进执行的而不需每次都扫描整个内存空间，可以很好的配合增量回收进行暂停恢复的一些操作，从而减少 全停顿 的时间

#### 写屏障（增量中修改引用）

一次完整的 `GC` 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了，增量中修改引用，可能不太好理解，我们举个例子（如图）

![image-20240821212520202](https://chen-1320883525.cos.ap-chengdu.myqcloud.com/img/image-20240821212520202.png)

假设有 A、B、C 三个对象依次引用，在第一次增量标记的时候我们全部标记为黑色，然后执行下面的 JS 代码，在 JS 中我们将 B 的指向**从 C 改为了 D**，然后恢复执行下一个增量标记。

我们发现此时 C 已经没有引用关系了，但由于它目前是黑色，所以**这一轮**的`GC`不会清理 C，不过就算这一轮不清理，下一轮的`GC`也会清理它，所以影响不大。

我们的主要影响是如图，刚刚添加的新对象`D`是初始的白色，此时没有了灰色对象，垃圾回收器会认为接下来需要进行清理，但由于`D`是白色，它明明还有引用关系，却也被清理了，这就不对了。

为了解决这个问题，V8 使用**写屏障(Wirte-barrier)**机制，即一旦有黑色的对象引用白色对象，该机制会强制将引用的白色对象改为灰色，保证下一次增量标记正确标记它，该机制也叫**强三色不变性**

引入它之后，刚刚的`D`由于是黑色对象`B`引用，会被强制改为灰色，就在下一轮增量中正常标记了。

#### 惰性清理

增量标记只是对各个对象进行标记工作，真正的清理然后释放内存，V8 采用了**惰性清理**

在增量标记完成后，惰性清理就开始了，它的特点是假如当前的可用内存可以快速执行我们的代码，它不会立即清理内存，而是会让清理过程**延迟一下**，先让 JS 代码执行。

它也不会一次性清理完所有的非活动对象内存（即白色对象），会按需逐一进行清理直到所有白色对象清理完毕，再接着执行增量标记。

#### 优缺点

增量标记与惰性清理的出现，使主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 `JavaScript` 代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化，所以增量标记缺点也很明显：

- 首先并没有减少主线程的**总暂停时间**，甚至会略微增加
- 由于写屏障机制，增量标记可能会降低应用程序的吞吐量

## 并发回收

前面我们介绍并行回收依旧会阻塞主线程，增量标记虽然减少了全停顿，但也有增加总暂停时间和降低应用吞吐量两个缺点，那么能否解决这些问题，得到一个更高效的方案呢？

这就是并发回收，它指的是主线程执行 JS 过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起阻塞

![image-20240821214142557](https://chen-1320883525.cos.ap-chengdu.myqcloud.com/img/image-20240821214142557.png)

辅助线程执行垃圾回收，主线程可以自由执行而不会被挂起，这是并发的优点，同时也是它实现的难点，因此它需要考虑在主线程执行 JS 的过程中，堆内存中的对象引用随时可能发生变化，此时辅助线程之前做的一些标记便需要修改，所以它需要额外实现一些读写锁机制来控制，这里不细说。

## 总结

V8 的垃圾回收策略采用分代式垃圾回收机制，新生代垃圾回收器采用并行回收提高效率，而老生代垃圾回收器采用并行回收、增量标记与惰性回收、并发回收这三个策略融合实现。

老生代主要采用**并发标记**，主线程执行 JS 时候，辅助线程也同时执行标记操作（标记操作全由辅助线程完成），标记完成后，再执行**并行清理操作**（主线程在执行清理操作，辅助线程也在同时执行），同时，清理的任务会采用**增量的方式**分批在各个 JS 任务之间执行。

参考文章：https://juejin.cn/post/6981588276356317214
