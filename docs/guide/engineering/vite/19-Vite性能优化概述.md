# Vite 性能优化概述

我们平时说的性能优化是在说什么呢？包括几个方面：

- 开发时候的构建速度优化：npm run dev 敲下的一瞬间到呈现结果要占用多少时长

  - webpack 在这方面很多：cache-loader cache loader 结果(如果两次构建源代码没有产生变化，则直接使用缓存 不调用 loader)，thread-loader，开启多线程去构建...
  - vite 是按需加载，所以我们不需要太关心这方面

- 页面性能指标：和我们写代码有关

  - 首屏渲染时长：fcp(first content paint) (也有叫页面中第一个元素的渲染时长)

    - 懒加载：需要我们写代码实现
    - http 优化：强缓存和协商缓存
      - 强缓存：服务端给响应头追加一些字段(expires 代表截止失效时间)，客户端会记住这些字段，在 expires 没有到达之前，无论怎么刷新页面，浏览器都不会重新请求而是从缓存中里取
      - 协商缓存：是否使用缓存要和后端商量，当服务端给我们打上协商缓存的标记以后，客户端在下次刷新页面需要重新请求资源时会发送一个协商请求给服务端，服务端如果需要说需要变化，则会响应具体的内容，如果没有变化则会响应 304 状态码

  - 页面中最大元素的一个时长：lcp(largest content paint)

  - ......

- js 逻辑：

  - 我们要注意副作用的清除，在应用中组件是会频繁的挂载和卸载，比如我们在某一个组件中有计时器，如果我们在卸载的时候不清除这个计时器，下次再次挂载的时候计时器等于有两个线程了

  - 我们在写法上的注意事项：`requestAnimationFrame`、`requestIdleCallback`一些新的 API

    - 浏览器的帧率：16.6 ms 去更新一次（执行 js 逻辑以及 重排重绘...），假设我的 js 执行逻辑超过 16.6ms，就会阻塞导致卡顿掉帧，可以通过 api 将 js 放入每 16.6 ms 剩余的时间中执行，就不会卡顿了

  - 防抖、节流，或者用 lodash 工具库，比如一个数组有很多数组，不要用原生的 forEach，用 lodash 的，这个工具库有很多算法可以提高性能

  - 对作用域的控制

    - ```js
      const arr = [1, 2, 3];
      for (let i = 0, len = arr.length; i < len; i++) {}
      ```

  - ...

- css
  - 关注继承属性：能继承就不要重复写
  - 尽量避免太过于深的 css 嵌套
- 构建优化：构建工具如 vite(rollup) webpack
  - 优化体积：压缩、treeshaking、图片资源压缩
  - cdn 加载、分包 ······
- ······
